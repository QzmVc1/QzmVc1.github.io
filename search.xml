<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Web: Gin框架学习笔记</title>
      <link href="/Go-Web-Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/Go-Web-Gin%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Gin框架介绍"><a href="#一、Gin框架介绍" class="headerlink" title="一、Gin框架介绍"></a>一、Gin框架介绍</h3><p><code>Gin</code>是一个用Go语言编写的web框架。它是一个类似于<code>martini</code>但拥有更好性能的API框架, 由于使用了<code>httprouter</code>，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上<code>Gin</code>。</p><p>Go世界里最流行的Web框架，<a href="https://github.com/gin-gonic/gin">Github</a>上有<code>32K+</code>star。 基于<a href="https://github.com/julienschmidt/httprouter">httprouter</a>开发的Web框架。 <a href="https://gin-gonic.com/zh-cn/docs/">中文文档</a>齐全，简单易用的轻量级框架。</p><h4 id="1-1-Gin框架安装与使用"><a href="#1-1-Gin框架安装与使用" class="headerlink" title="1.1 Gin框架安装与使用"></a>1.1 Gin框架安装与使用</h4><p>下载并安装<code>Gin</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="1-2-第一个Gin示例"><a href="#1-2-第一个Gin示例" class="headerlink" title="1.2 第一个Gin示例"></a>1.2 第一个Gin示例</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line"><span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p><h3 id="二、JSON渲染"><a href="#二、JSON渲染" class="headerlink" title="二、JSON渲染"></a>二、JSON渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">Age     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">msg.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.JSON(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、获取参数"><a href="#三、获取参数" class="headerlink" title="三、获取参数"></a>三、获取参数</h3><h4 id="3-1-获取querystring参数"><a href="#3-1-获取querystring参数" class="headerlink" title="3.1 获取querystring参数"></a>3.1 获取querystring参数</h4><p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。 获取请求的querystring参数的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 可以添加默认值</span></span><br><span class="line">username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line"><span class="comment">//username := c.Query(&quot;username&quot;)</span></span><br><span class="line">address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输入对应的URL，就能获取到对应的参数了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9090/web?username=小王子&amp;address=沙河</span><br></pre></td></tr></table></figure><h4 id="3-2-获取form参数"><a href="#3-2-获取form参数" class="headerlink" title="3.2 获取form参数"></a>3.2 获取form参数</h4><p>请求的数据通过form表单来提交，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.POST(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line"><span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;小王子&quot;)</span></span><br><span class="line">username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.PostForm(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-获取path参数"><a href="#3-3-获取path参数" class="headerlink" title="3.3 获取path参数"></a>3.3 获取path参数</h4><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-参数绑定"><a href="#3-4-参数绑定" class="headerlink" title="3.4 参数绑定"></a>3.4 参数绑定</h4><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User     <span class="keyword">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定JSON的示例 (&#123;&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;&#125;)</span></span><br><span class="line">router.POST(<span class="string">&quot;/loginJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;login info:%#v\n&quot;</span>, login)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">router.POST(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">router.GET(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p><ol><li>如果是 <code>GET</code> 请求，只使用 <code>Form</code> 绑定引擎（<code>query</code>）。</li><li>如果是 <code>POST</code> 请求，首先检查 <code>content-type</code> 是否为 <code>JSON</code> 或 <code>XML</code>，然后再使用 <code>Form</code>（<code>form-data</code>）。</li></ol><h3 id="四、文件上传"><a href="#四、文件上传" class="headerlink" title="四、文件上传"></a>四、文件上传</h3><h4 id="4-1-单个文件上传"><a href="#4-1-单个文件上传" class="headerlink" title="4.1 单个文件上传"></a>4.1 单个文件上传</h4><p>文件上传前端页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端gin框架部分代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 单个文件</span></span><br><span class="line">file, err := c.FormFile(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">&quot;C:/tmp/%s&quot;</span>, file.Filename)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-多个文件上传"><a href="#4-2-多个文件上传" class="headerlink" title="4.2 多个文件上传"></a>4.2 多个文件上传</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">&quot;C:/tmp/%s_%d&quot;</span>, file.Filename, index)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、重定向"><a href="#五、重定向" class="headerlink" title="五、重定向"></a>五、重定向</h3><h4 id="5-1-HTTP重定向"><a href="#5-1-HTTP重定向" class="headerlink" title="5.1 HTTP重定向"></a>5.1 HTTP重定向</h4><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.sogo.com/&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-2-路由重定向"><a href="#5-2-路由重定向" class="headerlink" title="5.2 路由重定向"></a>5.2 路由重定向</h4><p>路由重定向，使用<code>HandleContext</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指定重定向的URL</span></span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="六、Gin路由"><a href="#六、Gin路由" class="headerlink" title="六、Gin路由"></a>六、Gin路由</h3><h4 id="6-1-普通路由"><a href="#6-1-普通路由" class="headerlink" title="6.1 普通路由"></a>6.1 普通路由</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusNotFound, <span class="string">&quot;views/404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6-2-路由组"><a href="#6-2-路由组" class="headerlink" title="6.2 路由组"></a>6.2 路由组</h4><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>&#123;&#125;</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>&#123;&#125;</code>包裹功能上没什么区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">userGroup := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由组也是支持嵌套的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"><span class="comment">// 嵌套路由组</span></span><br><span class="line">xx := shopGroup.Group(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">xx.GET(<span class="string">&quot;/oo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h4 id="6-3-路由原理"><a href="#6-3-路由原理" class="headerlink" title="6.3 路由原理"></a>6.3 路由原理</h4><p>Gin框架中的路由使用的是<a href="https://github.com/julienschmidt/httprouter">httprouter</a>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h3 id="七、Gin中间件"><a href="#七、Gin中间件" class="headerlink" title="七、Gin中间件"></a>七、Gin中间件</h3><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><h4 id="7-1-定义中间件"><a href="#7-1-定义中间件" class="headerlink" title="7.1 定义中间件"></a>7.1 定义中间件</h4><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计耗时请求耗时的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatCost</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line"><span class="comment">// 计算耗时</span></span><br><span class="line">cost := time.Since(start)</span><br><span class="line">log.Println(cost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-注册中间件"><a href="#7-2-注册中间件" class="headerlink" title="7.2 注册中间件"></a>7.2 注册中间件</h4><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><p><img src="https://s4.ax1x.com/2022/01/30/HCUXGV.png" alt=""></p><p><img src="https://s4.ax1x.com/2022/01/30/HCUvxU.png" alt=""></p><p>中间的这个通过 Abort() 可以阻止执行</p><p><img src="https://s4.ax1x.com/2022/01/30/HCaSr4.png" alt=""></p><h4 id="7-2-1-为全局路由注册"><a href="#7-2-1-为全局路由注册" class="headerlink" title="7.2.1 为全局路由注册"></a>7.2.1 为全局路由注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.Use(StatCost())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="keyword">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-为某个路由单独注册"><a href="#7-2-2-为某个路由单独注册" class="headerlink" title="7.2.2 为某个路由单独注册"></a>7.2.2 为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="keyword">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="7-2-3-为路由组注册中间件"><a href="#7-2-3-为路由组注册中间件" class="headerlink" title="7.2.3 为路由组注册中间件"></a>7.2.3 为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。</p><p>写法1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-中间件注意事项"><a href="#7-3-中间件注意事项" class="headerlink" title="7.3 中间件注意事项"></a>7.3 中间件注意事项</h4><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h3 id="八、运行多个服务"><a href="#八、运行多个服务" class="headerlink" title="八、运行多个服务"></a>八、运行多个服务</h3><p>我们可以在多个端口启动服务，例如：</p><p>```go<br>package main</p><p>import (<br>    “log”<br>    “net/http”<br>    “time”</p><pre><code>&quot;github.com/gin-gonic/gin&quot;&quot;golang.org/x/sync/errgroup&quot;</code></pre><p>)</p><p>var (<br>    g errgroup.Group<br>)</p><p>func router01() http.Handler {<br>    e := gin.New()<br>    e.Use(gin.Recovery())<br>    e.GET(“/“, func(c *gin.Context) {<br>        c.JSON(<br>            http.StatusOK,<br>            gin.H{<br>                “code”:  http.StatusOK,<br>                “error”: “Welcome server 01”,<br>            },<br>        )<br>    })</p><pre><code>return e</code></pre><p>}</p><p>func router02() http.Handler {<br>    e := gin.New()<br>    e.Use(gin.Recovery())<br>    e.GET(“/“, func(c *gin.Context) {<br>        c.JSON(<br>            http.StatusOK,<br>            gin.H{<br>                “code”:  http.StatusOK,<br>                “error”: “Welcome server 02”,<br>            },<br>        )<br>    })</p><pre><code>return e</code></pre><p>}</p><p>func main() {<br>    server01 := &amp;http.Server{<br>        Addr:         “:8080”,<br>        Handler:      router01(),<br>        ReadTimeout:  5 <em> time.Second,<br>        WriteTimeout: 10 </em> time.Second,<br>    }</p><pre><code>server02 := &amp;http.Server&#123;    Addr:         &quot;:8081&quot;,    Handler:      router02(),    ReadTimeout:  5 * time.Second,    WriteTimeout: 10 * time.Second,&#125;</code></pre><p>   // 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务<br>    g.Go(func() error {<br>        return server01.ListenAndServe()<br>    })</p><pre><code>g.Go(func() error &#123;    return server02.ListenAndServe()&#125;)if err := g.Wait(); err != nil &#123;    log.Fatal(err)&#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> Go Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(12):TDAR</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-12-TDAR.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-12-TDAR.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>由于在电子商务和视频网站等各种在线平台上的普遍应用，推荐系统获得了广泛的研究关注。在实际应用中，隐式反馈数据（一类数据，如点击和购买等）被广泛使用，因为它易于收集且普遍适用。实际应用中的推荐通常存在严重的稀疏性问题，这会导致两个困难：</p><ul><li>没有足够的交互来为模型学习提供信息。此外，数据高度不平衡：大多数用户和物品与系统只有很少的交互，这使得推荐任务更加困难。</li><li>由于我们在隐式反馈中只观察到一小部分正样本，现有的负采样策略是将未观察到的样本视为负样本。然而，通过这种方式，许多潜在的正样本被错误地标记为负样本，并且模型被标签噪声严重误导，尤其是在稀疏数据上。</li></ul><p>为了解决上述挑战，我们采用迁移学习来丰富稀疏数据集上的信息，并且我们专注于没有用户和物品重叠的跨域推荐。具体来说，我们分别在稠密和稀疏数据上训练源模型和目标模型，并探索域自适应以对齐embeddings（即隐向量 latent factors），这是协同过滤 (CF) 模型中对用户偏好进行编码的关键组成部分。然而，在基本的 CF 模型中，没有具有特定语义的数据（例如图像和文本），我们通过将用户和物品嵌入（embedding）到潜在空间中来提取高级的密集特征。通过这种方式，我们将来自不同领域的用户和物品映射到不同的潜在空间。为了对齐潜在空间，我们探索域不变特征作为锚点。在本文中，我们利用了可以从用户评论（review）中轻松提取的文本特征。将文本特征与embeddings拼接起来，从而将空间扩展为文本潜在空间。对于域自适应，我们使用连接的embeddings和文本特征作为域分类器的输入。embeddings使用分类器进行对抗训练，而文本特征则固定。</p><p>正如我们所见，在我们的策略中，文本特征应该是域不变的，例如，来自所有域的恐怖电影都映射到文本空间的负半轴。现有的许多模型 提取文本特征用于推荐，而这些特征不是域不变的。为了缩小这一差距，首先，我们提出了一种称为文本记忆网络 ( Text Memory Network，TMN) 的记忆结构，通过将每个用户和物品映射到单词语义空间（word semantic space）来提取文本特征；然后，我们将这些特征注入 CF 模型以生成预测，这个由文本特征和CF模块组成的模型被命名为文本协同过滤（Text Collaborative Filtering，TCF）模型；最后，我们在源域和目标域上同步训练两个 TCF 模型，并通过自适应网络将它们连接起来。这个迁移学习模型被命名为文本增强域自适应推荐 (Text-enhanced Domain Adaptation Recommendation，TDAR) 方法。</p><p>原文链接：<a href="https://dl.acm.org/doi/pdf/10.1145/3394486.3403264">Semi-supervised Collaborative Filtering by Text-enhanced Domain Adaptation</a></p><span id="more"></span><h3 id="二、Text-Memory-Network-TMN"><a href="#二、Text-Memory-Network-TMN" class="headerlink" title="二、Text Memory Network(TMN)"></a>二、Text Memory Network(TMN)</h3><p>在本文中，粗体大写字母表示矩阵。假设总共有 $M$ 个用户和 $N$ 个物品，我们使用矩阵 $R$ 来表示用户和物品之间的交互。如果用户 $u$ 投票给物品 $i$，则 $R_{ui}=1$ ，否则 $R_{ui}=0$。我们的任务是对缺失值（ $R$ 中的 0 ）进行预测（表示为 $\hat{R}$ )。在本节中，我们<strong>根据评论构建特定用户和特定物品的文本表示</strong>，我们分别提取源域和目标域的文本特征。</p><p>以用户 $u$ 为例，我们构造了一个评论集$R_u=\mathop{\cup}\limits_{i=1}^{N}r_{ui}$ ，其中 $r_{ui}$ 是一个包含 $u$ 对 $i$ 的评论的词的集合。如果 $u$ 与 $i$ 没有交互，则 $r_{ui}=0$。类似地，物品 $i$ 的评论集是 $R_i=\mathop{\cup}\limits_{u=1}^{M}r_{ui}$。我们用 $W$ 来表示词集：$W=\mathop{\cup}\limits_{u=1}^M\mathop{\cup}\limits_{i=1}^Nr_{ui}$  ，用 $H$ 来表示词的总数：$H=|W|$ 。由于我们想要提取域不变的文本特征（即来自所有域的特征都在同一空间中），我们通过<strong>线性组合</strong>评论的词语义(word semantic)向量将所有用户和物品映射到词语义空间。</p><p> $S$ 是word2vec在GoogleNews语料库上预训练的词语义矩阵，  $S_w$ 表示词 $w$ 的语义特征。我们使用 $E$ 和 $F$ 分别表示我们为用户和物品构建的文本特征。以用户 <img src="https://www.zhihu.com/equation?tex=u" alt="[公式]"> 为例，$E_u=\mathop{\sum}\limits_{w\in R_u}a_{uw}S_w$ ，其中 $a_{uw}$ 是词 $w$ 基于 $u$ 的语义偏好的权重。我们提出了一个文本记忆网络 (TMN) 来计算用户 $a_{uw}$ 和物品 $a_{iv}$ 的权重，以根据单词语义构建文本特征。</p><p>对一个喜欢恐怖电影的用户 $u$ ，$u$ 可能更喜欢相关的词（比如“horrible”、“frightened”、“terrifying”），对不相关的词（比如“this”、“is”、“a ”）和相反的词（如“funny”、“relaxing”、“comical”）没兴趣。 对于 $u$ 偏爱的词 $w$，我们需要为 $w$ 设置一个很大的权重 $a_{uw}$。在物品方面，对于恐怖片 $i$，$i$ 的评论中的相关词提供了很多关于 $i$ 的信息，而不相关或相反的词提供的信息很少。针对对 $i$ 很重要的词 $v$，我们需要设置一个很大的权重 $a_{iv}$。容易看出，在这个任务中，我们的目标是向用户和物品推荐偏好词 (preferred words)。</p><p>受矩阵分解的启发，我们分别为用户、物品和单词声明了三个矩阵 $P,Q,T$。 以用户为例，我们使用 $e_{uw}=P_uT^T_w$  来建模 $u$ 对单词 $w$ 的偏好。 为了进一步强调重要的词，我们将 $e_{uw}$ 输入到 softmax 函数中以获得 $a_{uw}$，$a_{uw}=\frac{exp(e_{uw})}{\mathop{\sum}\limits_{w’\in R_u}exp(e_{uw’})}$ 。 针对物品 $a_{iv}$ 的权重以相同的方式构造。 我们最终通过 $\hat{R}=\sigma(EF^T)$ 来预测用户对物品的偏好，我们使用交叉熵损失作为我们的损失函数：</p><script type="math/tex; mode=display">L=-\mathop{\sum}\limits_{u,i}R_{ui}log\hat{R}_{ui}+(1-R_{ui})log(1-\hat{R}_{ui})</script><script type="math/tex; mode=display">\hat{R}_{ui}=\sigma[(\mathop{\sum}\limits_{w\in R_u}\frac{exp(P_uT_w^T)}{\mathop{\sum}\limits_{w'\in R_u}exp(P_uT_{w'}^T)})(\mathop{\sum}\limits_{v\in R_i}\frac{exp(Q_iT_v^T)}{\mathop{\sum}\limits_{v'\in R_i}exp(Q_iT_{v'}^T)})]</script><h3 id="三、文本增强跨域推荐"><a href="#三、文本增强跨域推荐" class="headerlink" title="三、文本增强跨域推荐"></a>三、文本增强跨域推荐</h3><p>在通过 TMN 提取文本特征后，我们将在本节中介绍我们的文本增强域自适应推荐 (TDAR) 模型。 首先，我们将文本特征注入到 CF 模型中以提出基本的 TCF 模型。 然后，我们同时在目标域和源域上训练两个 TCF 模型，并通过域自适应对齐用户和物品嵌入。</p><h4 id="3-1-文本协同过滤TCF"><a href="#3-1-文本协同过滤TCF" class="headerlink" title="3.1 文本协同过滤TCF"></a>3.1 文本协同过滤TCF</h4><p>记 $U,V$ 分别是用户和物品的embedding向量构成的矩阵。我们连接embedding和文本特征，因此用户和物品的表示是 $[U,E]$ 和 $[V,F]$。我们用以下公式预测用户偏好：</p><script type="math/tex; mode=display">\hat{R}_{ui}=f([U,E]_u,[V,F]_i,\Theta)</script><p>其中，$f(\cdot,\Theta)$ 是结合用户和物品 embedding 并返回偏好预测的<strong>交互函数</strong>，$\Theta$ 表示参数。 我们通过最小化交叉熵来学习模型。在这个模型中，$U,V,\Theta$ 是可训练的参数， 而 $E$ 和 $F$ 是固定的。</p><h4 id="3-2-文本增强域自适应推荐"><a href="#3-2-文本增强域自适应推荐" class="headerlink" title="3.2 文本增强域自适应推荐"></a>3.2 文本增强域自适应推荐</h4><p>在本小节中，我们使用上标 $s,t,u,i$ 分别表示源域、目标域、用户和物品。$R_s$ 和 $R_t$ 表示源域和目标域上的交互。 我们在两个域上训练两个 TCF，同时共享相同的交互函数，因此对两个域中数据集的预测由下式给出：</p><script type="math/tex; mode=display">\hat{R}_{u^si^s}^s=f([U^s,E^s]_{u^s},[V^s,F^s]_{i^s},\Theta)</script><script type="math/tex; mode=display">\hat{R}_{u^ti^t}^t=f([U^t,E^t]_{u^t},[V^t,F^t]_{i^t},\Theta)</script><p>然后我们在两个 TCF 上添加自适应网络以实现迁移学习。 考虑到用户和物品 embedding 的分布模式可能不同，我们<strong>分别对用户和物品通过DANN模型的思想进行域自适应</strong>(有关DANN的介绍参见<a href="https://qzmvc1.top/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-11-DANN%E4%B8%8EDARec.html">我的推荐算法之路(11):DANN与DARec</a>)。TDAR模型结构如下图所示：</p><p><img src="https://s4.ax1x.com/2022/01/16/7NKH3j.png" alt=""></p><p>在 TDAR 中，两个基本模型由标签和域分类器共同监督。 正如前文中所讨论的，目标域上的负标签受噪声严重污染，但正标签是纯净的，因此我们放弃了负样本。不幸的是，在隐式反馈案例中仅使用正样本进行监督会导致一个新问题——该模型倾向于将所有项目预测为正项目。为了解决这个问题，我们利用域自适应机制来监督目标域上的基本模型以及正样本。 但是，作为双域系统，需要对整个系统进行负采样。 考虑到源域通常比目标域密集得多，负标签的质量要高得多，我们采用源域进行负监督，并通过域适应将负监督转移到目标域。</p><p>对于文本特征 $E$ 和 $F$  ，我们可以在 TDAR 训练期间预训练并固定它们，也可以从头开始与TDAR联合训练。 实验表明，联合训练使模型更难以调优，且没有实现性能提升，因此我们选择了前一种策略。 实验还表明，与学习用户和物品 embedding 相比，学习到的文本特征对标签噪声的鲁棒性要强得多。 </p><h3 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/424639071">https://zhuanlan.zhihu.com/p/424639071</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(11):DANN与DARec</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-11-DANN%E4%B8%8EDARec.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-11-DANN%E4%B8%8EDARec.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Domain-Adaptation"><a href="#一、Domain-Adaptation" class="headerlink" title="一、Domain Adaptation"></a>一、Domain Adaptation</h3><p>想象一个分类任务，假设现在我们手里有源域数据和目标域数据，其中源域数据是丰富并且有标记的，而目标域数据是充足但是没有标记的，但是源域和目标域的特征空间和标记空间相同。很显然，我们可以轻松的利用源域数据为源域建立一个分类器，但是由于目标域数据本身没有标记，那么我们无法通过常规方法为目标域构建分类器，这时候Domain adaptation 就可以发挥作用了。</p><p>从下图中可以看到（图片来自<a href="https://zhuanlan.zhihu.com/p/51499968">知乎</a>），源域和目标域的特征都是 $\{x_1,x_2\}$，并且有相同的标记 $\{-1，+1\}$，但是在目标域数据的标记是不可获得的。此外，虽然源域和目标域的特征空间相同，但是两者的特征分布却不同。那么我们如何做到利用源域数据来帮助目标域进行分类呢？</p><p>这里最关键的一点就是在同一个特征空间中源域和目标域的分布不同，假设两者分布相同，那么我们就可以直接利用源域分类器对目标域数据进行分类了。因此，Domain adaptation的思想就是通过消除源域和目标域的分布差异，使得源域数据和目标域数据能同时被分开。在图中，通过映射函数 $\phi$ 将源域数据和目标域数据映射到某个空间中，并且将属于 +1 的样本混合在一起，属于 -1 的样本混合在一起。由于源域数据有标记，所以可以利用源域数据建立分类器。又因为源域数据和目标域数据混合在一起了，所以在分开源域样本的同时目标域样本也被分开了，这样任务就完成了。</p><span id="more"></span><p><img src="https://pic2.zhimg.com/v2-0975878ddcedfaf101b10358317b8691_r.jpg" alt=""></p><h3 id="二、Domain-Adversarial-Training-of-Neural-Networks-DANN"><a href="#二、Domain-Adversarial-Training-of-Neural-Networks-DANN" class="headerlink" title="二、Domain-Adversarial Training of Neural Networks(DANN)"></a>二、Domain-Adversarial Training of Neural Networks(DANN)</h3><p>在上面的 Domain Adaptation 过程中最关键的一点就是如何做到将源域样本和目标域样本混合在一起，并且还能保证被同时分开，DANN的主要任务也是做到这一点。</p><p>首先介绍一下DANN的应用背景：源域数据充足并且有标记，目标域数据充足但是无标记，源域和目标域的特征空间和标记空间相同，任务是借助源域数据对目标域数据进行分类。</p><p><img src="https://s4.ax1x.com/2022/01/16/7tbkgx.png" alt=""></p><p>网络分为三部分： </p><ul><li>Feature extractor(特征提取器)：提取后续网络完成任务所需要的特征；将源域样本和目标域样本进行映射和混合。</li><li>Label predictor (类别预测器)：利用Feature extractor提取的信息对样本进行分类。</li><li>Domain classifier(域分类器)：判断Feature extractor提取的信息来自源域还是目标域。</li></ul><p>可见，DANN中的对抗思想蕴含在特征提取器和域分类器中。其中特征提取器的作用就像是第一张图中的映射函数 $\phi$ 。但是我们并不知道  $\phi$ 的具体形式，也就是说<strong>我们不知道特征提取器的训练目标是什么</strong>，无法用一个网络来拟合函数 $\phi$。因此后面添加了域分类器，用来和特征提取器进行<strong>对抗训练</strong>。</p><p>特征提取器提取的信息会传入域分类器，之后域分类器会判断传入的信息到底是来自源域还是目标域，并计算损失。在反向传播更新参数的过程中，域分类器和特征提取器中间有一个<strong>梯度反转层</strong>（Gradient reversal layer），也就是说域分类器的训练目标是尽量将输入的信息分到正确的域类别（源域还是目标域），而特征提取器的训练目标却恰恰相反（由于梯度反转层的存在），特征提取器所提取的特征（或者说映射的结果）目的是域分类器不能正确的判断出信息来自哪一个域，因此形成一种对抗关系。可见，<strong>当域分类器不能将接收的信息正确分为源域样本还是目标域样本时</strong>，特征提取器的任务就圆满完成了，因为此时<strong>源域样本和目标域样本在某个空间中已经被混合在一起不能分开了。</strong></p><p>然而上述过程存在一个问题，我们最终的目的是对目标域样本进行分类，那么我们如何<strong>保证特征提取器提取的信息是能够用来分类</strong>的呢？假如无论输入什么样本给特征提取器，它都输出一个单位向量，这样依旧可以“骗过”域分类器，但是却无法完成后续的分类工作。</p><p>这时就要靠Label predictor (类别预测器)了，因为源域样本是有标记的，所以在提取特征时不仅仅要考虑后面的域分类器的情况，还要利用源域的带标记样本进行有监督训练从而兼顾分类的准确性。</p><p>综上所述，当把特征提取器、域分类器和类别预测器都训练完成后，就可以做到把源域和目标域混合在一起并且进行分类了。</p><h3 id="三、DRAec"><a href="#三、DRAec" class="headerlink" title="三、DRAec"></a>三、DRAec</h3><p>DRAec假设源域和目标域有相同的用户集合，items则是不同的。其模型结构如下所示：</p><p><img src="https://s4.ax1x.com/2022/01/16/7tqf0S.png" alt=""></p><p>DRAec主要用到了user-items-ratings评分矩阵，因为其是稀疏的，因此首先将其通过自动编码器AutoEncoder进行降维处理，取中间隐藏层作为embeddings向量；接着，对源域和目标域的embeddings向量进行交错排列，并将它们通过DANN网络进行训练，最终训练完成的Rating Pattern Extractor就可以将源域和目标域的特征向量映射到同一特征空间，这样，我们就可以进行跨域推荐了。</p><p>原文链接：<a href="https://arxiv.org/pdf/1905.10760.pdf">Deep Domain Adaptation for Cross-Domain Recommendation via Transferring Rating Patterns</a></p><h3 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/51499968">https://zhuanlan.zhihu.com/p/51499968</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(10):Cross-domain Recommendation via Deep Domain Adaptation</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-10-Cross-domain%20Recommendation%20via%20Deep%20Domain%20Adaptation.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-10-Cross-domain%20Recommendation%20via%20Deep%20Domain%20Adaptation.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>传统的推荐系统通常对用户过去的交互（例如评分或点击）做出假设来做出有意义的推荐。虽然这看起来很自然，但是，当假设不成立时，例如当新用户到达或我们的目标是对未使用的产品进行交叉销售时，这种系统的实用性就会降低。另一方面，随着网络服务种类的增加，冷启动用户的信息可以从他们在其他服务中的活动中获得。因此，利用来自其他相关领域的此类附加信息的跨域推荐系统近年来作为解决用户冷启动问题的有希望的解决方案获得了研究的关注 。</p><p>针对处理冷启动用户的跨域推荐，特别是在没有共同用户和item的情况。尽管可以推荐item并从目标用户那里获得反馈，但我们的目标是构建一个推荐系统，即使在这种替代方案不可用的情况下也可以工作。在这种情况下，一个主要的挑战是由于缺乏共同的用户，传统的方法不能用于两个服务之间的关系的引出。</p><p>该文研究了基于内容的方法，特别是，研究了一种跨域推荐的深度学习方法。深度学习已成功应用于推荐系统，除了在推荐系统应用中的成功之外，深度学习方法在迁移学习领域表现出更好的性能，因为它能够从数据中学习可迁移的特征。事实上，在领域自适应领域，深度神经网络在计算机视觉和自然语言处理任务中表现出最先进的性能。基于这一观察，该文假设深度神经网络的域适应也可以应用于跨域推荐。</p><p>领域自适应（Domain Adaptation）是一种使用从具有标记数据的一个域（源域）获得的知识来学习具有少量或没有标记训练数据的新域（目标域）的技术。通过域适应，可以将在源域中训练的分类器应用于目标域。为了实现领域自适应，该文使用了一种用于无监督域适应的神经网络架构，即 Bousmalis 等人提出的域分离网络（DSN）。此外，为了降低极端分类的难度和处理新item，该文通过堆叠去噪自动编码器（SDAE）来结合item特征。</p><p>原文链接：<a href="https://arxiv.org/pdf/1803.03018.pdf">Cross-domain Recommendation via Deep Domain Adaptation</a></p><span id="more"></span><h3 id="二、模型架构"><a href="#二、模型架构" class="headerlink" title="二、模型架构"></a>二、模型架构</h3><p>在该文中，假设输入数据采用隐式反馈的形式，例如点击日志。令 $Y=\{1,2,\cdots,L\}$ 是我们希望推荐的源域中的item集合。从用户对这些items的日志信息中，我们可以得到一个有标记的数据集 $X_S=\{x_i^S,y_i^S\}_{i=1}^{N_s}$。这里 $y_i^S$ 表示一个标签，$x_i^S$ 表示item的原始特征。在目标域中，由于两个域之间缺乏共同用户，我们只有一个未标记的数据集 $\{x_i^T\}_{i=1}^{N_T}$。我们的目标是向目标域中的用户推荐源域中的item。更正式地说，通过利用标记数据 $X_S$ 和未标记数据 $X_T$，我们的目标是构建一个分类器 $\eta(x^T)$，它定义了给定目标域中用户历史 $X^T$ 关于源域item集合 $Y$ 的概率分布。我们使用域分离网络 $DSN$ 对这个分类器进行建模。</p><p>例如，假设我们的任务是向使用新闻浏览服务的用户推荐视频。我们有源域中的视频服务和目标域中的新闻服务的用户日志。视频可以包含有关其自身的文本信息，例如演员或情节的描述。有了这些内容信息，我们可以使用 Bag of Words 或 TF-IDF 方案从视频列表中构建原始用户表示。与视频一样，我们可以使用新闻文章的文本信息为新闻用户构建表示。使用内容信息，我们获得源域（视频服务）的标记数据集和目标域（新闻服务）的未标记数据集。在这种情况下，任务是建立一个分类器，将新闻浏览历史作为输入，并为视频分配概率。</p><p>同时，我们也使用到了堆叠去噪自动编码器 (SDAE)。 它是一个前馈神经网络，可以学习输入数据的稳健表示。 </p><p>该文模型架构如下图所示，接下来，将对DSN和SDAE做一个详细介绍。</p><p><img src="https://s4.ax1x.com/2022/01/16/7tautI.png" alt=""></p><h3 id="三、Domain-Separation-Networks-DSNs"><a href="#三、Domain-Separation-Networks-DSNs" class="headerlink" title="三、Domain Separation Networks(DSNs)"></a>三、Domain Separation Networks(DSNs)</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><p>DSNs模型的作者是来自谷歌的研究者，该文发表在2016年的NIPS会议上，在这篇论文中，作者的工作重心放在了迁移学习三个核心问题之一：<strong>what to transfer</strong>，以及<strong>如何有效避免negative transfer上</strong>。在论文伊始，作者就提出之前已有的深度迁移学习算法都将注意力放在消除不同域之间的特征分布差异，但是Konstantinos Bousmalis（作者）等人从另一个角度来考虑了迁移学习问题，他们认为所有的域之间有着公有的特征(Shared)和私有的特征(Private)，如果将各个域的私有特征也进行迁移的话就会造成负迁移(negative transfer)。基于这一理念，他们提出了Domain Separation Networks(DSNs)。同时，作者为问题假设的前提是无监督迁移学习，也就是说目标域数据是没有标记的，源域数据有标记。因此，DSNs的主要工作分为两部分：</p><ul><li>提取不同域之间的公有特征</li><li>利用公有特征进行迁移</li></ul><h4 id="3-2-DSNs模型"><a href="#3-2-DSNs模型" class="headerlink" title="3.2 DSNs模型"></a>3.2 DSNs模型</h4><p><img src="https://s4.ax1x.com/2022/01/16/7tDwOf.png" alt=""></p><p>DSNs的主体结构是一个类似于自编码器的结构。整个结构可以分为如下五部分：</p><ul><li>Private Target Encoder $E_p^t(x^t)$ : 目标域私有编码器，用来提取目标域的私有特征。</li><li>Private Source Encoder $E_p^s(x^s)$ : 源域私有编码器，用来提取源域的私有特征。</li><li>Shared Encoder $E_c(x)$ : 共享编码器，用来提取源域和目标域的公有特征。</li><li>Shared Decoder $D(E_c(x)+E_p(x))$ : 共享解码器，用来将私有特征和公有特征组成的样本进行解码。</li><li>Classifier $G(E_c(x^s))$ : 分类器，在训练时用来对源域样本进行分类，在训练完成时就可以直接用在目标域数据上进行分类。</li></ul><p>看过每个部分的功能之后其实整个结构的原理就很明了了，首先我们忽略右下角的分类器，那么剩下的部分就是自编码器的结构。源域样本 $x^s$ 首先进入 $E_p^s(x^s)$ 和 $E_c(x)$，之后两个编码器分别输出 $h_p^s$ 和 $h_c^s$。 $h_p^s$ 和 $h_c^s$ 分别对应着源域数据中的私有特征和公有特征，同理， $h_p^t$ 和 $h_c^t$ 分别对应着目标域数据中的私有特征和公有特征。从上述的原理介绍我们可以知道，如果DSNs想要取得较好的效果，那么公有部分必须是真实的源域和目标域共有的特征，同时公有部分和私有部分必须完全分开，才能有效的避免负迁移，所以作者提出了以下两种损失函数来约束 $E_p^t(x^t)$，$E_p^s(x^s)$ 和 $E_c(x)$ ，首先是差异损失 $L_{difference}$：</p><script type="math/tex; mode=display">L_{difference}=||{H_c^s}^TH_p^s||^2_F+||{H_c^t}^TH_p^t||^2_F</script><p>$L_{difference}$ 其实计算的是 $h_p^s$ 和 $h_c^s$ 以及 $h_p^t$ 和 $h_c^t$ 的相似度大小，当 $h_p^s=h_c^s$ 以及 $h_p^t=h_c^t$ 时最大，当 $h_p^s$ 和 $h_c^s$ 正交（完全不同）以及  $h_p^t$ 和 $h_c^t$ 正交时 $L_{difference}$ 最小。所以通过最小化 $L_{difference}$ 可以达到 $h_p^s$ 和 $h_c^s$ 以及 $h_p^t$ 和 $h_c^t$ 完全分开的目的。</p><p>完全分开 $h_p^s$ 和 $h_c^s$ 以及 $h_p^t$ 和 $h_c^t$ 是不够的，因为我们还要保证 $h_c^s$ 和 $h_c^t$ 是可以进行迁移的，也就是要将两者进行适配，直观体现就是提高两者的相似度，因此作者提出了两种相似损失 $L_{similarity}$：</p><script type="math/tex; mode=display">L_{similarity}^{DANN}=\mathop{\sum}\limits_{i=0}^{N_s+N_t}\{d_ilog\hat{d}_i+(1-d_i)log(1-\hat{d}_i)\}</script><script type="math/tex; mode=display">L_{similarity}^{MMD}=\frac{1}{(N_s)^2}\mathop{\sum}\limits_{i,j=0}^{N_s}k(h_{ci}^s,h_{cj}^s)-\frac{2}{N_sN_t}\mathop{\sum}\limits_{i,j=0}^{N_s,N_t}k(h_{ci}^s,h_{cj}^t)+\frac{1}{(N_t)^2}\mathop{\sum}\limits_{i,j=0}^{N_t}k(h_{ci}^t,h_{cj}^t)</script><p>第一种相似损失是借用DANN算法中的损失函数，使用了对抗网络的思想，第二种损失函数则是迁移学习中经常用到的MMD损失。这两种损失都衡量了 $h_c^s$ 和 $h_c^t$ 差异的大小，因此当 $L_{similarity}$ 最小时可以使 $h_c^s$ 和 $h_c^t$ 最相似甚至变为同一种分布。当 $h_c^s$ 和 $h_c^t$ 的分布近似相等时，在 $h_c^s$ 上有效的分类器同样也可以在 $h_c^t$ 上工作了。</p><p>到这里工作还远远没有结束，因为我们虽然保证了 $h_p^s$ 和 $h_c^s$ 以及 $h_p^t$ 和 $h_c^t$ 完全分开同时 $h_c^s$ 和 $h_c^t$ 的分布近似相等，但是我们没有保证源域数据和目标域数据的完整性。举一个极端的例子，假如无论什么数据进来都有 $h_p^s=h_p^t=0,h_c^s=h_c^t=1$，那么上面的损失函数都是可以达到最小的，但是学到的东西却毫无意义。这时候作者采用的这种‘编码-解码’结构就起作用了，这种结构不仅能够保证提取公有、私有特征，还能够保证特征的完整性和有效性。具体的，作者为Shared Decoder提出了重构损失 $L_{recon}$：</p><script type="math/tex; mode=display">L_{recon}=\mathop{\sum}\limits_{i=1}^{N_s}||x_i^s-\hat{x}_i^s||^2+\mathop{\sum}\limits_{i=1}^{N_t}||x_i^t-\hat{x}_i^t||^2</script><p>到此，源域样本进入编码器到从解码器出来的过程中，两个解码器分别提取了私有和公有特征，同时又因为解码器要求公有特征和私有特征组合在一起要能够构成完整的源域样本，所以又保证了特征的完整性。同理，当目标域样本进入时也是同样的操作。但是，通过‘编码-解码’这种无监督方法提取出来了源域和目标域的公有特征以及各自的私有特征，我们还无法对样本进行分类，所以作者在整个结构中加入了分类器 $G(E_c(x^s))$，其损失函数为：</p><script type="math/tex; mode=display">L_{class}=-\mathop{\sum}\limits_{i=1}^{N_s}y_i^s\cdot log\hat{y}_i^s</script><p>这一步骤在迁移学习中就很常见了，在前面的过程中，自编码器已经提取出来了源域和目标域的公有部分，并且通过最小化 $L_{similarity}$ 使两者在分布上进行了逼近。那么可以说如果一个分类器在源域的公有部分上有效的话那么在目标域的公有部分上同样有效，因此在训练时只需要使用带标记的源域数据对分类器进行训练，在训练完成时分类器就可以直接应用在目标域上了。至此，整个DSNs的各个部分都已经向大家介绍完成。</p><h3 id="四、Stacked-Denoising-Autoencoder-SDAE"><a href="#四、Stacked-Denoising-Autoencoder-SDAE" class="headerlink" title="四、Stacked Denoising Autoencoder(SDAE)"></a>四、Stacked Denoising Autoencoder(SDAE)</h3><p>论文中使用到了堆叠去噪自动编码器 (SDAE)。 它是一个前馈神经网络，可以学习输入数据的稳健表示。记 $X_I=\{x_i\}_{i=1}^n$ 原始输入向量的集合，$\tilde{X}_I=\{\tilde{x}_i\}_{i=1}^n$ 是含噪声的向量集合。SDAE以 $\tilde{X}_I$ 作为输入，并通过它的编码器 $E_\theta$ 将其转化为隐层中间向量 $h$。接着通过解码器 $D_{\theta’}$ 将 $h$ 重构，原始输入向量 $X_I$ 即重构结果，损失函数即二者的均方损失。</p><h3 id="五、Proposed-Method"><a href="#五、Proposed-Method" class="headerlink" title="五、Proposed Method"></a>五、Proposed Method</h3><p>我们的目的是向目标域的用户推荐源域中的item，如前文所示，我们使用DSNs基于源域的有标签数据构建了一个分类器。对于DSNs的输出层，我们使用softmax层，该层第k个元素的值如下所示：</p><script type="math/tex; mode=display">(G(E_c(x^s))_k=p(y=k|x^s)=\frac{exp(v_k^Tu)}{\mathop{\sum}\limits_{k'\in Y}exp(v_{k'}^Tu)}</script><p>$v_k$ 是softmax层的权重向量，向量 $u$ 是前一层经过激活后的结果。</p><p>由于items的数量通常很大，因此仅使用用户特征进行预测将是一项艰巨的任务。在实践中，输入数据是不平衡的，有些标签只能观察几次。此外，目标域中用户偏好的item类型可能与训练数据中的不同。因此，分类器应该能够预测训练数据中未观察到的新item。从这些观察中，我们相信结合item特征将有助于预测。事实上，在我们用于实验的视频服务中，大部分用户观看的视频都是几十秒长的短片。因此，结合视频播放时间使模型能够识别哪些视频是短视频。为此，除了使用 DSNs 之外，我们还建议结合去噪自动编码器SDAE来合并item特征。我们在softmax权重 $v_k$ 和由去噪自动编码器计算的item的隐藏表示 $h$ 之间施加均方误差。</p><p>整个模型的损失函数如下所示（$L_{IR}$ 是自动编码器的损失函数）：</p><script type="math/tex; mode=display">E=L_{DSN}+\lambda_{item}L_{item}+\lambda_{IR}L_{IR}</script><script type="math/tex; mode=display">L_{DSN}=L_{class}+\alpha L_{recon}+\beta L_{difference}+\gamma L_{similarity}</script><script type="math/tex; mode=display">L_{item}=\mathop{\sum}\limits_{i=1}^{N_s}||v_{yi}-h_i||^2</script><h3 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/49479734">https://zhuanlan.zhihu.com/p/49479734</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(9):TMCDR</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-9-TMCDR.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-9-TMCDR.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>EMCDR将源域和目标域的用户偏好编码为向量，然后学习一个映射函数，该映射函数将源域中的用户向量映射为目标领域上的用户向量，基于两个领域重叠的用户，使用 MSE 损失来进行学习。这类方法往往存在如下问题：</p><ul><li>通常两个领域重叠的用户只是一小部分用户，这样学习到的映射函数会在重叠用户上过拟合，降低模型的泛化能力；</li><li>使用映射导向的损失函数（MSE），对目标向量的质量有很高的要求。然而在冷启动场景中，目标向量的质量往往不尽人意，这样会导致向量表示学习中被噪声影响；</li></ul><p>论文将跨域推荐和元学习思想结合起来，提出了一种Transfer-Meta的框架来构建用户的embedding向量，该框架分为两个阶段：Transfer阶段、Meta阶段。</p><p>原文链接：<a href="https://arxiv.org/pdf/2105.04785.pdf">Transfer-Meta Framework for Cross-domain Recommendation to Cold-Start Users</a></p><span id="more"></span><h3 id="二、TMCDR"><a href="#二、TMCDR" class="headerlink" title="二、TMCDR"></a>二、TMCDR</h3><h4 id="2-1-meta-learning简介"><a href="#2-1-meta-learning简介" class="headerlink" title="2.1 meta learning简介"></a>2.1 meta learning简介</h4><p>meta-learning即元学习，也可以称为“<strong>learning to learn</strong>”。常见的深度学习模型，目的是学习一个用于预测的数学模型。而元学习面向的不是学习的结果，而是学习的过程。其学习的不是一个直接用于预测的数学模型，而是学习“如何更快更好地学习一个数学模型”。</p><p>举一个现实生活的例子。我们教小朋友读英语时，可以直接让他们模仿apple、banana的发音。但是他们很快又会遇到新的单词，例如strawberry，这是小朋友就需要重新听你的发音，才能正确地读出这个新单词。我们换一种方式，这一次我们不教每个单词的发音，而是教音标的发音。从此小朋友再遇见新单词，他们只要根据音标，就可以正确地读出这个单词。学习音标的过程，正是一个元学习的过程。</p><h4 id="2-2-Transfer阶段"><a href="#2-2-Transfer阶段" class="headerlink" title="2.2 Transfer阶段"></a>2.2 Transfer阶段</h4><p>Transfer阶段类似EMCDR中生成U/I embedding向量的步骤。不同的是这里使用所有的数据（而不仅是交叉域）在源域和目标域进行预训练，得到源域和目标域的U/I的embedding表示 $u^s,v^s,u^t,v^t$。为了验证Transfer-Meta框架的兼容性，论文中使用了MF、BPR、ListRank-MF、CML四种向量生成方法。</p><p>之后，将训练好的模型作为预训练模型，固定不动，再学习meta network。</p><h4 id="2-3-Meta阶段"><a href="#2-3-Meta阶段" class="headerlink" title="2.3 Meta阶段"></a>2.3 Meta阶段</h4><p>Meta阶段借鉴了元学习（<a href="https://zhuanlan.zhihu.com/p/395138650">meta-learning</a>）的思想，并<strong>提出了一种Task-oriented（面向任务）的优化方法</strong>，直接使用任务标签来优化meta network。</p><p>从交叉域中的用户集抽取部分用户的数据作为task，反复在训练数据分布中抽取若干个这样的task，组成一个batch进行训练。在每个task中，将用户分为不重叠的两部分 $U_a, U_b$ ，并得到对应的数据 $D_a, D_b$。这两部分用户数据分别来模拟<strong>在交叉域用户上学习知识</strong>和<strong>在冷启动用户上测试</strong>这两个阶段（真正的冷启用户只有源域的信息，没有目标域的信息，不能用于做测试集，所以测试集也使用交叉域用户)。</p><p>将meta network（即与Transfer阶段相同的MF、BPR、ListRank-MF、CML四种向量生成方法）用 $f_{\theta}(\cdot)$ 表示， $\theta$ 表示参数。$f_{\theta}(u_i^s)$ 表示 $u_i^s$ 的向量（$u_i^s$ 表示第 $i$ 个用户源域的向量表示）。Task-oriented的损失函数优化的是 $f_{\theta}(u_i^s)$ 而不是Transfer阶段得到的 $u_i^s$。Task-oriented的损失函数可以表示为（即：将Transfer阶段得到的 $u_i^s$ 用元网络映射后与目标域的 $v_t$ 计算loss)：</p><script type="math/tex; mode=display">\mho_\theta=\mathop{\sum}\limits_{x\in D_a}L_{task}(x)</script><p>其中，$task\in \{MF,BPR,ListRank-MF,CML\}$，$x\in D_a$。另外注意的是，这里使用的U/I embedding为源域的 $u_s$ 和目标域的 $v_t$。之后就可以按照元学习的双重梯度方式训练模型。task内通过交叉域用户上学习知识和在冷启动用户上测试这两个阶段学习得到每个task的 $\theta’$；对于全部task，通过 $\theta’$ 更新 $\theta$。</p><h4 id="2-4-算法流程"><a href="#2-4-算法流程" class="headerlink" title="2.4 算法流程"></a>2.4 算法流程</h4><p><img src="https://s4.ax1x.com/2022/01/16/7NJ6XQ.png" alt=""></p><h3 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/395211316">https://zhuanlan.zhihu.com/p/395211316</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(8):EMCDR</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-8-EMCDR.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-8-EMCDR.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、跨域推荐概述"><a href="#一、跨域推荐概述" class="headerlink" title="一、跨域推荐概述"></a>一、跨域推荐概述</h3><p>为了解决推荐系统冷启动中长期存在的数据稀疏问题，人们提出了跨域推荐（CDR），利用来自更丰富域（源域）的相对更丰富的信息，提高在更稀疏域（目标域）中的推荐性能。</p><p>跨域推荐分为两种类型：</p><ol><li>非对称的方式：利用源域中的数据来解决目标域的数据稀疏性，具体来说是把在源域中学到的知识或者某种模式直接应用到目标域中充当先验或者正则。这种方法的关键之处是需要从源域数据中识别出可以应用到目标域的知识。然而因为没有完全利用源域和目标域的数据，所以是有很大局限的。</li><li>对称的方式，假设源域和目标域都有数据稀疏的问题，并且它们可以互相应用对方的数据知识。以这种方式来看，这两个域是可以同等对待的，两个域都以协同的方式应对数据稀疏问题。通常这种方式会在域之间学习一个map函数，把域独有的因子和域间共享的因子明确区分开来，主要的缺点是学习域独有的因子和域间共享的因子本身就放大了数据的稀疏性问题。</li></ol><p>两种类型的区别在于：非对称方式中源域用于判断label的知识足够多而目标域用于判断label知识相对少，源域需要的知识目标域无法提供，而目标域需要源域的知识，源域知识与目标域知识的交集为目标域知识，这样目标域的知识没必要迁移或迁移过去没多大作用；而对称方式中源域和目标域知识都不太多，有一定交集，也有各自的部分，需要互为补充提高精度。</p><p>本篇博客对跨域推荐模型EMCDR做一个详细介绍，原文地址： <a href="https://static.aminer.cn/upload/pdf/program/59ae3c262bbe271c4c71f007_0.pdf">Cross-Domain Recommendation: An Embedding and Mapping Approach</a></p><span id="more"></span><h3 id="二、EMCDR模型"><a href="#二、EMCDR模型" class="headerlink" title="二、EMCDR模型"></a>二、EMCDR模型</h3><h4 id="2-1-模型总览"><a href="#2-1-模型总览" class="headerlink" title="2.1 模型总览"></a>2.1 模型总览</h4><p>EMCDR属于非对称的方式进行跨域推荐，推荐的目标是针对目标域中有很少信息的用户或者物品，例如对于一个新来的用户或者物品，在目标域中并不能找到它的embedding，但是在源域中它比较活跃，可以找到它的embedding，这时通过目标域和源域的map函数（map可以认为是从源域的embedding到目标域embedding的一种映射，所以训练map函数<strong>使用的embedding只能是源域和目标域的交叉部分</strong>）可以得到目标域的embedding，之后再做推荐。</p><p>EMCDR模型如下图所示，其将跨域推荐分为三个步骤：</p><ul><li>Latent Factor Modeling（生成U/I的隐式向量）</li><li>Latent Space Mapping（源域-&gt;目标域 U/I隐式向量的映射）</li><li>Cross-domain Recommendation（跨域推荐）</li></ul><p><img src="https://s4.ax1x.com/2022/01/15/7JMmwD.png" alt=""></p><h4 id="2-2-Latent-Factor-Modeling"><a href="#2-2-Latent-Factor-Modeling" class="headerlink" title="2.2 Latent Factor Modeling"></a>2.2 Latent Factor Modeling</h4><p>论文中介绍了两种生成隐向量的方式，分别是矩阵分解<a href="http://qzmvc1.top/我的推荐算法之路-2-矩阵分解.html">(MF)</a>和贝叶斯个性化排序<a href="https://www.cnblogs.com/pinard/p/9128682.html">(BPR)</a>。</p><ul><li>MF通过构建user-item的二元组，并对其进行矩阵分解生成两个低秩矩阵的乘积。其中，user表示为 $K \times U$ 的矩阵，item表示为 $K \times V$ 的矩阵，最终损失函数为：</li></ul><script type="math/tex; mode=display">\mathop{min}\limits_{U,V}(\mathop{\sum}\limits_{i}\mathop{\sum}\limits_{j}||I_{ij}\cdot(R_{ij}-U_i^TV_j)||^2_F+\lambda_U\mathop{\sum}\limits_{i}||U_i||^2_F+\lambda_V\mathop{\sum}\limits_{j}||V_j||^2_F)</script><ul><li>BPR通过构建user-item1-item2（user对item1的偏好大于item2）的三元组生成user对应的所有商品的全序关系，并通过使用与funkSVD类似的矩阵分解模型生成K维向量，最终的损失函数为：</li></ul><script type="math/tex; mode=display">\mathop{min}\limits_{U,V}(\mathop{\sum}\limits_{(u_i,v_j,v_l)\in D}-ln\sigma(U_i^TV_j-U_i^TV_l)+\lambda_U\mathop{\sum}\limits_{i}||U_i||^2_F+\lambda_V\mathop{\sum}\limits_{j}||V_j||^2_F))</script><h4 id="2-3-Latent-Space-Mapping"><a href="#2-3-Latent-Space-Mapping" class="headerlink" title="2.3 Latent Space Mapping"></a>2.3 Latent Space Mapping</h4><p>在得到源域和目标域U/I的K维embedding表示后，就可以构建一个map映射关系，完成从源域到目标域的映射。论文中介绍了Linear Mapping、MLP-based Nonlinear Mapping两种映射方法。</p><ul><li>Linear Mapping为线性映射，通过线性变换实现。损失函数表示为：</li></ul><script type="math/tex; mode=display">\mathop{min}\limits_{M}\mathop{\sum}\limits_{u_i\in U}L(M\times U_i^s,U_i^t)+\Omega(M)</script><p>其中，$U_i^s,U_i^t$ 分别是源域和目标域的隐因子向量，$M$ 是待学习的线性变换矩阵，$\Omega(M)$ 是正则项。</p><ul><li>MLP-based Nonlinear Mapping为非线性映射，通过MLP实现。损失函数表示为：</li></ul><script type="math/tex; mode=display">\mathop{min}\limits_{\theta}\mathop{\sum}\limits_{u_i\in U}L(f_{mlp}(U_i^s;\theta),U_i^t)</script><p>其中，$\theta$ 是MLP的参数。</p><h4 id="2-4-Cross-domain-Recommendation"><a href="#2-4-Cross-domain-Recommendation" class="headerlink" title="2.4 Cross-domain Recommendation"></a>2.4 Cross-domain Recommendation</h4><p>对于目标域中信息很少的用户和物品，直接使用MF或者BPR建模出的隐向量是不准确的，有很大偏差。这时可以使用源域建模出的隐向量以及map函数对user建模：</p><script type="math/tex; mode=display">\hat{U}_i^t=f(U_i^s;\theta)</script><h3 id="3、参考链接"><a href="#3、参考链接" class="headerlink" title="3、参考链接"></a>3、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/395211316">https://zhuanlan.zhihu.com/p/395211316</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(7):MiNet</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-7-MiNet.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-7-MiNet.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-1-跨域推荐的概念"><a href="#1-1-跨域推荐的概念" class="headerlink" title="1.1 跨域推荐的概念"></a>1.1 跨域推荐的概念</h4><p>首先要引入“跨域推荐”的概念。什么是”域“呢？简单来说，可以把它看作是通过某种方式聚集在一起的集合。比如可以把新闻app中的某一个板块当做一个域，也可以是b站的鬼畜区，舞蹈区等等。当然我们也可以扩大域的概念，把短视频整体当成一个域。这些定义应该都是可以的，域的概念其实可大可小。</p><p>那什么叫”跨域“呢？可能常见的推荐场景都是单域推荐比较多，也就是”游戏“只推荐”游戏“类的东西，它基于的数据也都是游戏用户本身的东西。但什么是”跨域推荐“呢？比如，我要给“鬼畜区”推荐东西，但是使用的数据不只是鬼畜区自己的，它还包括了”舞蹈区“，”数码区“，”游戏区“等其他域产生的数据。</p><p>对于此，我们要定义两个”域“的概念：”源域“和”目标域“，我们要优化、提升的目标叫做”目标域“，比如我们要优化”鬼畜区“的CTR，那么“鬼畜区”就是“目标域”。而”源域“相当于是辅助的部分，我们会把“舞蹈区”，“数码区”等看做是“源域”。</p><h4 id="1-2-跨域推荐的细节"><a href="#1-2-跨域推荐的细节" class="headerlink" title="1.2 跨域推荐的细节"></a>1.2 跨域推荐的细节</h4><p>跨域推荐实际是有一种前提的，就是基于重叠(overlap)。为什么会有跨域？那是因为有一部分的特征也好、用户也好、物品也好，能够有一些重叠，通过重叠的部分找到两个域之间的一些关联，共分为以下四种情况。</p><ul><li>用户与物品之间没有都没有交集；</li><li>两个域的用户有部分交集，但是物品没有交集。这种情况可以理解成鬼畜用户和舞蹈用户会有部分交集，这部分用户他们既访问了鬼畜区的视频又去舞蹈区看了小姐姐；</li><li>两个域的用户没有交集，但是物品有部分重合。一种可能的情况：youtube和b站的用户在法定情况下是不一样的，但是b站的部分内容又是从youtube上搬运过来的；</li><li>这个场景的重合度就比较高了，不论是用户还是物品都有一定程度上的重叠，这在b站上也是很常见的，比如自制区的视频同时也是数码区的视频。</li></ul><p>原文链接：<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2008.02974">MiNet:Mixed Interest Network for Cross-Domain Click-Through Rate Prediction</a></p><span id="more"></span><h3 id="二、模型设计"><a href="#二、模型设计" class="headerlink" title="二、模型设计"></a>二、模型设计</h3><h4 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h4><p>本文基于UC头条的应用场景，将新闻feed流作为源域，广告作为目标域。</p><p><img src="https://s4.ax1x.com/2022/01/07/7967FK.png" alt=""></p><h4 id="2-2-结构设计"><a href="#2-2-结构设计" class="headerlink" title="2.2 结构设计"></a>2.2 结构设计</h4><p>为了更好的利用好跨域数据，文中对三种不同的user interest进行建模：</p><ul><li><p>跨域长期兴趣（Long-term interest across domains）：用户的profile feature能反映出他长期的、固有的兴趣。通过跨域数据（用户交互过的所有的新闻和广告记录）可以学习出一个包含更多语义信息和可信度更高的user embedding。简单来说，就是通过用户的基本信息建模用户的内在长期兴趣。</p></li><li><p>源域短期兴趣（Short-term interest from the source domain）：对于每个待预估的广告，都会有一个源域的短期用户兴趣与之关联，尽管广告和新闻的内容可能是完全不同，但其中很可能会存在一个确定的相关性比，如看了娱乐新闻后的用户可能会去点击游戏广告。基于这种相关性，我们能把源域的有用信息迁移到目标域来。简单来说就是对用户在源域的短期行为进行建模。</p></li><li><p>目标域短期兴趣（Short-term interest from the target domain）：这个不言而喻了，就不多阐述了，简单来说就是对用户在目标域的短期行为进行建模。</p></li></ul><p>尽管上面的三种user interest看起来可行性很高，但依然存在几个问题：</p><ul><li>不是所有交互过的新闻都和目标广告有关系</li><li>同样，也不是所有交互过的广告都和目标广告有关系</li><li>模型必须能把信息从源域迁移到目标域</li><li>对于每个目标广告，三种用户兴趣的重要性是不一样的</li><li>用户兴趣向量的维度可能不一样</li></ul><p>为了解决这些问题，提出<strong>MiNet</strong>模型，模型结构如下：</p><p><img src="https://s4.ax1x.com/2022/01/07/79ctTx.png" alt=""></p><h4 id="2-3-详细说明"><a href="#2-3-详细说明" class="headerlink" title="2.3 详细说明"></a>2.3 详细说明</h4><h4 id="2-3-1-Embedding层"><a href="#2-3-1-Embedding层" class="headerlink" title="2.3.1 Embedding层"></a>2.3.1 Embedding层</h4><p>对于用户、新闻、广告来说，其某些特征可能如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">feature</th></tr></thead><tbody><tr><td style="text-align:center">User information</td><td style="text-align:center">user ID, city, age…</td></tr><tr><td style="text-align:center">Ad information</td><td style="text-align:center">creative ID, campaign ID, title…</td></tr><tr><td style="text-align:center">News information</td><td style="text-align:center">creative ID, campaign ID, title…</td></tr></tbody></table></div><p>以上表中的city特征为例，若对其进行one-hot编码之后直接输入到模型当中，结果往往是非常糟糕的，因为其one-hot向量是高度稀疏的，因此我们需要对其进行降维。正如大部分模型那样，这里同样使用了Embedding技术。在对每个特征Embedding之后，我们得到了相较之前维度较少的特征向量，再对各个特征的Embedding向量进行拼接之后，作为模型的输入并准备下一步的工作。</p><p><img src="https://s4.ax1x.com/2022/01/07/79g14f.png" alt=""></p><h4 id="2-3-2-跨域长期建模"><a href="#2-3-2-跨域长期建模" class="headerlink" title="2.3.2 跨域长期建模"></a>2.3.2 跨域长期建模</h4><p>用户的profile feature能反映出他长期的、固有的兴趣，⽐如20岁左右的男性⽤户可能对体育赛事或者游戏类的资讯或者⼴告⽐较感兴趣。通过跨域数据（用户交互过的所有的新闻和广告记录）可以学习出一个包含更多语义信息和可信度更高的user embedding。简单来说，就是通过用户的基本信息建模用户的内在长期兴趣。这⾥主要做法是将⽤户ID、⽤户性别、⽤户所在地域、⽤户的⼿机设备等embedding向量进⾏拼接，输出为 $P_u$。例如⽤户ID为123，城市为北京，男性⽤户，使⽤苹果⼿机，得到的⻓期兴趣表示为：</p><script type="math/tex; mode=display">P_u=[e_{u123}||e_{BJ}||e_{male}||e_{ios}]</script><p><img src="https://s4.ax1x.com/2022/01/07/79RPfK.png" alt=""></p><h4 id="2-3-3-源域短期兴趣建模"><a href="#2-3-3-源域短期兴趣建模" class="headerlink" title="2.3.3 源域短期兴趣建模"></a>2.3.3 源域短期兴趣建模</h4><p>对于每个待预估的广告，都会有一个源域的短期用户兴趣与之关联。尽管广告和新闻的内容可能是完全不同，但其中很可能会存在一个确定的相关性比，如看了娱乐新闻后的用户可能会去点击游戏广告。基于这种相关性，我们能把源域的有用信息迁移到目标域来。简单来说就是对用户在源域的短期行为进行建模。</p><p><img src="https://s4.ax1x.com/2022/01/07/79WlU1.png" alt=""></p><h5 id="2-3-3-1-Item-attention"><a href="#2-3-3-1-Item-attention" class="headerlink" title="2.3.3.1 Item attention"></a>2.3.3.1 Item attention</h5><p>首先，定义</p><script type="math/tex; mode=display">\widetilde{a_i}=h_s^TReLU(W_s[r_{si}||q_t||p_u||Mr_{si}\odot{q_t}])</script><ul><li>$r_{si}$ 是源域被点击新闻embedding并拼接后的特征向量；</li><li>$q_t$ 是目标域目标广告embedding并拼接后的特征向量；</li><li>$p_u$ 是用户长期兴趣向量；</li><li>$Mr_{si}\odot{q_t}$ 中，$M$ 是待学习的矩阵，其将 $r_{si}$ 映射到目标域空间中与$q_t$ 作元素积；</li></ul><h5 id="2-3-3-2-Aggregation"><a href="#2-3-3-2-Aggregation" class="headerlink" title="2.3.3.2 Aggregation"></a>2.3.3.2 Aggregation</h5><p>通过softmax公式对 $\widetilde{a_i}$ 进行映射</p><script type="math/tex; mode=display">a_i =\frac{exp(\widetilde{a_i})}{\sum{exp(\widetilde{a_i})}}</script><p>并线性加权得到最后的 $a_s$：</p><script type="math/tex; mode=display">a_s=\sum{a_ir_{si}}</script><h4 id="2-3-4-目标域短期兴趣建模"><a href="#2-3-4-目标域短期兴趣建模" class="headerlink" title="2.3.4 目标域短期兴趣建模"></a>2.3.4 目标域短期兴趣建模</h4><p><img src="https://s4.ax1x.com/2022/01/07/795soj.png" alt=""></p><h5 id="2-3-4-1-Item-attention"><a href="#2-3-4-1-Item-attention" class="headerlink" title="2.3.4.1 Item attention"></a>2.3.4.1 Item attention</h5><p>首先，定义</p><script type="math/tex; mode=display">\widetilde{\beta_j}=h_t^TReLU(W_t[r_{tj}||q_t||p_u||r_{tj}\odot{q_t}])</script><p>与源域短期兴趣建模唯一的区别就是 $r_{tj}$, ${q_t}$ 都是目标域的向量，不需要训练映射矩阵。</p><h5 id="2-3-4-2-Aggregation"><a href="#2-3-4-2-Aggregation" class="headerlink" title="2.3.4.2 Aggregation"></a>2.3.4.2 Aggregation</h5><p>通过softmax公式对 $\widetilde{\beta_j}$ 进行映射</p><script type="math/tex; mode=display">\beta_j =\frac{exp(\widetilde{\beta_j})}{\sum{exp(\widetilde{\beta_j})}}</script><p>并线性加权得到最后的 $a_t$：</p><script type="math/tex; mode=display">a_t=\sum{\beta_jr_{tj}}</script><h4 id="2-3-5-Interest-Attention层"><a href="#2-3-5-Interest-Attention层" class="headerlink" title="2.3.5 Interest Attention层"></a>2.3.5 Interest Attention层</h4><p><img src="https://s4.ax1x.com/2022/01/07/79ICtA.png" alt=""></p><p>最终，输入到预测层的向量 $m_t=[q_t||v_up_u||v_sa_s||v_ta_t]$</p><p>其中，</p><script type="math/tex; mode=display">v_u=exp(g^T_uReLU(V_u[q_t||p_u||a_s||a_t])+b_u)</script><script type="math/tex; mode=display">v_s=exp(g^T_sReLU(V_s[q_t||p_u||a_s||a_t])+b_s)</script><script type="math/tex; mode=display">v_t=exp(g^T_tReLU(V_t[q_t||p_u||a_s||a_t])+b_t)</script><h4 id="2-3-6-Prediction层和Loss函数"><a href="#2-3-6-Prediction层和Loss函数" class="headerlink" title="2.3.6 Prediction层和Loss函数"></a>2.3.6 Prediction层和Loss函数</h4><p><img src="https://s4.ax1x.com/2022/01/07/79TDeO.png" alt=""></p><p>预测层是一个多层的全连接神经网络，其输出是经过sigmoid函数映射后的 [0, 1] 值。$MiNet$ 采用了辅助任务，通过使用 $q_s$ 向量促进对 $p_u$ 向量的训练，并将其通过预测层。</p><p>最终模型的损失函数包括两部分：$loss1$ 和 $loss2$，分别记为 $loss_t$ 和 $loss_s$ ，每个 $loss$ 都是用交叉熵作为损失函数，最终的损失函数 $loss$ 如下：</p><script type="math/tex; mode=display">loss=loss_t+\gamma loss_s</script><p>其中，$\gamma$ 是平衡因子。 </p><h3 id="三、跨域推荐优缺点"><a href="#三、跨域推荐优缺点" class="headerlink" title="三、跨域推荐优缺点"></a>三、跨域推荐优缺点</h3><p>优势：</p><blockquote><ul><li>首先，它可以用来解决一部分冷启动的问题。目标域的新用户很可能是源域的旧用户，那么将源域的信息拿过来辅助提升推荐的效果，能一定程度上解决冷启动；</li><li>第二点就是提升目标域的推荐效果，这个也是跨域推荐的主要目的；</li><li>第三个优势是多样性。因为跨域推荐同时参考了多个域的特征，自然而然会对推荐结果的多样性进行一定的优化。最终，它还会反作用于源域，能够实现源域的推荐与目标的域推荐效果的共同提升。</li></ul></blockquote><p>劣势：</p><blockquote><ul><li>跨域推荐还需要考虑一定的权衡，因为跨域必然会导致数据的稀疏，处理不当可能会有反作用。</li></ul></blockquote><h3 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/221719082">https://zhuanlan.zhihu.com/p/221719082</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(6):Deep Crossing</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-6-Deep-Crossing.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-6-Deep-Crossing.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>$Deep　Crossing$ 模型是微软于2016年在 KDD 上提出的模型，它算是第一个企业以正式论文的形式分享深度学习推荐系统的技术细节的模型。由于手工设计特征（特征工程）花费巨大精力，因此文章提出了$Deep　Crossing$ 模型自动联合特征与特征交叉。$Deep　Crossing$ 并没有采用显式交叉特征的方式，而是利用残差网络结构挖掘特征间的关系，以现在的角度看待这个模型是非常简单的，也就是 $Embedding+MLP$ 的结构，但对当时影响是非常巨大。</p><p>原文链接:<a href="https://www.kdd.org/kdd2016/papers/files/adf0975-shanA.pdf">Deep Crossing: Web-Scale Modeling without Manually Crafted Combinatorial Features</a></p><span id="more"></span><h3 id="二、模型结构"><a href="#二、模型结构" class="headerlink" title="二、模型结构"></a>二、模型结构</h3><p>$Deep　Crossing$ 一共包含四层结构: $Embedding$层、$Stacking$层、$Multiple　Residual　Units$层、$Scoring$层。</p><p><img src="https://z3.ax1x.com/2021/10/04/4O2eyR.png" alt=""></p><h4 id="2-1-Embedding-Layer"><a href="#2-1-Embedding-Layer" class="headerlink" title="2.1 Embedding Layer"></a>2.1 Embedding Layer</h4><p>几乎所有基于深度学习的推荐、CTR预估模型都离不开 $Embedding$ 层，它的作用是将离散高维的稀疏特征转化为低维的密集型特征，其公式化定义为 $X_j^O=max(0, W_jX_j^I+b_j)$。其中，$X_j^I$ 表示经过 $One-Hot$ 编码的第 $j$ 个 $Field$，$W_j$ 表示对应的模型参数，$b_j$ 表示对应的偏置项，$max$ 操作等价于使用激活函数 $ReLU$。在模型结构中发现 <code>Feature #2</code>并没有使用 $Embedding$，因为文章提到“维度小于256的特征“不需要进行 $Embedding$ 转化。</p><h4 id="2-2-Stacking-Layer"><a href="#2-2-Stacking-Layer" class="headerlink" title="2.2 Stacking Layer"></a>2.2 Stacking Layer</h4><p>$Stacking$ 层的操作非常简单，就是将所有的 $Embedding$ 向量、未进行 $Embedding$ 操作的原生特征进行拼接，形成一个向量 $X^O=[X_0^O,X_1^O,\cdots,X_n^O]$。</p><h4 id="2-3-Multiple-Residual-Units"><a href="#2-3-Multiple-Residual-Units" class="headerlink" title="2.3 Multiple Residual Units"></a>2.3 Multiple Residual Units</h4><p>$Deep　Crossing$ 模型中的 $Crossing$ 就是<strong>多个残差单元</strong>层来实现。该层使用了残差网络的基本单元，单个残差单元如下所示：</p><p><img src="https://z3.ax1x.com/2021/10/04/4OWrss.png" alt=""></p><p>公式定义为：</p><script type="math/tex; mode=display">X^O = ReLU(W_1·ReLU(W_0X^I+b_0)+b_1)+X^I</script><p>$Deep　Crossing$ 模型使用稍微修改过的残余单元，它不使用卷积内核，改为两层神经网络。可以看到，残差单元是通过两层 $ReLU$ 变换再将原输入特征加回来。</p><p>将 $X^I$ 移到等式左侧，可以发现左侧变为 $X^O-X^I$，可见右侧拟合的是输出与输入之间的残差。有分析说明，残差结构能更敏感的捕获输入输出之间的信息差。</p><p>多个残差单元层是 $MLP$ 的具体实现，该层通过多个残差单元，对特征向量各个维度进行交叉组合，使模型获得了更多的非线性特征和组合特征信息，进而提高了模型的表达能力。</p><h4 id="2-4-Scoring-Layer"><a href="#2-4-Scoring-Layer" class="headerlink" title="2.4 Scoring Layer"></a>2.4 Scoring Layer</h4><p>$Scoring$ 层就是输出层。对于CTR预估模型，往往是一个二分类问题，因此采用逻辑回归来对点击进行预测，损失函数采用交叉熵，激活函数采用 $Sigmoid$。</p><h3 id="三、伪代码"><a href="#三、伪代码" class="headerlink" title="三、伪代码"></a>三、伪代码</h3><p>论文中给出了模型的伪代码，首先定义了一些函数的基本实现：</p><p><img src="https://z3.ax1x.com/2021/10/04/4OhZ4K.png" alt=""></p><p>接着给出了各层的伪代码：</p><p><img src="https://z3.ax1x.com/2021/10/04/4Ohn3D.png" alt=""></p><h3 id="四、代码演示"><a href="#四、代码演示" class="headerlink" title="四、代码演示"></a>四、代码演示</h3><blockquote><p>实验数据选用MovieLens 1M </p></blockquote><h4 id="4-1-数据处理"><a href="#4-1-数据处理" class="headerlink" title="4.1 数据处理"></a>4.1 数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取users、moives、ratings三个部分的数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readMovies</span>(<span class="params">path</span>):</span></span><br><span class="line">    movies = pd.read_table(os.path.join(path, <span class="string">&#x27;movies.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    movies.columns = [<span class="string">&#x27;MovieID&#x27;</span>, <span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Genres&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> movies</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readUsers</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Age: &#123;1, &#x27;under 18&#x27;,  18: &quot;18-24&quot;,  25: &quot;25-34&quot;,  35: &quot;35-44&quot;,</span></span><br><span class="line"><span class="string">              45: &quot;45-49&quot;,    50: &quot;50-55&quot;,  56: &quot;56+&quot;,&#125;&quot;&quot;&quot;</span></span><br><span class="line">    users = pd.read_table(os.path.join(path, <span class="string">&#x27;users.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    users.columns = [<span class="string">&#x27;UserID&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Zip-code&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> users</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readRatings</span>(<span class="params">path</span>):</span></span><br><span class="line">    ratings = pd.read_table(os.path.join(path, <span class="string">&#x27;ratings.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    ratings.columns = [<span class="string">&#x27;UserID&#x27;</span>, <span class="string">&#x27;MovieID&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>, <span class="string">&#x27;Timestamp&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> ratings</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># movielens数据集分为users、movies、ratings三个部分，选择所需的特征将它们合并为一个Tensor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">movieDataConcat</span>(<span class="params">path</span>):</span>  <span class="comment"># 合并特征</span></span><br><span class="line">    ans = []</span><br><span class="line">    users, movies, ratings = readUsers(path), readMovies(path), readRatings(path)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> ratings.values:</span><br><span class="line">        userid, movieid, rating = row[:<span class="number">3</span>]</span><br><span class="line">        gender, age, occupation = users[users.UserID==userid].values[<span class="number">0</span>][<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">        genre = movies[movies.MovieID==movieid].Genres.values[<span class="number">0</span>]</span><br><span class="line">        ans.append([userid, gender, age, occupation, movieid, genre, rating])</span><br><span class="line">    np.save(<span class="string">&#x27;./moviedataconcat.npy&#x27;</span>, np.array(ans))</span><br></pre></td></tr></table></figure><p><strong>合并结果如下图所示，每个元素的数据类型都是str</strong></p><p><img src="https://z3.ax1x.com/2021/10/05/4jo3LD.png" alt=""></p><h4 id="4-2-将离散特征转化为One-Hot-Multi-Hot编码"><a href="#4-2-将离散特征转化为One-Hot-Multi-Hot编码" class="headerlink" title="4.2 将离散特征转化为One-Hot/Multi-Hot编码"></a>4.2 将离散特征转化为One-Hot/Multi-Hot编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataVectorHot</span>(<span class="params">data</span>):</span> </span><br><span class="line">    <span class="comment"># X_type: conVar, 2dim-onehot, 7dim-onehot, 21dim-onehot, conVar, 18dim-multihot, conVar</span></span><br><span class="line">    strtonum = &#123;<span class="string">&#x27;Action&#x27;</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;Adventure&#x27;</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;Animation&#x27;</span> : <span class="number">2</span>,</span><br><span class="line">                <span class="string">&#x27;Children\&#x27;s&#x27;</span> : <span class="number">3</span>,</span><br><span class="line">                <span class="string">&#x27;Comedy&#x27;</span> : <span class="number">4</span>,</span><br><span class="line">                <span class="string">&#x27;Crime&#x27;</span> : <span class="number">5</span>,</span><br><span class="line">                <span class="string">&#x27;Documentary&#x27;</span> : <span class="number">6</span>,</span><br><span class="line">                <span class="string">&#x27;Drama&#x27;</span> : <span class="number">7</span>,</span><br><span class="line">                <span class="string">&#x27;Fantasy&#x27;</span> : <span class="number">8</span>,</span><br><span class="line">                <span class="string">&#x27;Film-Noir&#x27;</span> : <span class="number">9</span>,</span><br><span class="line">                <span class="string">&#x27;Horror&#x27;</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">&#x27;Musical&#x27;</span> : <span class="number">11</span>,</span><br><span class="line">                <span class="string">&#x27;Mystery&#x27;</span> : <span class="number">12</span>,</span><br><span class="line">                <span class="string">&#x27;Romance&#x27;</span> : <span class="number">13</span>,</span><br><span class="line">                <span class="string">&#x27;Sci-Fi&#x27;</span> : <span class="number">14</span>,</span><br><span class="line">                <span class="string">&#x27;Thriller&#x27;</span> : <span class="number">15</span>,</span><br><span class="line">                <span class="string">&#x27;War&#x27;</span> : <span class="number">16</span>,</span><br><span class="line">                <span class="string">&#x27;Western&#x27;</span> : <span class="number">17</span>&#125;</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">2</span> <span class="keyword">or</span> j == <span class="number">3</span> <span class="keyword">or</span> j == <span class="number">4</span> <span class="keyword">or</span> j == <span class="number">6</span>:</span><br><span class="line">                tmp.append(<span class="built_in">int</span>(data[i][j]))</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">1</span>:</span><br><span class="line">                tmp += ([<span class="number">1</span>, <span class="number">0</span>] <span class="keyword">if</span> data[i][j]==<span class="string">&#x27;M&#x27;</span> <span class="keyword">else</span> [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss = data[i][j].split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                afterchange = [strtonum[s] <span class="keyword">for</span> s <span class="keyword">in</span> ss]</span><br><span class="line">                zeros = [<span class="number">0</span>] * <span class="number">18</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> afterchange:</span><br><span class="line">                    zeros[k] = <span class="number">1</span></span><br><span class="line">                tmp += zeros</span><br><span class="line">        ans.append(tmp)</span><br><span class="line">    data = np.array(ans)</span><br><span class="line">    change = &#123;<span class="number">1</span>:<span class="number">0</span>,<span class="number">18</span>:<span class="number">1</span>,<span class="number">25</span>:<span class="number">2</span>,<span class="number">35</span>:<span class="number">3</span>,<span class="number">45</span>:<span class="number">4</span>,<span class="number">50</span>:<span class="number">5</span>,<span class="number">56</span>:<span class="number">6</span>&#125; <span class="comment"># 为了使用F.one_hot，需要做一个映射</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data.shape[<span class="number">0</span>]):</span><br><span class="line">        data[i, <span class="number">3</span>] = change[data[i, <span class="number">3</span>]]</span><br><span class="line">    data = torch.tensor(data, dtype=torch.int64)</span><br><span class="line">    data2, data3 = F.one_hot(data[:,<span class="number">3</span>], num_classes=<span class="number">7</span>), F.one_hot(data[:,<span class="number">4</span>], num_classes=<span class="number">21</span>)</span><br><span class="line">    data1, data5 = data[:, <span class="number">1</span>:<span class="number">3</span>], data[:, <span class="number">6</span>:<span class="number">24</span>]</span><br><span class="line">    data0, data4, data6 = torch.unsqueeze(data[:,<span class="number">0</span>], dim=<span class="number">1</span>), torch.unsqueeze(data[:,<span class="number">5</span>], dim=<span class="number">1</span>), torch.unsqueeze(data[:,-<span class="number">1</span>], dim=<span class="number">1</span>)</span><br><span class="line">    np.save(<span class="string">&#x27;./moviedata_vectorform.npy&#x27;</span>, np.array(torch.cat((data0,data1,data2,data3,data4,data5), dim=<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p><img src="https://z3.ax1x.com/2021/10/05/4joxOO.png" alt=""></p><h4 id="4-3-Residual-Unit定义"><a href="#4-3-Residual-Unit定义" class="headerlink" title="4.3  Residual Unit定义"></a>4.3  Residual Unit定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResidualUnit</span>(<span class="params">nn.Module</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, innodes, hiddennodes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear1 = nn.Linear(in_features=innodes, out_features=hiddennodes, bias=<span class="literal">True</span>)</span><br><span class="line">        self.linear2 = nn.Linear(in_features=hiddennodes, out_features=innodes, bias=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(self.linear2(F.relu(self.linear1(x))) + x)</span><br></pre></td></tr></table></figure><h4 id="4-4-Deep-Crossing-模型定义"><a href="#4-4-Deep-Crossing-模型定义" class="headerlink" title="4.4 Deep Crossing 模型定义"></a>4.4 Deep Crossing 模型定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCrossing</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dense_index, sparse_index, embedding_dim=<span class="number">8</span>, res_hidden=[<span class="number">24</span>, <span class="number">20</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">8</span>]</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dense_index = dense_index</span><br><span class="line">        self.sparse_index = sparse_index</span><br><span class="line">        self.embedding_dim = embedding_dim</span><br><span class="line">        self.res_hidden = res_hidden</span><br><span class="line">        self.embedding_layers = nn.ModuleList([</span><br><span class="line">            nn.Embedding(num_embeddings=index[<span class="number">1</span>]-index[<span class="number">0</span>], embedding_dim=self.embedding_dim) <span class="keyword">for</span> index <span class="keyword">in</span> self.sparse_index</span><br><span class="line">        ])</span><br><span class="line">        </span><br><span class="line">        self.stack_dim = <span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x[<span class="number">1</span>]-x[<span class="number">0</span>], self.dense_index))) + self.embedding_dim * <span class="built_in">len</span>(self.sparse_index)</span><br><span class="line">        </span><br><span class="line">        self.residual_layers = nn.ModuleList([</span><br><span class="line">            ResidualUnit(self.stack_dim, h) <span class="keyword">for</span> h <span class="keyword">in</span> self.res_hidden</span><br><span class="line">        ])</span><br><span class="line">        </span><br><span class="line">        self.score_layer = nn.Linear(self.stack_dim, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        sparse_embeddings = [self.embedding_layers[idx](x[:, i[<span class="number">0</span>]:i[<span class="number">1</span>]]) \</span><br><span class="line">                             <span class="keyword">for</span> idx, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.sparse_index)]</span><br><span class="line">        x = x.<span class="built_in">float</span>() <span class="comment"># x是long类型，embedding的结果是float类型</span></span><br><span class="line">        sparse_embeddings = [torch.squeeze(torch.matmul(torch.unsqueeze(x[:, i[<span class="number">0</span>]:i[<span class="number">1</span>]],<span class="number">1</span>), sparse_embeddings[idx])) \</span><br><span class="line">                            <span class="keyword">for</span> idx, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.sparse_index)]</span><br><span class="line">        sparse_embeddings = torch.cat(sparse_embeddings, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        dense_embeddings = [x[:, i[<span class="number">0</span>]:i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> self.dense_index]</span><br><span class="line">        dense_embeddings = torch.cat(dense_embeddings, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        output = torch.cat((dense_embeddings, sparse_embeddings), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> residual <span class="keyword">in</span> self.residual_layers:</span><br><span class="line">            output = residual(output)</span><br><span class="line"></span><br><span class="line">        result = torch.sigmoid(self.score_layer(output)).squeeze()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="4-5-模型训练"><a href="#4-5-模型训练" class="headerlink" title="4.5 模型训练"></a>4.5 模型训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model, lossF, optimizer, train_iter</span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        model.train()</span><br><span class="line">        TOTALLOSS, TOTALLEN = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_pred = model(x)</span><br><span class="line">            l = lossF(y_pred, y.<span class="built_in">float</span>()).<span class="built_in">sum</span>()</span><br><span class="line">            TOTALLOSS += l.item()</span><br><span class="line">            TOTALLEN += <span class="built_in">len</span>(y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        <span class="built_in">print</span>(TOTALLOSS / TOTALLEN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">1000</span>, <span class="string">&#x27;display.max_columns&#x27;</span>,<span class="literal">None</span>,</span><br><span class="line">                <span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x:<span class="string">&quot;%.2f&quot;</span> % x)</span><br><span class="line"></span><br><span class="line">    dense_index = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">10</span>), (<span class="number">31</span>, <span class="number">32</span>)] <span class="comment"># 在Tensor中特征对应的起始和结束索引</span></span><br><span class="line">    sparse_index = [(<span class="number">10</span>, <span class="number">31</span>), (<span class="number">32</span>, <span class="number">50</span>)]</span><br><span class="line">    data = torch.tensor(np.load(<span class="string">&#x27;./moviedata_vectorform.npy&#x27;</span>))</span><br><span class="line">    X, Y  = data[:, :-<span class="number">1</span>], data[:, -<span class="number">1</span>]</span><br><span class="line">    train_iter = DataLoader(TensorDataset(X, Y), batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    dc = DeepCrossing(dense_index, sparse_index)</span><br><span class="line">    optimizer = torch.optim.Adam(dc.parameters(), lr=<span class="number">1e-4</span>, weight_decay=<span class="number">0.1</span>)</span><br><span class="line">    loss = nn.MSELoss()</span><br><span class="line">    train(dc, loss, optimizer, train_iter)</span><br></pre></td></tr></table></figure><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>在复现论文的时候遇到了一个问题，<strong>有关nn.Embedding和nn.Linear的区别</strong>，于是结合个人理解稍微记录一下。</p><blockquote><ul><li>其根本区别在于输入，nn.Linear的输入为一个向量，输出也为一个向量，向量的各个维度的元素取值范围是连续的；而nn.Embedding的输入只能为离散值，这个离散值实际上相当于取One-Hot之后的向量。</li><li>nn.Embedding() 第一个参数是embedding的数量 $N$，第二个参数是embedding后的维度 $M$，该函数得到的结果是一个二维矩阵 $N×M$。因为embedding的输入是一个One-Hot形式的编码，只有一个维度的值为1，其它均为0。所以，取维度值为1所对应的 $M$ 维embedding向量和将原始输入(One-Hot向量)与二维矩阵 $N×M$做矩阵乘法两者的结果是一样的。原始输入对应着 $x$，embedding后得到的二维矩阵为权重矩阵 $w$，因此nn.Embedding和nn.Linear的区别就是少了一个偏置项 $b$，其它的可以说没什么区别。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(5):AutoRec</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-5-AutoRec.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-5-AutoRec.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>$AutoRec$ 模型是由澳大利亚国立大学在2015年提出的，它将自编码器($AutoEncoder$)的思想与协同过滤($Collaborative　Filter$)的思想结合起来，提出了一种单隐层的简单神经网络推荐模型。可以说这个模型的提出，拉开了使用深度学习解决推荐系统问题的序幕，为复杂深度学习网络的构建提供了思路。</p><p>原文地址：<a href="https://users.cecs.anu.edu.au/~akmenon/papers/autorec/autorec-paper.pdf">AutoRec: Autoencoders Meet Collaborative Filtering</a></p><span id="more"></span><h3 id="一、自动编码器AutoEncoder"><a href="#一、自动编码器AutoEncoder" class="headerlink" title="一、自动编码器AutoEncoder"></a>一、自动编码器AutoEncoder</h3><h4 id="1-1-自编码器的介绍"><a href="#1-1-自编码器的介绍" class="headerlink" title="1.1 自编码器的介绍"></a>1.1 自编码器的介绍</h4><p>自编码器是一种<strong>无监督</strong>的<strong>数据维度压缩和数据特征</strong>表达方法，它是神经网络的一种，经过训练后能尝试将输入复制到输出。自编码器由编码器和解码器组成，结构如下：</p><p><img src="https://z3.ax1x.com/2021/09/17/4MmWLT.png" alt=""></p><p>  其中，输入为 $x$，输出为 $r$ ，$S$ 代表所有的输入数据向量，$h=f(x)$ 表示编码器，$r=g(h)$ 表示解码器，自编码器的目标便是优化损失函数：</p><script type="math/tex; mode=display">min \mathop{\sum}\limits_{r \in S} ||r-g(h)||^2_2</script><p>也就是令图中红色部分的Error值最小。</p><blockquote><p>Q1：输出向量与输入向量误差最小有什么意义？直接使用原始输入向量不行吗？为什么需要编码和解码这些操作？</p><p>A1：比如协同过滤中，每个用户对每个物品不可能都评过分，即当数据规模较大时，共现矩阵是一个巨大的稀疏矩阵，该矩阵存在大量的缺失值。故将初始向量通过已训练好的AutoEncoder模型得到的输出向量会因为网络权重的作用而自动填补一些缺失值，与输入向量有所区别。</p><p>事实上，AutoEncoder的中间隐层是其最有用的特性之一。其可以作为特征提取的结果，也可作为数据降维的结果等。</p><p>Q2：既然共现矩阵稀疏，存在大量缺失值，怎么处理缺失值？训练的效果会好吗？</p><p>A2：缺失值的处理可以尝试用0代替，在训练过程中，不同输入向量的不同缺失值相互弥补了输出向量的空缺。个人理解是某些输入向量的训练集中在某些权值上，而另一些与其缺失值不同的输入向量的训练集中在另一些权值上。</p></blockquote><h4 id="1-2-自编码器与前馈神经网络的比较："><a href="#1-2-自编码器与前馈神经网络的比较：" class="headerlink" title="1.2 自编码器与前馈神经网络的比较："></a>1.2 自编码器与前馈神经网络的比较：</h4><blockquote><ul><li>自编码器是前馈神经网络的一种，最开始主要用于数据的降维以及特征的抽取，随着技术的不断发展，现在也被用于生成模型中，可用来生成图片等。</li><li>前馈神经网络是有监督学习，其需要大量的标注数据；自编码器是无监督学习，数据不需要标注因此较容易收集。</li><li>前馈神经网络在训练时主要关注输出层的数据以及错误率；而自编码器可能更多的关注中间隐层的结果。</li></ul></blockquote><h3 id="二、AutoRec"><a href="#二、AutoRec" class="headerlink" title="二、AutoRec"></a>二、AutoRec</h3><p>$AutoRec$ 模型跟多层感知机类似，是一个标准的3层全连接神经网络，只不过它结合了自编码器和协同过滤的思想。再确切一点说，$AutoRec$ 模型就是一个标准的自编码器结构，它的基本原理是利用协同过滤中的共现矩阵，完成物品向量或者用户向量的自编码，再利用自编码结果得到用户对所有物品的评分，结果通过排序之后就可以用于物品推荐。</p><h4 id="2-1-模型结构"><a href="#2-1-模型结构" class="headerlink" title="2.1 模型结构"></a>2.1 模型结构</h4><p>在基于评分数据的协同过滤算法中，假设我们有 $m$ 个用户，$n$ 个物品，则有用户-物品评分矩阵 $R \in  {\Bbb R}^{m×n}$ 。对于一个用户 $u$ 来说，他对所有 $n$ 个物品的评分数据可以形成一个 $n$ 维的向量 $r^{(u)}=(R_{u1},\cdots,R_{un})$。同理，对于一个物品 $i$ 而言，所有 $m$ 个用户对它的评分可以构成一个 $m$ 维的向量 $r^{(i)}=(R_{1i},\cdots,R_{mi})$  。其中 $R_{ui}$ 代表的是用户 $u$ 对 物品 $i$ 的评分。</p><p>下面是 $AutoRec$ 的整体模型框图：</p><p><img src="https://z3.ax1x.com/2021/09/17/4MlL6A.png" alt=""></p><p>可以看到整个模型只有3层，蓝色的圆点代表的是隐层神经元，红色方框代表的是模型的输入，经过权重矩阵 $V$ 到达隐藏层，再经过权重矩阵 $W$ 到达输出层，我们的目的是通过训练模型，找到合适的权重矩阵 $V$ 和 $W$，以及偏置 $\mu$ 和 $b$，使得输入和输出的误差最小。令模型的重建函数为 $h(r;\theta)$，其中 $r \in {\Bbb R}^d$，其定义如下：</p><script type="math/tex; mode=display">h(r;\theta) = f(W·g(Vr+\mu)+b)</script><p>其中， $f(·)$ 代表的是输出层的神经元激活函数，$g(·)$ 代表的是隐层神经元的激活函数。$\theta=\{W,V,\mu,b\}$，$V$ 和 $W$ 分别是隐层和输出层的权重矩阵，$\mu$ 和 $b$ 分别是隐层和输出层的偏置。</p><h4 id="2-2-损失函数"><a href="#2-2-损失函数" class="headerlink" title="2.2 损失函数"></a>2.2 损失函数</h4><script type="math/tex; mode=display">\mathop{min}\limits_{\theta}\sum^n_{i=1}||r^{(i)}-h(r^{(i)};\theta)||^2_2+\frac{\lambda}{2}(||W||^2_2+||V||^2_2)</script><h4 id="2-3-基于AutoRec的推荐过程"><a href="#2-3-基于AutoRec的推荐过程" class="headerlink" title="2.3 基于AutoRec的推荐过程"></a>2.3 基于AutoRec的推荐过程</h4><h5 id="Item-AutoRec"><a href="#Item-AutoRec" class="headerlink" title="Item-AutoRec"></a>Item-AutoRec</h5><ul><li>依次输入物品 $i$ 的评分向量 $r^{(i)}$，得到模型输出的预测评分向量 $h(r^{(i)};\theta)$；</li><li>遍历所有物品预测评分向量的第 $u$ 维，得到用户 $u$ 对所有物品的评分，进行排序之后得到用户 $u$ 的推荐列表。</li></ul><h5 id="User-AutoRec"><a href="#User-AutoRec" class="headerlink" title="User-AutoRec"></a>User-AutoRec</h5><ul><li>依次输入用户 $u$ 的评分向量 $r^{(u)}$，得到模型输出的预测评分向量 $h(r^{(u)};\theta)$；</li><li>进行排序得到用户 $u$ 的推荐列表。</li></ul><h3 id="三、代码演示"><a href="#三、代码演示" class="headerlink" title="三、代码演示"></a>三、代码演示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> moviesData <span class="keyword">import</span> readRatings</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># AutoRec_user_based</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRec</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_users, num_items, hidden_nodes=<span class="number">1000</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.num_users = num_users</span><br><span class="line">        self.num_items = num_items</span><br><span class="line">        self.hidden_nodes = hidden_nodes</span><br><span class="line"></span><br><span class="line">        self.encoder = nn.Sequential(</span><br><span class="line">            nn.Linear(self.num_items, self.hidden_nodes),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.decoder = nn.Sequential(</span><br><span class="line">            nn.Linear(self.hidden_nodes, self.num_items),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.decoder(self.encoder(X))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epochs, data_iter</span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        epochloss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_iter):</span><br><span class="line">            loss = lossF(net(x), x)</span><br><span class="line">            epochloss += loss.item()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        losslist.append(epochloss/(i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 共现矩阵</span></span><br><span class="line">    comatrix = torch.tensor(np.load(<span class="string">&#x27;./comatrix.npy&#x27;</span>), dtype=torch.float32)</span><br><span class="line">    trainX, testX = comatrix[:<span class="built_in">int</span>(<span class="number">0.7</span>*comatrix.shape[<span class="number">0</span>])], comatrix[<span class="built_in">int</span>(<span class="number">0.7</span>*comatrix.shape[<span class="number">0</span>]):]</span><br><span class="line">    data_iter = data.DataLoader(trainX, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    net = AutoRec(trainX.shape[<span class="number">0</span>], trainX.shape[<span class="number">1</span>])</span><br><span class="line">    lossF = nn.MSELoss()</span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(), lr=<span class="number">1e-4</span>, weight_decay=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">    losslist = []</span><br><span class="line">    train(<span class="number">1000</span>, data_iter)</span><br></pre></td></tr></table></figure><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>$AutoRec$ 模型是深度学习方法用于推荐系统中的开山之作，它仅仅使用了一个单隐层的自编码器来泛化用户和物品评分，使模型具有一定的泛化和表达能力。但是由于模型过于简单，也让它在实际使用中显得表征能力不足。</p>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCodeLCP07:传递信息</title>
      <link href="/LeetCodeLCP07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF.html"/>
      <url>/LeetCodeLCP07-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><img src="https://z3.ax1x.com/2021/09/15/4eMWad.png" alt=""></p><span id="more"></span><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><p><img src="https://z3.ax1x.com/2021/09/15/4eMRVH.png" alt=""></p><h3 id="三、条件限制"><a href="#三、条件限制" class="headerlink" title="三、条件限制"></a>三、条件限制</h3><p><img src="https://z3.ax1x.com/2021/09/15/4eMgqe.png" alt=""></p><h3 id="四、解题思路及代码"><a href="#四、解题思路及代码" class="headerlink" title="四、解题思路及代码"></a>四、解题思路及代码</h3><p>记 $dp[i][j]$ 为经过第 $i$ 轮传递到编号 $j$ 的玩家的方案数。</p><p>对于传信息的关系 $[from_, to_]$，如果第 $i$ 轮传递到编号 $from_$ 的玩家，则第 $i+1$ 轮可以从编号 $from_$ 的玩家传递到编号 $to_$ 的玩家。因此在计算 $dp[i+1][to_]$ 时，需要考虑可以传递到编号 $to_$ 的所有玩家，即：</p><script type="math/tex; mode=display">dp[i+1][to\_] = \sum dp[i][from\_]</script><p>最终，$dp[k][n-1]$ 即为方案总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span>(<span class="params">self, n: <span class="built_in">int</span>, relation: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">for</span> re <span class="keyword">in</span> relation:</span><br><span class="line">                from_, to_ = re</span><br><span class="line">                dp[i+<span class="number">1</span>][to_] += dp[i][from_]</span><br><span class="line">        <span class="keyword">return</span> dp[k][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode338:比特位计数</title>
      <link href="/LeetCode338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html"/>
      <url>/LeetCode338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><img src="https://z3.ax1x.com/2021/09/15/4enpHs.png" alt=""></p><span id="more"></span><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><p><img src="https://z3.ax1x.com/2021/09/15/4enCEn.png" alt=""></p><h3 id="三、条件限制"><a href="#三、条件限制" class="headerlink" title="三、条件限制"></a>三、条件限制</h3><p><img src="https://z3.ax1x.com/2021/09/15/4enSBj.png" alt=""></p><h3 id="四、解题思路及代码"><a href="#四、解题思路及代码" class="headerlink" title="四、解题思路及代码"></a>四、解题思路及代码</h3><h4 id="4-1-动态规划——最高有效位"><a href="#4-1-动态规划——最高有效位" class="headerlink" title="4.1 动态规划——最高有效位"></a>4.1 动态规划——最高有效位</h4><p>记 $dp[i]$ 表示索引 $i$ 所对应二进制数的 $「1比特数」$。</p><ul><li>如果最高位为 $1$ 且其余位均为 $0$，即 $i \&amp; (i-1)=0$，有 $dp[i]=1$ 。</li><li>$i$ 比 $i-highBit$ 的 $「1比特数」$ 多 $1$ ，即 $dp[i] = dp[i-highBit]+1$</li></ul><p>其中，$highBit$ 是二进制最高位为 $1$ 且其余位为 $0$ 的数，$i$ 和 $highBit$ 的二进制位数相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        dp, h = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)], <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &amp; (i-<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                h = i</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">            dp[i] = dp[i - h] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h4 id="4-2-动态规划——最低有效位"><a href="#4-2-动态规划——最低有效位" class="headerlink" title="4.2 动态规划——最低有效位"></a>4.2 动态规划——最低有效位</h4><p>对于正整数 $x$ ，将其二进制表示右移一位，得到的数是 $\lfloor \frac{x}{2} \rfloor$，如果 $dp[\lfloor \frac{x}{2} \rfloor]$ 的值已知，则可以得到 $dp[x]$ 的值：</p><ul><li>如果 $x$ 是偶数， 则 $dp[x]=dp[\lfloor \frac{x}{2} \rfloor]$；</li><li>如果 $x$ 是奇数，则 $dp[x]=dp[\lfloor \frac{x}{2} \rfloor]+1$；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = (dp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h3 id="五、补充"><a href="#五、补充" class="headerlink" title="五、补充"></a>五、补充</h3><ul><li><p>判断一个二进制数是否最高位为 $1$ 且其余位为0：$x\&amp;(x-1)==0$ ；</p></li><li><p>$x=x\&amp;(x-1)$，该运算将 $x$ 的二进制数最后一个 $1$ 变为 $0$。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1442:形成两个异或相等数组的三元组数目</title>
      <link href="/LeetCode1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE.html"/>
      <url>/LeetCode1442-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><img src="https://z3.ax1x.com/2021/09/11/hzSGRI.png" alt=""></p><span id="more"></span><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><p><img src="https://z3.ax1x.com/2021/09/11/hzS8JA.png" alt=""></p><h3 id="三、条件限制"><a href="#三、条件限制" class="headerlink" title="三、条件限制"></a>三、条件限制</h3><p><img src="https://z3.ax1x.com/2021/09/11/hzS3id.png" alt=""></p><h3 id="四、解题思路及代码"><a href="#四、解题思路及代码" class="headerlink" title="四、解题思路及代码"></a>四、解题思路及代码</h3><p><img src="https://z3.ax1x.com/2021/09/11/hzSho4.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/09/11/hzSfwF.png" alt=""></p><h4 id="4-1-三重循环"><a href="#4-1-三重循环" class="headerlink" title="4.1 三重循环"></a>4.1 三重循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        s = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> arr:</span><br><span class="line">            s.append(s[-<span class="number">1</span>] ^ val)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j, n):</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[k + <span class="number">1</span>]:</span><br><span class="line">                        ans += <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="4-2-二重循环"><a href="#4-2-二重循环" class="headerlink" title="4.2 二重循环"></a>4.2 二重循环</h4><p>当等式 $S_i=S_{k+1}$ 成立时，$[i+1,k]$ 的范围内任意 $j$ 都是符合要求的， 对应的三元组个数为 $k-i$ ，因此只需枚举 $i$ 和 $k$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        s = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> arr:</span><br><span class="line">            s.append(s[-<span class="number">1</span>] ^ val)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[k + <span class="number">1</span>]:</span><br><span class="line">                    ans += k - i  </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode剑指Offer56-II:数组中数字出现的次数II</title>
      <link href="/LeetCode%E5%89%91%E6%8C%87Offer56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II.html"/>
      <url>/LeetCode%E5%89%91%E6%8C%87Offer56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><img src="https://z3.ax1x.com/2021/09/11/hx46HK.png" alt=""></p><span id="more"></span><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><p><img src="https://z3.ax1x.com/2021/09/11/hx4R4e.png" alt=""></p><h3 id="三、条件限制"><a href="#三、条件限制" class="headerlink" title="三、条件限制"></a>三、条件限制</h3><p><img src="https://z3.ax1x.com/2021/09/11/hx5yxs.png" alt=""></p><h4 id="四、解题思路及代码"><a href="#四、解题思路及代码" class="headerlink" title="四、解题思路及代码"></a>四、解题思路及代码</h4><h4 id="4-1-遍历"><a href="#4-1-遍历" class="headerlink" title="4.1 遍历"></a>4.1 遍历</h4><p>比较容易想到的思路是<strong>对数组排序后遍历数组，从索引1开始，如果当前元素和前一个元素相同，则索引指针往后跳三个，否则return前一个元素的值，当然考虑索引指针的边界情况。</strong>详见代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> i + <span class="number">3</span> &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                i = i + <span class="number">3</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[i+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="4-2-进制位法"><a href="#4-2-进制位法" class="headerlink" title="4.2 进制位法"></a>4.2 进制位法</h4><p>如下图所示，考虑数字的二进制形式。<strong>对于出现三次的数字，各二进制位出现的次数都是3的倍数。因此，统计所有数字的各二进制位中1的出现次数，并对3求余，结果则为只出现一次的数字。</strong></p><p><img src="https://z3.ax1x.com/2021/09/11/hx53Pe.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>)]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">                count[j] += num &amp; <span class="number">1</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            ans &lt;&lt;= <span class="number">1</span></span><br><span class="line">            ans |= count[<span class="number">30</span>-k] % <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(4):GBDT+LR</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-4-GBDT-LR.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-4-GBDT-LR.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CTR预估（Click-Through Rate Prediction）是互联网计算广告中的关键环节，预估准确性直接影响公司广告收入。CTR预估中用的最多的模型是LR（Logistic Regression），LR是广义线性模型，这种线性模型很容易并行化，处理上亿条训练样本不是问题。但线性模型学习能力有限，需要大量特征工程预先分析出有效的特征、特征组合，从而去间接增强LR的非线性学习能力。</p><p>LR模型中的特征组合很关键， 但又无法直接通过特征笛卡尔积解决，只能依靠人工经验，耗时耗力同时并不一定会带来效果提升。如何自动发现有效的特征、特征组合，弥补人工经验不足，缩短LR特征实验周期，是亟需解决的问题。Facebook　2014年的文章介绍了通过GBDT（Gradient Boost Decision Tree）解决LR的特征组合问题，随后Kaggle竞赛也有实践此思路，GBDT与LR融合开始引起了业界关注。</p><p>GBDT（Gradient Boost Decision Tree）是一种常用的非线性模型，它基于集成学习中的boosting思想，每次迭代都在减少残差的梯度方向新建立一颗决策树，迭代多少次就会生成多少颗决策树。GBDT的思想使其具有天然优势可以发现多种有区分性的特征以及特征组合，决策树的路径可以直接作为LR输入特征使用，省去了人工寻找特征、特征组合的步骤。这种通过GBDT生成LR特征的方式（GBDT+LR），业界已有实践（Facebook，Kaggle-2014），且效果不错，是非常值得尝试的思路。</p><span id="more"></span><h3 id="一、GBDT"><a href="#一、GBDT" class="headerlink" title="一、GBDT"></a>一、GBDT</h3><p><img src="https://z3.ax1x.com/2021/09/05/hR77VO.png" alt=""></p><h3 id="二、LR"><a href="#二、LR" class="headerlink" title="二、LR"></a>二、LR</h3><p><a href="https://qzmvc1.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%80-%E4%BB%8E%E9%9B%B6%E8%AE%A4%E8%AF%86%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html">机器学习日记(一):从零认识逻辑回归</a></p><p><img src="https://z3.ax1x.com/2021/09/05/hRbGtg.png" alt=""></p><h3 id="三、GBDT-LR模型结构"><a href="#三、GBDT-LR模型结构" class="headerlink" title="三、GBDT+LR模型结构"></a>三、GBDT+LR模型结构</h3><p>一个训练样本在输入GBDT的某一子树后，会根据每个节点的规则最终落入某一叶子节点，把该叶子节点设置为1，其它叶子节点设置为0，所有叶子节点组成的向量即形成了该棵树的特征向量，把GBDT所有子树的特征向量连接起来，即形成了后续LR模型输入的离散型特征向量。</p><p><img src="https://z3.ax1x.com/2021/09/05/hRH6yt.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(3):从FM到FFM</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-3-%E4%BB%8EFM%E5%88%B0FFM.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-3-%E4%BB%8EFM%E5%88%B0FFM.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、为什么需要特征组合？"><a href="#一、为什么需要特征组合？" class="headerlink" title="一、为什么需要特征组合？"></a>一、为什么需要特征组合？</h3><p>在仅利用单一特征而非交叉特征进行判断的情况下，有时不仅是信息损失的问题，甚至会得出错误的结论。著名的“辛普森悖论”用一个非常简单的例子，说明了进行多维度特征交叉的重要性。</p><h4 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h4><p>在对样本集合进行分组研究时，在分组比较中都占优势的一方，在总评中有时反而是失势的一方，这种有悖常理的现象，被称为“辛普森悖论”。</p><p>假设表2-1和表2-2所示为某视频应用中男性用户和女性用户点击视频的数据。</p><span id="more"></span><table>    <caption>表2-1 男性用户</caption></table><div class="table-container"><table><thead><tr><th style="text-align:center">视频</th><th style="text-align:center">点击（次）</th><th style="text-align:center">曝光（次）</th><th style="text-align:center">点击率</th></tr></thead><tbody><tr><td style="text-align:center">视频A</td><td style="text-align:center">8</td><td style="text-align:center">530</td><td style="text-align:center">1.51%</td></tr><tr><td style="text-align:center">视频B</td><td style="text-align:center">51</td><td style="text-align:center">1520</td><td style="text-align:center">3.36%</td></tr></tbody></table></div><table>    <caption>表2-2 女性用户</caption></table><div class="table-container"><table><thead><tr><th style="text-align:center">视频</th><th style="text-align:center">点击（次）</th><th style="text-align:center">曝光（次）</th><th style="text-align:center">点击率</th></tr></thead><tbody><tr><td style="text-align:center">视频A</td><td style="text-align:center">201</td><td style="text-align:center">2510</td><td style="text-align:center">8.01%</td></tr><tr><td style="text-align:center">视频B</td><td style="text-align:center">92</td><td style="text-align:center">1010</td><td style="text-align:center">9.11%</td></tr></tbody></table></div><p>从以上数据中可以看出，无论男性用户还是女性用户，对视频B的点击率都高于视频A，显然推荐系统应该优先考虑向用户推荐视频B。</p><p>那么，如果忽略性别这个维度，将数据汇总（如表2-3所示）会得出什么结论呢？</p><table>    <caption>表2-3 数据汇总</caption></table><div class="table-container"><table><thead><tr><th style="text-align:center">视频</th><th style="text-align:center">点击（次）</th><th style="text-align:center">总曝光（次）</th><th style="text-align:center">点击率</th></tr></thead><tbody><tr><td style="text-align:center">视频A</td><td style="text-align:center">209</td><td style="text-align:center">3040</td><td style="text-align:center">6.88%</td></tr><tr><td style="text-align:center">视频B</td><td style="text-align:center">143</td><td style="text-align:center">2530</td><td style="text-align:center">5.65%</td></tr></tbody></table></div><p>在汇总结果中，视频A的点击率居然比视频B高。如果据此进行推荐，将得出与之前结果完全相反的结论，这就是所谓的“辛普森悖论”。</p><p><strong>在辛普森悖论的例子中，分组实验相当于使用“性别”+“视频ID”的组合特征计算点击率，而汇总实验则使用“视频ID”这一单一特征计算点击率。汇总实验对高维特征进行了合并，损失了大量的有效信息，因此无法正确地刻画数据模式。</strong></p><h3 id="二、特征交叉的开始——POLY2模型"><a href="#二、特征交叉的开始——POLY2模型" class="headerlink" title="二、特征交叉的开始——POLY2模型"></a>二、特征交叉的开始——POLY2模型</h3><script type="math/tex; mode=display">POLY2(w,x)=w_0+\sum_{i=1}^n w_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n w_{ij}x_ix_j</script><p>可以看到，该模型对所有特征进行了两两交叉（特征 $x_i$ 和 $x_j$），并对所有特征组合赋予权重 $w_{ij}$ 。$POLY2$ 通过暴力组合特征的方式，在一定程度上解决了特征组合的问题。但该模型存在两个较大的缺陷：</p><blockquote><ul><li>在处理数据时，经常采用 one-hot 编码的方法处理类别型数据，致使特征向量极度稀疏， $POLY2$ 进行无选择的特征交叉，使原本就非常稀疏的特征向量更加稀疏，导致大部分交叉特征的权重缺乏有效的数据进行训练，无法收敛。</li><li>权重参数的数量由 $n$ 直接上升到 $n^2$ ，极大的增加了训练复杂度。</li></ul></blockquote><h3 id="三、因子分解机模型（Factorization-Machine-FM）（2010年）"><a href="#三、因子分解机模型（Factorization-Machine-FM）（2010年）" class="headerlink" title="三、因子分解机模型（Factorization Machine, FM）（2010年）"></a>三、因子分解机模型（Factorization Machine, FM）（2010年）</h3><script type="math/tex; mode=display">FM(w,x)=w_0+\sum_{i=1}^n w_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n （\vec{v_i}\cdot \vec{v_j}）x_ix_j</script><p>与 $POLY2$ 相比，其主要区别是用两个向量的内积 $（\vec{v_i}\cdot \vec{v_j}）$ 取代了单一的权重系数 $w_{ij}$ 。具体地说，$FM$ 为每个特征学习了一个权重隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。</p><p>本质上，$FM$ 引入隐向量的做法，与矩阵分解用隐向量代表用户和物品的做法异曲同工。可以说， $FM$ 是将矩阵分解隐向量的思想进行了进一步扩展，从单纯的用户、物品隐向量扩展到了所有特征上。</p><p>$FM$ 通过引入特征隐向量的方式，直接把 $POLY2$ 模型 $n^2$ 级别的权重参数数量减少到了 $nk$ （$k$ 为隐向量维度， $n&gt;&gt;k$），极大地降低了训练开销；而且，隐向量的引入使  $FM$ 能更好地解决数据稀疏性的问题。比如在 $POLY2$ 模型中，只有当特征$x_i,x_j$ 均非零时，才能训练与之对应的 $w_{ij}$，而对于 $FM$ ，每个特征都有其对应的隐向量，减少了训练条件的苛刻性，并且对于未出现的特征组合，只要模型之前分别学习过对应的隐向量，就具备了计算其特征组合权重的能力。</p><p>$FM$ 公式二次项后继推导如下：</p><p><img src="https://z3.ax1x.com/2021/08/07/fKQC26.png" alt=""></p><p>采用梯度下降法求解参数：</p><script type="math/tex; mode=display">\frac{∂FM}{∂ \theta}=\begin{cases}1,&\theta=w_0 \cr x_i,&\theta=w_i \cr x_i\sum_{i=1}^n(v_{ik}x_i)-v_{ik}x_i^2,&\theta=v_{ik}\end{cases}</script><h3 id="四、特征域感知因子分解机模型（Field-aware-Factorization-Machines，FFM）（2015年）"><a href="#四、特征域感知因子分解机模型（Field-aware-Factorization-Machines，FFM）（2015年）" class="headerlink" title="四、特征域感知因子分解机模型（Field-aware Factorization Machines，FFM）（2015年）"></a>四、特征域感知因子分解机模型（Field-aware Factorization Machines，FFM）（2015年）</h3><script type="math/tex; mode=display">FFM(w,x)=w_0+\sum_{i=1}^n w_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n （\vec{v_{i，f_j}}\cdot \vec{v_{j,f_i}}）x_ix_j</script><p>其与 $FM$ 的区别在于隐向量由原来的 $\vec{v_i}$ 变成了 $\vec{v_{i，f_j}}$ ，这意味着每个特征对应的不是唯一一个隐向量，而是一组隐向量。当 $x_i$ 特征与 $x_j$ 特征进行交叉时， $x_i$ 特征会从 $x_i$ 的这一组隐向量中挑出与特征 $x_j$ 的域 $f_j$ 对应的隐向量 $\vec{v_{i，f_j}}$ 进行交叉。同理， $x_j$ 也会用与 $x_i$ 的域 $f_i$ 对应的隐向量 $\vec{v_{j，f_i}}$ 进行交叉。</p><h4 id="为什么引入Field？"><a href="#为什么引入Field？" class="headerlink" title="为什么引入Field？"></a>为什么引入Field？</h4><p>如下表所示，其中性别和年龄同属于user维度特征，而tag属于item维度特征。<strong>在FM原理讲解中，“男性”与“篮球”、“男性”与“年龄”所起潜在作用是默认一样的，但实际上不一定。FM算法无法捕捉这个差异，因为它不区分更广泛类别field的概念，而会使用相同参数的点积来计算。</strong></p><div class="table-box"><table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>field</td><td colspan="5" rowspan="1">user field(<em><strong>U</strong></em>)</td><td colspan="2" rowspan="1">item field(<em><strong>I</strong></em>)</td></tr><tr><td>clicked</td><td>userId</td><td>Gender_男</td><td>Gender_女</td><td>Age_[20,30]</td><td>Age_[30,40]</td><td>Tag_篮球</td><td>Tag_化妆品</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><p>在 $FFM$（Field-aware Factorization Machines ）中每一维特征（feature）都归属于一个特定的 $field$，$field$ 和 $feature$ 是一对多的关系。</p><p>$FFM$ 模型认为 $v_i$ 不仅跟 $x_i$ 有关系，还跟与 $x_i$ 相乘的 $x_j$ 所属的Field有关系，即 $v_i$ 成了一个二维向量 $v_{f×k}$，$k$ 是隐向量长度，$f$ 是Field的总个数。设样本一共有 $n$ 个特征, 那么 $FFM$ 的二次项有 $nf$ 个隐向量。而在 $FM$ 模型中，每一维特征的隐向量只有一个。$FM$ 可以看作 $FFM$ 的特例，是把所有特征都归属到一个 $field$ 时的 $FFM$ 模型。 </p><h3 id="五、FM与FFM的代码实现"><a href="#五、FM与FFM的代码实现" class="headerlink" title="五、FM与FFM的代码实现"></a>五、FM与FFM的代码实现</h3><h4 id="5-1-FM"><a href="#5-1-FM" class="headerlink" title="5.1 FM"></a>5.1 FM</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FM</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n = n  <span class="comment"># 特征个数</span></span><br><span class="line">        self.k = k  <span class="comment"># 隐向量维度</span></span><br><span class="line">        self.linear = nn.Linear(n, <span class="number">1</span>, bias=<span class="literal">True</span>) <span class="comment"># 一次项部分</span></span><br><span class="line">        self.v = nn.parameter(torch.randn(k, n))  <span class="comment"># 隐向量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># x: (batch, n)</span></span><br><span class="line">        part1 = self.linear(x)</span><br><span class="line">        ans1 = torch.<span class="built_in">pow</span>(torch.mm(x, self.v.t()), <span class="number">2</span>)</span><br><span class="line">        ans2 = torch.mm(torch.<span class="built_in">pow</span>(x, <span class="number">2</span>), torch.<span class="built_in">pow</span>(self.v.t(), <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="number">0.5</span> * torch.<span class="built_in">sum</span>(ans1 - ans2)</span><br></pre></td></tr></table></figure><h4 id="5-2-FFM"><a href="#5-2-FFM" class="headerlink" title="5.2 FFM"></a>5.2 FFM</h4><p>代码详解参考：<a href="https://www.cnblogs.com/sunupo/p/12826308.html">推荐系统——FFM模型点击率CTR预估（代码，数据流动详细过程）</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldAwareFactorizationMachine</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, field_dims, embed_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.num_fields = <span class="built_in">len</span>(field_dims)</span><br><span class="line">        self.embeddings = torch.nn.ModuleList([</span><br><span class="line">            torch.nn.Embedding(<span class="built_in">sum</span>(field_dims), embed_dim) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.num_fields)</span><br><span class="line">        ])</span><br><span class="line">        self.offsets = np.array((<span class="number">0</span>, *np.cumsum(field_dims)[:-<span class="number">1</span>]), dtype=np.long)</span><br><span class="line">        <span class="keyword">for</span> embedding <span class="keyword">in</span> self.embeddings:</span><br><span class="line">            torch.nn.init.xavier_uniform_(embedding.weight.data)  <span class="comment">#初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x + x.new_tensor(self.offsets, dtype=np.long).unsqueeze(<span class="number">0</span>)</span><br><span class="line">        xs = [self.embeddings[i](x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_fields)]</span><br><span class="line">        ix = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_fields - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, self.num_fields):</span><br><span class="line">                ix.append(xs[j][:, i] * xs[i][:, j])</span><br><span class="line">        ix = torch.stack(ix, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FieldAwareFactorizationMachineModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, field_dims, embed_dim</span>):</span></span><br><span class="line">        <span class="comment"># field_dims:[10, 20, 30] 共3个field,每个field下各多少特征</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="built_in">sum</span>(field_dims))</span><br><span class="line">        self.ffm = FieldAwareFactorizationMachine(field_dims, embed_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param x: Long tensor of size ``(batch_size, num_fields)``</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ffm_term = torch.<span class="built_in">sum</span>(torch.<span class="built_in">sum</span>(self.ffm(x), dim=<span class="number">1</span>), dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        x = self.linear(x) + ffm_term</span><br><span class="line">        <span class="keyword">return</span> torch.sigmoid(x.squeeze(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(2):矩阵分解</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-2-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-2-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>针对协同过滤算法的头部效应较明显、泛化能力较弱的问题，矩阵分解算法被提出。矩阵分解在协同过滤算法中“共现矩阵”的基础上，加入了隐向量的概念，加强了模型处理稀疏矩阵的能力，针对性地解决了协同过滤存在的主要问题。</p><span id="more"></span><h3 id="一、矩阵分解"><a href="#一、矩阵分解" class="headerlink" title="一、矩阵分解"></a>一、矩阵分解</h3><p>矩阵分解有几个明显的特点，它具有协同过滤的 “集体智慧”，隐语义的 “深层关系”，以及机器学习的 “以目标为导向的有监督学习”。在了解了基于邻域的协同过滤算法后，集体智慧自不必多说，我们依次从 “隐因子” 和 “有监督学习” 的角度来了解矩阵分解的基本思路。</p><p>推荐算法中的矩阵分解最初的想法是从奇异值分解（Singular Value Decomposition，SVD）借鉴来的。以 $Netflix$ 用户对电影的评分矩阵为例，矩阵分解，直观上来说就是把原来的大矩阵，近似分解成两个小矩阵的乘积，在实际推荐计算时不再使用大矩阵，而是使用分解得到的两个小矩阵。按照矩阵分解的原理，我们会发现原来 $m×n$ 的大矩阵会分解成 $m×k$ 和 $k×n$ 的两个小矩阵，这里多出来一个 $k$ 维向量，就是隐因子向量（Latent Factor Vector）。$k$ 的大小决定了隐向量表达能力的强弱。 $k$ 的取值越小，隐向量包含的信息越少，模型的泛化程度越高；反之，$k$ 的取值越大，隐向量的表达能力越强，但泛化程度相应降低。此外，$k$ 的取值还与矩阵分解的求解复杂度直接相关。</p><p><img src="https://z3.ax1x.com/2021/07/31/Wj2vge.png" alt=""></p><p><strong>基于矩阵分解的推荐算法的核心假设是用隐向量来表达用户和物品，他们的乘积关系就成为了原始的元素。</strong>这种假设之所以成立，是因为我们认为实际的交互数据是由一系列的隐向量的影响下产生的，这些隐向量代表了用户和物品一部分共有的特征，在物品身上表现为属性特征，在用户身上表现为偏好特征，只不过这些因子并不具有实际意义，也不一定具有非常好的可解释性，每一个维度也没有确定的标签名字，所以才会叫做 “隐变量”。而矩阵分解后得到的两个包含隐变量的小矩阵，一个代表用户的隐含特征，一个代表物品的隐含特征，矩阵的元素值代表着相应用户或物品对各项隐因子的符合程度，有正面的也有负面的。</p><p>我们再从机器学习的角度来了解矩阵分解，<strong>我们已经知道评分预测实际上是一个矩阵补全的过程，在矩阵分解的时候原来的大矩阵必然是稀疏的，即有一部分有评分，有一部分是没有评分的，不然也就没必要预测和推荐了，所以整个预测模型的最终目的是得到两个小矩阵，通过这两个小矩阵的乘积来补全大矩阵中没有评分的位置。</strong>所以对于机器学习模型来说，<strong>问题转化成了如何获得两个最优的小矩阵</strong>。因为大矩阵有一部分是有评分的，那么只要保证大矩阵有评分的位置（实际值）与两个小矩阵相乘得到的相应位置的评分（预测值）之间的误差最小即可，其实就是一个均方误差损失，这便是模型的目标函数。</p><p><img src="https://z3.ax1x.com/2021/07/31/WjRr8O.png" alt=""></p><h3 id="二、矩阵分解的优缺点"><a href="#二、矩阵分解的优缺点" class="headerlink" title="二、矩阵分解的优缺点"></a>二、矩阵分解的优缺点</h3><blockquote><p><strong>矩阵分解具有以下优点：</strong></p><ul><li>泛化能力强。在一定程度上解决了数据稀疏的问题。</li><li>空间复杂度低。不需再存储协同过滤模型所需的“庞大“用户相似性或物品相似性矩阵，只需存储用户和物品隐向量空间复杂度由 $n^2$ 级别降低到 $(n+m)*k$ 级别。</li><li>更好的扩展性和灵活性。矩阵分解最终产出的是用户和物品隐向量，这其实与深度学习中的Embedding思想不谋而合，因此矩阵分解的结果也非常便于与其他特征进行组合和拼接，与深度学习网络进行无缝组合。</li></ul><p><strong>矩阵分解也有一些局限性：</strong></p><ul><li>矩阵分解不方便加入用户、物品、上下文相关的特征，丧失了利用很多有效信息的机会。</li><li>在缺乏用户历史行为时，无法进行有效的推荐。</li><li>模型训练比较费时。</li><li>推荐结果不具有很好的可解释性，分解出来的用户和物品矩阵的每个维度无法用现实生活中的概念来解释，只能理解为潜在语义空间。</li></ul></blockquote><h3 id="三、矩阵分解相关算法"><a href="#三、矩阵分解相关算法" class="headerlink" title="三、矩阵分解相关算法"></a>三、矩阵分解相关算法</h3><h4 id="3-1-奇异值分解SVD"><a href="#3-1-奇异值分解SVD" class="headerlink" title="3.1 奇异值分解SVD"></a>3.1 奇异值分解SVD</h4><p>有关SVD的原理阐述请参考我的相关博客：<a href="https://qzmvc1.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%9B%9B-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3.html">机器学习日记(四):奇异值分解</a></p><p>虽然奇异值分解解决了矩阵分解问题，但其存在两点缺陷，使其不宜作为互联网场景下矩阵分解的主要方法：</p><ul><li>SVD 要求矩阵是稠密的，而现实场景中的共现矩阵是稀疏的，有大量空白，无法直接使用 SVD 分解。要想使用 SVD，必须对评分矩阵中的缺失值进行简单的补全，比如用全局平均值或者用用户物品平均值补全，得到补全后的矩阵。接着可以用 SVD 分解并降维。但填充本身会造成很多问题，其一，填充大大增加了数据量，增加了算法复杂度。其二，简单粗暴的数据填充很容易造成数据失真。</li><li>传统奇异值分解的计算复杂度达到了 $O(mn^2)$ 的级别，这对于商品数量动辄上百万、用户数量往往上千万的互联网场景来说几乎是不可接受的。</li></ul><h4 id="3-2-Funk-SVD"><a href="#3-2-Funk-SVD" class="headerlink" title="3.2 Funk-SVD"></a>3.2 Funk-SVD</h4><p>$Simon　Funk$ 在博客上公开发表了一个只考虑已有评分记录的矩阵分解方法，称为 $Funk-SVD$，也就是被 $Yehuda Koren$ 称为隐语义模型的矩阵分解方法。它的出发点为，既然将一个矩阵做 SVD 分解成 3 个矩阵很耗时，同时还面临稀疏的问题，<strong>那么我们能不能避开稀疏问题，同时只分解成两个矩阵呢？</strong>也就是说，现在期望我们的矩阵$M$ 这样进行分解：</p><script type="math/tex; mode=display">M_{m×n}=P_{m×k}^TQ_{k×n}</script><p><strong>这种简化的矩阵分解不再是分解为三个矩阵，而是分解为两个低秩的用户和物品矩阵，其实就是把用户和物品都映射到一个 $k$ 维空间中，</strong>这个 $k$ 维空间对应着 $k$ 个隐因子，我们认为用户对物品的评分主要是由这些隐因子影响的，所以这些隐因子代表了用户和物品一部分共有的特征，在物品身上表现为属性特征，在用户身上表现为偏好特征。只不过这些隐因子并不具有实际意义，也不一定具有非常好的可解释性，每一个维度也没有确定的标签名字，所以才会叫做 “隐因子”。</p><p>我们知道 $SVD$ 分解已经很成熟了，但是 $Funk-SVD$ 如何将矩阵 $M$ 分解成为 $P$ 和 $Q$ 呢？<strong>这里采用了线性回归的思想。我们的目标是让用户的评分和用矩阵乘积得到的评分残差尽可能的小</strong>，也就是说，可以用均方差作为损失函数，来寻找最终的P和Q。即通过 User-Item 评分信息来学习到的用户特征矩阵 $P$ 和物品特征矩阵 $Q$，通过重构的低维矩阵预测用户对物品的评分。</p><p>对于某一个用户评分 $m_{ij}$ 如果用 $Funk-SVD$ 进行矩阵分解，则对应的表示为 $q_j^Tp_i$，采用均方差作为损失函数，则我们期望 $(m_{ij}-q_j^Tp_i)^2$ 尽可能的小，如果考虑所有的物品和样本的组合，则我们期望最小化下式：</p><script type="math/tex; mode=display">\sum_{i,j}(m_{ij}-q_j^Tp_i)^2</script><p>只要我们能够最小化上面的式子，并求出极值所对应的 $p_i,q_j$，则我们最终可以得到矩阵 $P$ 和 $Q$，那么对于任意矩阵 $M$ 任意一个空白评分的位置，我们可以通过 $q_j^Tp_i$ 计算预测评分，很漂亮的方法！</p><p>当然，在实际应用中，为了防止过拟合，会加入一个 $L2$ 的正则化项，因此正式的 $Funk-SVD$ 的优化目标函数是这样的：</p><script type="math/tex; mode=display">arg\mathop{min}\limits_{p_i,q_j}\sum_{(i,j)\in K}(m_{ij}-q_j^Tp_i)^2+\lambda(||p_i||^2_2+||q_j||^2_2)</script><p>其中 $K$ 为已有评分记录的 $(i,j)$ 对集合，$m_{ij}$ 为用户 $i$ 对物品 $j$ 的真实评分，$\lambda$ 是正则化系数。对于这个优化问题，一般通过<strong>梯度下降法</strong>来进行优化得到结果。</p><p>将上式分别对 $p_i,q_j$ 求导：</p><script type="math/tex; mode=display">\frac{∂J}{∂p_i} = -2(m_{ij}-q_j^Tp_i)q_j+2\lambda p_i</script><script type="math/tex; mode=display">\frac{∂J}{∂q_j} = -2(m_{ij}-q_j^Tp_i)p_i+2\lambda q_j</script><p>则在梯度下降法迭代时，$p_i,q_j$ 的迭代公式为：</p><script type="math/tex; mode=display">p_i = p_i + \alpha ((m_{ij}-q_j^Tp_i)q_j-\lambda p_i)</script><script type="math/tex; mode=display">q_j = q_j + \alpha ((m_{ij}-q_j^Tp_i)p_i-\lambda q_j)</script><h4 id="3-3-Bias-SVD"><a href="#3-3-Bias-SVD" class="headerlink" title="3.3 Bias-SVD"></a>3.3 Bias-SVD</h4><p>在 $Funk-SVD$ 算法火爆之后，出现了很多 $Funk-SVD$ 的改进版算法。其中 $Bias$ 算是改进的比较成功的一种算法。其在 $Funk-SVD$ 的基础上加了偏置项特征。</p><p>由于不同用户的打分体系不同（比如在5分为满分的情况下，有的用户认为打3分已经是很低的分数了，而有的用户认为打1分才是比较差的评价），不同用户的衡量标准也有所区别（比如电子产品的平均分和日用品的平均分差异有可能比较大），为了消除用户和物品打分的偏差（Bias），常用的做法是在矩阵分解时加入用户和物品的偏差向量，如下所示：</p><script type="math/tex; mode=display">r_{ui} = \mu + b_i + b_u + q_j^Tp_i</script><p>偏置部分主要由三个子部分组成：</p><ul><li>训练集中所有评分记录的全局平均数 $\mu$ ，表示了训练数据的总体评分情况，对于固定的数据集，它是一个常数。</li><li>用户偏置 $b_u$，独立于物品特征的因素，表示某一特定用户的打分习惯。例如，对于批判性用户对于自己的评分比较苛刻，倾向于打低分；而乐观型用户则打分比较保守，总体打分要偏高。</li><li>物品偏置 $b_i$ ，特立于用户兴趣的因素，表示某一特定物品得到的打分情况。以电影为例，好片获得的总体评分偏高，而烂片获得的评分普遍偏低，物品偏置捕获的就是这样的特征。</li></ul><p>加入了偏置项以后的优化目标函数如下所示：</p><script type="math/tex; mode=display">arg\mathop{min}\limits_{p_i,q_j}\sum_{(i,j)\in K}(m_{ij}-q_j^Tp_i-\mu-b_i-b_u)^2+\lambda(||p_i||^2_2+||q_j||^2_2+||b_i||^2_2+||b_u||^2_2)</script><h3 id="四、基于Pytorch的矩阵分解"><a href="#四、基于Pytorch的矩阵分解" class="headerlink" title="四、基于Pytorch的矩阵分解"></a>四、基于Pytorch的矩阵分解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bias-SVD代码实现</span></span><br><span class="line"><span class="comment"># 基于MovieLens 1M数据集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> moviesData <span class="keyword">import</span> readRatings</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MFDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, u_id, i_id, rating</span>):</span></span><br><span class="line">        self.u_id = u_id</span><br><span class="line">        self.i_id = i_id</span><br><span class="line">        self.rating = rating</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.u_id[index], self.i_id[index], self.rating[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.rating)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MF</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_users, num_items, mean, embedding_size=<span class="number">100</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.user_emb = nn.Embedding(num_users, embedding_size) <span class="comment"># 隐向量</span></span><br><span class="line">        self.user_bias = nn.Embedding(num_users, <span class="number">1</span>)  <span class="comment"># 用户偏置</span></span><br><span class="line">        self.item_emb = nn.Embedding(num_items, embedding_size) <span class="comment"># 隐向量</span></span><br><span class="line">        self.item_bias = nn.Embedding(num_items, <span class="number">1</span>)  <span class="comment"># 物品偏置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 参数初始化</span></span><br><span class="line">        self.user_emb.weight.data.uniform_(<span class="number">0</span>, <span class="number">0.005</span>)  <span class="comment"># 0-0.05之间均匀分布</span></span><br><span class="line">        self.user_bias.weight.data.uniform_(-<span class="number">0.01</span>, <span class="number">0.01</span>)</span><br><span class="line">        self.item_emb.weight.data.uniform_(<span class="number">0</span>, <span class="number">0.005</span>)</span><br><span class="line">        self.item_bias.weight.data.uniform_(-<span class="number">0.01</span>, <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 全局偏置</span></span><br><span class="line">        <span class="comment"># 将不可训练的tensor转换成可训练的类型parameter，并绑定到module里，net.parameter()中就有了这个参数</span></span><br><span class="line">        self.mean = nn.Parameter(torch.FloatTensor([mean]), <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, u_id, i_id</span>):</span></span><br><span class="line">        U = self.user_emb(u_id)</span><br><span class="line">        b_u = self.user_bias(u_id).squeeze()</span><br><span class="line">        I = self.item_emb(i_id)</span><br><span class="line">        b_i = self.item_bias(i_id).squeeze()</span><br><span class="line">        <span class="keyword">return</span> (U * I).<span class="built_in">sum</span>(<span class="number">1</span>) + b_u + b_i + self.mean <span class="comment"># 返回预测评分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model, x_train, y_train, loss_func</span>):</span></span><br><span class="line">    train_ls = [] <span class="comment"># 返回训练误差</span></span><br><span class="line">    train_dataset = MFDataset(x_train[:, <span class="number">0</span>], x_train[:, <span class="number">1</span>], y_train)</span><br><span class="line">    <span class="comment"># DataLoader将一个batch_size封装成一个tensor，方便迭代</span></span><br><span class="line">    train_iter = DataLoader(train_dataset, batch_size=<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># weight_decay是正则化系数</span></span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-4</span>, weight_decay=<span class="number">0.1</span>)</span><br><span class="line">    model = model.<span class="built_in">float</span>()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        model.train()  <span class="comment"># 如果模型中有Batch Normalization或Dropout层，需要在训练时添加model.train()，使起作用</span></span><br><span class="line">        total_loss, total_len = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x_u, x_i, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_pred = model(x_u, x_i)</span><br><span class="line">            l = loss_func(y_pred, y).<span class="built_in">sum</span>()</span><br><span class="line">            optimizer.zero_grad() <span class="comment"># 清空这一批的梯度</span></span><br><span class="line">            l.backward() <span class="comment"># 回传</span></span><br><span class="line">            optimizer.step() <span class="comment"># 参数更新</span></span><br><span class="line"></span><br><span class="line">            total_loss += l.item()</span><br><span class="line">            total_len += <span class="built_in">len</span>(y)</span><br><span class="line">        train_ls.append(total_loss / total_len)</span><br><span class="line">    <span class="keyword">return</span> train_ls</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">1000</span>, <span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>,</span><br><span class="line">                  <span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x:<span class="string">&quot;%.2f&quot;</span> % x)</span><br><span class="line">    path = <span class="string">r&#x27;C:\Users\QzmVc1\Desktop\MovieLens&#x27;</span></span><br><span class="line">    df = readRatings(path)</span><br><span class="line"></span><br><span class="line">    x, y = df.iloc[:, :<span class="number">2</span>], df.iloc[:, <span class="number">2</span>]</span><br><span class="line">    x = torch.tensor(x.values, dtype=torch.int64)</span><br><span class="line">    y = torch.tensor(y.values, dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x.numpy(), y.numpy(), test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    mean_rating = df.iloc[:, <span class="number">2</span>].mean()</span><br><span class="line">    <span class="comment"># 虽然数据集的UserID是从1开始的，但这里还是需要+1，因为nn.Embedding是从索引0开始，而model(x_u, x_i)传的是真实的ID</span></span><br><span class="line">    num_users, num_items = df[<span class="string">&#x27;UserID&#x27;</span>].<span class="built_in">max</span>()+<span class="number">1</span>, df[<span class="string">&#x27;MovieID&#x27;</span>].<span class="built_in">max</span>()+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    model = MF(num_users, num_items, mean_rating)</span><br><span class="line">    loss = nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    train_ls = train(model, x_train, y_train, loss)</span><br><span class="line">    <span class="built_in">print</span>(train_ls)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的推荐算法之路(1):协同过滤</title>
      <link href="/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-1-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4.html"/>
      <url>/%E6%88%91%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-1-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是协同过滤？"><a href="#一、什么是协同过滤？" class="headerlink" title="一、什么是协同过滤？"></a>一、什么是协同过滤？</h3><p>顾名思义，<strong>“协同过滤”就是协同大家的反馈、评价和意见一起对海量的信息进行过滤，从中筛选出目标用户可能感兴趣的信息的推荐过程</strong>。其主要分为：</p><ul><li>基于用户相似度进行推荐的协同过滤算法（$UserCF$）</li><li>基于物品相似度进行推荐的协同过滤算法（$ItemCF$）</li></ul><span id="more"></span><h3 id="二、基于用户相似度进行推荐的协同过滤算法（-UserCF-）"><a href="#二、基于用户相似度进行推荐的协同过滤算法（-UserCF-）" class="headerlink" title="二、基于用户相似度进行推荐的协同过滤算法（$UserCF$）"></a>二、基于用户相似度进行推荐的协同过滤算法（$UserCF$）</h3><h4 id="2-1-UserCF流程"><a href="#2-1-UserCF流程" class="headerlink" title="2.1 UserCF流程"></a>2.1 UserCF流程</h4><blockquote><ol><li><p>基于历史数据，构建以用户（假设用户总数为 $m$）为行坐标，物品（物品总数为 $n$）为列坐标的 $m×n$ 维的共现矩阵；</p></li><li><p>计算共现矩阵两两行向量间的相似性，构建 $m×m$ 维的用户相似度矩阵；</p></li><li><p>若要对用户 $K$ 进行推荐时，利用其 $Top$ $n$ 相似用户的已有评价对目标用户的偏好进行预测，生成最终推荐结果。</p><script type="math/tex; mode=display">R_{u,p} = \frac{\sum_{s \in S}(w_{u,s}*R_{s,p})}{\sum_{s \in S}w_{u,s}}</script><p>其中，权重 $w_{u,s}$ 是用户 $u$ 和用户 $s$ 的相似度， $R_{s,p}$ 是用户 $s$ 对物品 $p$ 的评分。</p></li><li><p>由以上公式得到用户 $u$ 对物品的预测得分，进行排序即可得到最终的推荐列表。</p></li></ol></blockquote><h4 id="2-2-存在的缺点"><a href="#2-2-存在的缺点" class="headerlink" title="2.2 存在的缺点"></a>2.2 存在的缺点</h4><ul><li>在互联网应用的场景下，用户数远大于物品数，而 $UserCF$ 需要维护用户相似度矩阵以便快速找出 $Top$ $n$ 相似用户。该用户相似度矩阵的存储开销非常大，而且随着业务的发展，用户数的增长会导致用户相似度矩阵的存储空间以 $n^2$ 的速度快速增长，这是在线存储系统难以承受的扩展速度。</li><li>用户的历史数据向量往往非常稀疏，对于只有几次购买或点击行为的用户来说，找到相似用户的准确度是非常低的，这导致 $UserCF$ 不适用于那些正反馈获取较困难的应用场景（如酒店预定、大件商品购买等低频应用）。</li></ul><h3 id="三、基于物品相似度进行推荐的协同过滤算法（ItemCF）"><a href="#三、基于物品相似度进行推荐的协同过滤算法（ItemCF）" class="headerlink" title="三、基于物品相似度进行推荐的协同过滤算法（ItemCF）"></a>三、基于物品相似度进行推荐的协同过滤算法（<strong>ItemCF</strong>）</h3><h4 id="3-1-ItemCF流程"><a href="#3-1-ItemCF流程" class="headerlink" title="3.1 ItemCF流程"></a>3.1 ItemCF流程</h4><blockquote><ol><li><p>基于历史数据，构建以用户（假设用户总数为 $m$）为行坐标，物品（物品总数为 $n$）为列坐标的 $m×n$ 维的共现矩阵；</p></li><li><p>计算共现矩阵两两列向量间的相似性，构建 $n×n$ 维的用户相似度矩阵；</p></li><li><p>获得用户历史行为数据中的正反馈物品列表；</p></li><li><p>利用物品相似度矩阵，针对目标用户历史行为中的正反馈物品，找出相似的 $Top$ $k$ 个物品，组成相似物品集合；</p></li><li><p>对相似物品集合中的物品，利用相似度分值进行排序，生成最终的推荐列表，物品的相似度分值计算公式如下：</p><script type="math/tex; mode=display">R_{u,p}=\sum_{h \in H} (R_{u,h}*w_{p,h})</script><p>其中，$H$ 是目标用户的正反馈物品集合，$w_{p,h}$ 是物品 $p$ 与物品 $h$ 的物品相似度，$R_{u,h}$ 是用户 $u$ 对物品 $h$ 的已有评分。</p></li></ol></blockquote><h3 id="四、相似度计算"><a href="#四、相似度计算" class="headerlink" title="四、相似度计算"></a>四、相似度计算</h3><p><strong>（1） 余弦相似度</strong>。余弦相似度衡量了用户向量 $i$ 和用户向量 $j$ 之间的向量夹角大小。显然，夹角越小，证明余弦相似度越大，两个用户越相似。</p><script type="math/tex; mode=display">sim(\vec{i},\vec{j})=cos(\vec{i},\vec{j})=\frac{\vec{i}\cdot \vec{j}}{\mid \mid\vec{i}\mid\mid\cdot \mid \mid\vec{j}\mid\mid}</script><p><strong>（2）皮尔逊相关系数。</strong>相比余弦相似度，皮尔逊相关系数通过使用用户平均分对各独立评分进行修正，减小了用户评分偏置的影响。</p><script type="math/tex; mode=display">sim(i,j) = \frac{\sum_{p\in P}(R_{i,p}-\overline{R_i})(R_{j,p}-\overline{R_j})}{\sqrt{\sum_{p\in P}(R_{i,p}-\overline{R_i})^2}\sqrt{\sum_{p\in P}(R_{j,p}-\overline{R_j})^2}}</script><h3 id="五、-UserCF-与-ItemCF-的应用场景"><a href="#五、-UserCF-与-ItemCF-的应用场景" class="headerlink" title="五、$UserCF$ 与 $ItemCF$ 的应用场景"></a>五、$UserCF$ 与 $ItemCF$ 的应用场景</h3><ul><li>一方面，由于 $UserCF$ 基于用户相似度进行推荐，使其具备更强的社交特性，用户能够快速得知与自己兴趣相似的人最近喜欢的是什么。这样的特点使其非常适用于新闻推荐场景。因为新闻本身的兴趣点往往是分散的，相比用户对不同新闻的兴趣偏好，新闻的及时性、热点性往往是其更重要的属性，而 $UserCF$ 正适用于发现热点，以及跟踪热点的趋势。</li><li>另一方面，$ItemCF$ 更适用于兴趣变化较为稳定的应用，比如在 $Amazon$ 的电商场景中，用户在一个时间段内更倾向于寻找一类商品，这时利用物品相似度为其推荐相关物品是契合用户动机的。</li></ul><h3 id="六、存在缺点及未来展望"><a href="#六、存在缺点及未来展望" class="headerlink" title="六、存在缺点及未来展望"></a>六、存在缺点及未来展望</h3><ul><li>热门的物品具有很强的头部效应，容易跟大量物品产生相似性；而尾部物品由于特征向量稀疏，很少与其他物品产生相似性，导致很少被推荐；</li><li>为解决上述问题，同时增加模型的泛化能力，矩阵分解技术被提出。该方法在共现矩阵的基础上，使用更稠密的隐向量表示用户和物品，挖掘用户和物品的隐含兴趣和特征，在一定程度上弥补了协同过滤模型处理稀疏矩阵能力不足的问题。</li><li>另外，协同过滤仅利用用户和物品的交互信息，无法有效地引入用户年龄、性别、商品描述、商品分类、当前时间等一系列用户特征、商品特征、上下文特征，造成了有效信息的遗漏；</li><li>为解决上述问题，推荐系统逐渐发展到以逻辑回归模型为核心、能够综合不同类型特征的机器学习模型的道路上。</li></ul><h3 id="七、代码实现"><a href="#七、代码实现" class="headerlink" title="七、代码实现"></a>七、代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集：MovieLens 1M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readMovies</span>(<span class="params">path</span>):</span></span><br><span class="line">    movies = pd.read_table(os.path.join(path, <span class="string">&#x27;movies.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    movies.columns = [<span class="string">&#x27;MovieID&#x27;</span>, <span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Genres&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> movies</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readUsers</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Age: &#123;1, &#x27;under 18&#x27;,  18: &quot;18-24&quot;,  25: &quot;25-34&quot;,  35: &quot;35-44&quot;,</span></span><br><span class="line"><span class="string">              45: &quot;45-49&quot;,    50: &quot;50-55&quot;,  56: &quot;56+&quot;,&#125;&quot;&quot;&quot;</span></span><br><span class="line">    users = pd.read_table(os.path.join(path, <span class="string">&#x27;users.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    users.columns = [<span class="string">&#x27;UserID&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Zip-code&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> users</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readRatings</span>(<span class="params">path</span>):</span></span><br><span class="line">    ratings = pd.read_table(os.path.join(path, <span class="string">&#x27;ratings.dat&#x27;</span>), header=<span class="literal">None</span>, sep=<span class="string">&#x27;::&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    ratings.columns = [<span class="string">&#x27;UserID&#x27;</span>, <span class="string">&#x27;MovieID&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>, <span class="string">&#x27;Timestamp&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> ratings</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UserCF.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> moviesData <span class="keyword">import</span> readMovies, readUsers, readRatings</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reCoMatrix</span>(<span class="params">df, rows, cols</span>):</span>   <span class="comment"># 生成共现矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...Generating co-occurrence matrix...&#x27;</span>)</span><br><span class="line">    coMatrix = np.zeros((rows, cols), dtype=np.<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(df.shape[<span class="number">0</span>]):</span><br><span class="line">        UserID, MovieID, Rating = df.iloc[i, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">        coMatrix[UserID-<span class="number">1</span>, MovieID-<span class="number">1</span>] = Rating</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...Co-occurrence matrix generation completed!...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> coMatrix  <span class="comment"># type: numpyArray (rows, cols)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cosSimilarity</span>(<span class="params">a, b</span>):</span>      <span class="comment"># 相似度计算</span></span><br><span class="line">    a_norm = np.linalg.norm(a)</span><br><span class="line">    b_norm = np.linalg.norm(b)</span><br><span class="line">    <span class="keyword">return</span> np.dot(a, b) / (a_norm * b_norm)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reSimilarMatrix</span>(<span class="params">coMatrix, n</span>):</span>  <span class="comment"># 用户相似度矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...Generating Similarity matrix...&#x27;</span>)</span><br><span class="line">    similarMatrix = np.ones((n, n), dtype=np.<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            similarMatrix[i, j] = cosSimilarity(coMatrix[i], coMatrix[j])</span><br><span class="line">            similarMatrix[j, i] = similarMatrix[i, j]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...Similarity matrix generation completed!...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> similarMatrix  <span class="comment"># type: numpyArray (n, n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortMatrix</span>(<span class="params">similarMatrix, K, N</span>):</span>   <span class="comment"># 返回与第K个用户相关的Top N个相似度列表</span></span><br><span class="line">    df = pd.DataFrame(similarMatrix, index=<span class="built_in">range</span>(similarMatrix.shape[<span class="number">0</span>]), columns=<span class="built_in">range</span>(similarMatrix.shape[<span class="number">0</span>]))</span><br><span class="line">    df = df.iloc[:, K-<span class="number">1</span>].sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> df[:N]    <span class="comment"># 与第K个用户最相似的排序结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillScore</span>(<span class="params">coMatrix, sortMatrix</span>):</span>  <span class="comment"># 计算用户对物品的预测打分</span></span><br><span class="line">    index = <span class="built_in">list</span>(sortMatrix.index)</span><br><span class="line">    score = np.array(sortMatrix.values)[<span class="number">1</span>:]</span><br><span class="line">    ans = coMatrix[index][<span class="number">1</span>:]</span><br><span class="line">    results = np.<span class="built_in">sum</span>(np.expand_dims(score, axis=<span class="number">1</span>)*ans, axis=<span class="number">0</span>) / np.<span class="built_in">sum</span>(score)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pd.set_option(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">1000</span>, <span class="string">&#x27;display.max_columns&#x27;</span>, <span class="literal">None</span>,</span><br><span class="line">                  <span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x:<span class="string">&quot;%.2f&quot;</span> % x)</span><br><span class="line">    np.set_printoptions(threshold=np.inf)</span><br><span class="line">    path = <span class="string">r&#x27;C:\Users\QzmVc1\Desktop\MovieLens&#x27;</span> <span class="comment"># movies/users/ratings</span></span><br><span class="line"></span><br><span class="line">    df = readRatings(path)</span><br><span class="line"></span><br><span class="line">    rows = df[<span class="string">&#x27;UserID&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">    cols = df[<span class="string">&#x27;MovieID&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line">    coMatrix = reCoMatrix(df, rows, cols)</span><br><span class="line">    similarMatrix = reSimilarMatrix(coMatrix, coMatrix.shape[<span class="number">0</span>])</span><br><span class="line">    df = sortMatrix(similarMatrix, <span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line">    results = fillScore(coMatrix, df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1863:找出所有子集的异或总和再求和</title>
      <link href="/LeetCode1863-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C.html"/>
      <url>/LeetCode1863-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><img src="https://z3.ax1x.com/2021/07/27/WhdvGR.png" alt=""></p><span id="more"></span><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><p><img src="https://z3.ax1x.com/2021/07/27/Whdzxx.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/27/WhwpM6.png" alt=""></p><p><img src="https://z3.ax1x.com/2021/07/27/WhdxR1.png" alt=""></p><h3 id="三、条件限制"><a href="#三、条件限制" class="headerlink" title="三、条件限制"></a>三、条件限制</h3><p><img src="https://z3.ax1x.com/2021/07/27/Whw9sK.png" alt=""></p><h3 id="四、解题思路及代码"><a href="#四、解题思路及代码" class="headerlink" title="四、解题思路及代码"></a>四、解题思路及代码</h3><h4 id="4-1-枚举子集"><a href="#4-1-枚举子集" class="headerlink" title="4.1 枚举子集"></a>4.1 枚举子集</h4><p>比较常见的思路是<strong>先枚举出列表的所有子集，然后对每个子集的元素求异或，最后累加各异或值。</strong></p><p>下面是Python生成列表所有子集的一般方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combination</span>(<span class="params">nums</span>):</span></span><br><span class="line">    ans = [[]] <span class="comment"># 含空集的初始列表</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        ans.extend([x+[num] <span class="keyword">for</span> x <span class="keyword">in</span> ans])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>不过我们可以通过itertools模块中的combinations快速生成子集，函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combinations(iterable, r) <span class="comment"># 参数1是可迭代对象，参数2是子集的元素数量</span></span><br></pre></td></tr></table></figure><p>该题该方案完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = [combinations(nums, i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        ss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">            ss += <span class="built_in">sum</span>([reduce(<span class="keyword">lambda</span> x,y:x^y, lst) <span class="keyword">for</span> lst <span class="keyword">in</span> i])</span><br><span class="line">        <span class="keyword">return</span> ss</span><br></pre></td></tr></table></figure><h4 id="4-2-进制位法"><a href="#4-2-进制位法" class="headerlink" title="4.2 进制位法"></a>4.2 进制位法</h4><p>一个长度为 $n$ 的数组 $nums$ 有 $2^n$ 个子集（包括空集与自身），数组中的每个元素都有「选取」与「未选取」两个状态，可以对应一个二进制位的 1 与 0。<strong>那么对于一个长度为 $n$ 的数组 $nums$ ，我们可以用 $n$ 个二进制位表示每个元素的选取情况，此时该二进制数第 $j$ 位的取值表示数组第 $j$ 个元素是否包含在对应的子集中。</strong>那么，每个子集就可转化为一串二进制数，即我们可以将这些子集一一映射到 $[0, 2^n -1]$ 中的整数。</p><p>因此，我们遍历 $[0, 2^n -1]$ 中的整数，每个整数实则代表了一种子集情况，遍历它的每一位计算对应子集的异或总和，并维护这些值之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> integer <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> integer &amp; (<span class="number">1</span> &lt;&lt; j): <span class="comment"># 判断二进制串上该位是否为1</span></span><br><span class="line">                    ans ^= nums[j]</span><br><span class="line">            res += ans</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="4-3-按位考虑-二项式展开"><a href="#4-3-按位考虑-二项式展开" class="headerlink" title="4.3 按位考虑 + 二项式展开"></a>4.3 按位考虑 + 二项式展开</h4><p>假设初始数组大小为 $N$，数组中每个元素均可用定长的二进制数表示。设数组所有元素中第 $i$ 位为 $1$ 的元素个数为 $K$，则第 $i$ 位为 $0$ 的元素个数为 $N-K$。对于某个子集，只有当该子集中第 $i$ 位为 $1$ 的元素个数总数为奇数时，子集元素最终异或结果的第 $i$ 位方为 $1$，那么只要我们求出这样的子集的总数目 $Count$ ，就可得出第 $i$ 位对最终结果影响为 $Count * (1 &lt;&lt; i)$ 。而 $Count$ 的计算包括<strong>从第 $i$ 位为 $1$ 的 $K$ 个元素中选择奇数个和从第 $i$ 位为 $0$ 的 $N-K$ 个元素中任意选</strong>两个阶段，所以：</p><script type="math/tex; mode=display">Count=(C_K^1+C_K^3+C_K^5+\dots+C_K^m)*2^{N-K}</script><p>其中 $m$ 为不大于 $K$ 的最大奇数。</p><p>而二项式系数，<strong>奇数项之和 = 偶数项之和 = $2^{K-1}$ 。</strong></p><p>故：</p><script type="math/tex; mode=display">Count = 2^{K-1}*2^{N-K} = 2^{N-1}</script><p>所以第 $i$ 位对结果的影响为： $2^{N-1}*(1 &lt;&lt; i)$。此结果与 $K$ 无关，因此我们只需对所有元素求或再移位即可。（排除数组中所有元素对应二进制数某位上全为 $0$ 的情况）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetXORSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ans |= num</span><br><span class="line">        <span class="keyword">return</span> ans &lt;&lt; (<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(八):CART</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%85%AB-CART.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%85%AB-CART.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>CART(Classification and Regression Tree)，又名分类回归树</strong>，是在ID3的基础上进行优化的决策树，CART有以下几个关键点：</p><ol><li>CART既能是分类树，又能是回归树；</li><li>当CART是分类树时，采用<strong>Gini</strong>值作为节点分裂的依据；当CART是回归树时，采用<strong>样本的最小方差</strong>作为节点分裂的依据；</li><li>CART<strong>是一棵二叉树</strong>。</li></ol><span id="more"></span><h3 id="一、实例"><a href="#一、实例" class="headerlink" title="一、实例"></a>一、实例</h3><div class="table-container"><table><thead><tr><th style="text-align:center">看电视时间</th><th style="text-align:center">婚姻情况</th><th style="text-align:center">职业</th><th style="text-align:center">年龄</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">未婚</td><td style="text-align:center">学生</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">未婚</td><td style="text-align:center">学生</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">已婚</td><td style="text-align:center">老师</td><td style="text-align:center">26</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">已婚</td><td style="text-align:center">上班族</td><td style="text-align:center">47</td></tr><tr><td style="text-align:center">2.5</td><td style="text-align:center">已婚</td><td style="text-align:center">上班族</td><td style="text-align:center">36</td></tr><tr><td style="text-align:center">3.5</td><td style="text-align:center">未婚</td><td style="text-align:center">老师</td><td style="text-align:center">29</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">已婚</td><td style="text-align:center">学生</td><td style="text-align:center">21</td></tr></tbody></table></div><h3 id="二、分类树？回归树？"><a href="#二、分类树？回归树？" class="headerlink" title="二、分类树？回归树？"></a>二、分类树？回归树？</h3><p>　　分类树的作用是通过一个对象的特征来预测该对象所属的类别，而回归树的目的是根据一个对象的信息预测该对象的属性，并以数值表示。</p><p>​      CART既能是分类树，又能是决策树，如上表所示，如果我们想预测一个人是否已婚，那么构建的CART将是分类树；如果想预测一个人的年龄，那么构建的将是回归树。</p><h3 id="三、CART如何选择分裂的属性？"><a href="#三、CART如何选择分裂的属性？" class="headerlink" title="三、CART如何选择分裂的属性？"></a>三、CART如何选择分裂的属性？</h3><p>　　分裂的目的是为了能够让数据变纯，使决策树输出的结果更接近真实值。那么CART是如何评价节点的纯度呢？<strong><em>如果是分类树</em></strong>，CART采用<strong>Gini</strong>值衡量节点纯度；<strong><em>如果是回归树</em></strong>，采用<strong>样本方差</strong>衡量节点纯度。节点越不纯，节点分类或者预测的效果就越差。</p><p>　　<strong>Gini</strong>值的计算公式：</p><script type="math/tex; mode=display">Gini=1-\mathop{\sum}\limits_{i \in I}{p_i^2}</script><p>　　 节点越不纯，Gini值越大。以二分类为例，如果节点的所有数据只有一个类别，则$Gini=1-\mathop{\sum}\limits_{i \in I}{p_i^2}=0$, 如果两类数量相同，则$Gini=1-\mathop{\sum}\limits_{i \in I}{p_i^2}=\frac{1}{2}$。</p><p>　　<strong>样本方差</strong>计算公式：</p><script type="math/tex; mode=display">\sigma=\sqrt{\mathop{\sum}\limits_{i \in I}(x_i-\mu)^2}</script><p>　　方差越大，表示该节点的数据越分散，预测的效果就越差。如果一个节点的所有数据都相同，那么方差就为0，此时可以很肯定得认为该节点的输出值；如果节点的数据相差很大，那么输出的值有很大的可能与实际值相差较大。</p><p>　　因此，无论是分类树还是回归树，CART都要选择使子节点的GINI值或者回归方差最小的属性作为分裂的方案。即最小化（分类树）：</p><script type="math/tex; mode=display">Gain=\mathop{\sum}\limits_{i \in I}P_i*Gini</script><p>或者（回归树）：</p><script type="math/tex; mode=display">Gain=\mathop{\sum}\limits_{i \in I}\sigma_i</script><h3 id="四、CART如何分裂成一棵二叉树？"><a href="#四、CART如何分裂成一棵二叉树？" class="headerlink" title="四、CART如何分裂成一棵二叉树？"></a>四、CART如何分裂成一棵二叉树？</h3><p>　　节点的分裂分为两种情况，连续型的数据和离散型的数据。   　　</p><p>　　CART对连续型属性的处理与C4.5差不多，通过最小化分裂后的 $Gini$值 或者 样本方差 寻找最优分割点，将数据一分为二。（对连续值的属性进行排序，$N$个数据共$N-1$个分裂点，每个分裂点计算$Gini$或者样本方差，找使其值最小的分裂点进行二分）</p><p>　　对于离散型属性，理论上有多少个离散值就应该分裂成多少个节点。但CART是一棵二叉树，每一次分裂只会产生两个节点，怎么办呢？很简单，只要将其中一个离散值独立作为一个节点，其他的离散值生成另外一个节点即可。这种分裂方案有多少个离散值就有多少种划分的方法，举一个简单的例子：如果某离散属性一个有三个离散值X，Y，Z，则该属性的分裂方法有{X}、{Y，Z}; {Y}、{X，Z};{Z}、{X，Y}，分别计算每种划分方法的 $Gini$值 或者 样本方差 确定最优的方法。</p><p><strong>划分方法举例：{“学生”}、{“老师”、“上班族”}</strong></p><p><img src="https://z3.ax1x.com/2021/07/24/W6AJXR.png" alt=""></p><p>预测是否已婚（分类）：</p><p><img src="https://z3.ax1x.com/2021/07/24/W6Atn1.png" alt=""></p><p>预测年龄（回归）：</p><p><img src="https://z3.ax1x.com/2021/07/24/W6AN0x.png" alt=""></p><h3 id="五、停止分裂的条件"><a href="#五、停止分裂的条件" class="headerlink" title="五、停止分裂的条件"></a>五、停止分裂的条件</h3><p>​     （1）最小节点数</p><p>　　当节点的数据量小于一个指定的数量时，不继续分裂。两个原因：一是数据量较少时，再做分裂容易强化噪声数据的作用；二是降低树生长的复杂性。提前结束分裂一定程度上有利于降低过拟合的影响。</p><p>　　（2）熵或者基尼值小于阀值。</p><p>​     由上述可知，熵和基尼值的大小表示数据的复杂程度，当熵或者基尼值过小时，表示数据的纯度比较大，如果熵或者基尼值小于一定程度时，节点停止分裂。</p><p>　　（3）决策树的深度达到指定的条件</p><p>　  节点的深度可以理解为节点与决策树跟节点的距离，如根节点的子节点的深度为1，因为这些节点与跟节点的距离为1，子节点的深度要比父节点的深度大1。决策树的深度是所有叶子节点的最大深度，当深度到达指定的上限大小时，停止分裂。</p><p>　　（4）所有特征已经使用完毕，不能继续进行分裂。</p><p>​     被动式停止分裂的条件，当已经没有可分的属性时，直接将当前节点设置为叶子节点。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动搭建Shadowsocks完整版</title>
      <link href="/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAShadowsocks%E5%AE%8C%E6%95%B4%E7%89%88.html"/>
      <url>/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAShadowsocks%E5%AE%8C%E6%95%B4%E7%89%88.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、-Vultr购买VPS"><a href="#一、-Vultr购买VPS" class="headerlink" title="一、 Vultr购买VPS"></a>一、 Vultr购买VPS</h3><p><img src="https://s2.ax1x.com/2020/02/11/1TdHaD.png" alt=""></p><span id="more"></span><p><img src="https://s2.ax1x.com/2020/02/11/1TdbIe.png" alt=""></p><p><img src="https://s2.ax1x.com/2020/02/11/1Td7VO.png" alt=""></p><p><strong>最后选择价格就ok~</strong>，然后就会变成下面这样：</p><p><img src="https://s2.ax1x.com/2020/02/11/1Tw6yt.png" alt=""></p><p><strong>点击国旗旁的蓝色图标可以查看服务器的具体信息：</strong></p><p><img src="https://s2.ax1x.com/2020/02/11/1TwcOP.png" alt=""></p><h3 id="二、手动搭建Shadowsocks"><a href="#二、手动搭建Shadowsocks" class="headerlink" title="二、手动搭建Shadowsocks"></a>二、手动搭建Shadowsocks</h3><h4 id="1-通过Putty-Xshell连接服务器"><a href="#1-通过Putty-Xshell连接服务器" class="headerlink" title="1. 通过Putty/Xshell连接服务器"></a>1. 通过Putty/Xshell连接服务器</h4><p><strong>输入服务器IP地址：</strong></p><p><img src="https://s2.ax1x.com/2020/02/11/1T0tpj.png" alt=""></p><p><strong>输入用户名密码：</strong></p><p><img src="https://s2.ax1x.com/2020/02/11/1T0JhQ.png" alt=""></p><p><strong>之后成功进入后依次输入如下命令：</strong></p><p><strong>通过安装锐速脚本进行加速</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N — no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh </span><br></pre></td></tr></table></figure><p><strong>下载Shadowsocks</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget — no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure><p><strong>更改权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 shadowsocks.sh</span><br></pre></td></tr></table></figure><p><strong>安装Shadowsocks</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p><strong>之后它会让你依次输入连接密码，端口和加密方式。依次输入就可以， 加密方式选择</strong> <strong>7（AES-256-CFB）</strong>。安装完之后就会出现一块红色的区域，那就是连接时使用的类似账号密码的东西，这样就ok啦~</p><h3 id="三、多用户使用"><a href="#三、多用户使用" class="headerlink" title="三、多用户使用"></a>三、多用户使用</h3><p>有时候需要多个人使用一台服务器，因此我们需要增加端口：</p><p><strong>检测CentOS7是否安装vim，之后要用，没有的话直接安装：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y vim</span><br></pre></td></tr></table></figure><p><strong>修改Shadowsocks文件，修改成如下形式（”端口”:”密码”）:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;9000&quot;:&quot;12345&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;12345&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;12345&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;12345&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;12345&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打开防火墙，开放对应端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/firewalld/zones/public.xml </span><br></pre></td></tr></table></figure><p><strong>重启Shadowsocks</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure><p><strong>重启防火墙</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service firewalld restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见指令汇总(长期更新)</title>
      <link href="/Linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0.html"/>
      <url>/Linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux指令格式"><a href="#Linux指令格式" class="headerlink" title="Linux指令格式"></a>Linux指令格式</h3><p><img src="https://s2.ax1x.com/2019/10/07/uRK2Ax.png" alt=""></p><span id="more"></span><h3 id="一、语系设置"><a href="#一、语系设置" class="headerlink" title="一、语系设置"></a>一、语系设置</h3><h4 id="1-1-显示目前所支持的语系"><a href="#1-1-显示目前所支持的语系" class="headerlink" title="1.1 显示目前所支持的语系"></a>1.1 显示目前所支持的语系</h4><blockquote><p>locale</p></blockquote><h4 id="1-2-修改语系"><a href="#1-2-修改语系" class="headerlink" title="1.2 修改语系"></a>1.2 修改语系</h4><blockquote><p>LANG=en_US.utf8</p><p>export LC_ALL=en_US.utf8</p></blockquote><p>注：LANG只与输出讯息有关，若需要更改其他不同的信息，要同步更新 LC_ALL</p><h3 id="二、基础指令的操作"><a href="#二、基础指令的操作" class="headerlink" title="二、基础指令的操作"></a>二、基础指令的操作</h3><h4 id="2-1-显示日期的指令"><a href="#2-1-显示日期的指令" class="headerlink" title="2.1 显示日期的指令"></a>2.1 显示日期的指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRKrjJ.png" alt=""></p><h4 id="2-2-显示日历的指令"><a href="#2-2-显示日历的指令" class="headerlink" title="2.2 显示日历的指令"></a>2.2 显示日历的指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRKDc4.png" alt=""></p><h4 id="2-3-计算器"><a href="#2-3-计算器" class="headerlink" title="2.3 计算器"></a>2.3 计算器</h4><blockquote><p>$ bc</p></blockquote><p><strong>小数位设置：</strong></p><blockquote><p>scale=3</p></blockquote><h4 id="2-4-指令用法详解"><a href="#2-4-指令用法详解" class="headerlink" title="2.4 指令用法详解"></a>2.4 指令用法详解</h4><blockquote><p>$ command <strong>—help</strong></p><p>$ <strong>man</strong> command</p><p>$ <strong>info</strong> command</p></blockquote><h4 id="2-5-关机-重启"><a href="#2-5-关机-重启" class="headerlink" title="2.5 关机/重启"></a>2.5 关机/重启</h4><h5 id="2-5-1-关机命令"><a href="#2-5-1-关机命令" class="headerlink" title="2.5.1 关机命令"></a>2.5.1 关机命令</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRK6BR.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRKyu9.png" alt=""></p><h5 id="2-5-2-重启命令"><a href="#2-5-2-重启命令" class="headerlink" title="2.5.2 重启命令"></a>2.5.2 重启命令</h5><blockquote><p>$ reboot</p></blockquote><h3 id="三、Linux文件概念"><a href="#三、Linux文件概念" class="headerlink" title="三、Linux文件概念"></a>三、Linux文件概念</h3><h4 id="3-1-linux文件属性"><a href="#3-1-linux文件属性" class="headerlink" title="3.1 linux文件属性"></a>3.1 linux文件属性</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRKcH1.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRKW4K.png" alt=""></p><h4 id="3-2-改变文件属性与权限"><a href="#3-2-改变文件属性与权限" class="headerlink" title="3.2 改变文件属性与权限"></a>3.2 改变文件属性与权限</h4><h5 id="3-2-1-改变所属群组-chgrp"><a href="#3-2-1-改变所属群组-chgrp" class="headerlink" title="3.2.1 改变所属群组 chgrp"></a>3.2.1 改变所属群组 <code>chgrp</code></h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKRN6.png" alt=""></p><h5 id="3-2-2-改变文件拥有者-chown"><a href="#3-2-2-改变文件拥有者-chown" class="headerlink" title="3.2.2 改变文件拥有者 chown"></a>3.2.2 改变文件拥有者 <code>chown</code></h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKh9O.png" alt=""></p><h5 id="3-2-3-改变权限-chmod"><a href="#3-2-3-改变权限-chmod" class="headerlink" title="3.2.3 改变权限 chmod"></a>3.2.3 改变权限 <code>chmod</code></h5><h6 id="3-2-3-1-数字类型改变文件权限"><a href="#3-2-3-1-数字类型改变文件权限" class="headerlink" title="3.2.3.1 数字类型改变文件权限"></a>3.2.3.1 数字类型改变文件权限</h6><p><img src="https://s2.ax1x.com/2019/10/07/uRK43D.png" alt=""></p><h6 id="3-2-3-2符号类型改变文件权限"><a href="#3-2-3-2符号类型改变文件权限" class="headerlink" title="3.2.3.2符号类型改变文件权限"></a>3.2.3.2符号类型改变文件权限</h6><p><img src="https://s2.ax1x.com/2019/10/07/uRK5ge.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRKIjH.png" alt=""></p><p><strong>不知道原先的文件属性，增加文件每个人均可写入的权限：</strong></p><p><img src="https://s2.ax1x.com/2019/10/07/uRKTud.png" alt=""></p><p><strong>拿掉全部人的可执行权限：</strong></p><p><img src="https://s2.ax1x.com/2019/10/07/uRK7DA.png" alt=""></p><h3 id="四、Linux文件与目录相关指令"><a href="#四、Linux文件与目录相关指令" class="headerlink" title="四、Linux文件与目录相关指令"></a>四、Linux文件与目录相关指令</h3><h4 id="4-1-文件与目录管理"><a href="#4-1-文件与目录管理" class="headerlink" title="4.1 文件与目录管理"></a>4.1 文件与目录管理</h4><h5 id="4-11-比较特殊的目录"><a href="#4-11-比较特殊的目录" class="headerlink" title="4.11 比较特殊的目录"></a>4.11 比较特殊的目录</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKHHI.png" alt=""></p><h5 id="4-12-cd-change-directory"><a href="#4-12-cd-change-directory" class="headerlink" title="4.12  cd (change directory)"></a>4.12  <code>cd</code> (change directory)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKqEt.png" alt=""></p><h5 id="4-13-pwd-print-working-directory"><a href="#4-13-pwd-print-working-directory" class="headerlink" title="4.13 pwd (print working directory)"></a>4.13 <code>pwd</code> (print working directory)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKLUP.png" alt=""></p><h5 id="4-14-mkdir"><a href="#4-14-mkdir" class="headerlink" title="4.14 mkdir"></a>4.14 <code>mkdir</code></h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKO4f.png" alt=""></p><h5 id="4-15-rmdir"><a href="#4-15-rmdir" class="headerlink" title="4.15 rmdir"></a>4.15 <code>rmdir</code></h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKjC8.png" alt=""></p><h5 id="4-16-ls-文件与目录的检视"><a href="#4-16-ls-文件与目录的检视" class="headerlink" title="4.16 ls 文件与目录的检视"></a>4.16 <code>ls</code> 文件与目录的检视</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKv8S.png" alt=""></p><h5 id="4-17-cp-文件复制"><a href="#4-17-cp-文件复制" class="headerlink" title="4.17 cp 文件复制"></a>4.17 <code>cp</code> 文件复制</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKxgg.png" alt=""></p><h5 id="4-18-rm-移除文件或目录"><a href="#4-18-rm-移除文件或目录" class="headerlink" title="4.18 rm 移除文件或目录"></a>4.18 <code>rm</code> 移除文件或目录</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRKzvQ.png" alt=""></p><h5 id="4-19-mv-移动文件或更名"><a href="#4-19-mv-移动文件或更名" class="headerlink" title="4.19 mv 移动文件或更名"></a>4.19 <code>mv</code> 移动文件或更名</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMpuj.png" alt=""></p><p><strong>取得路径的文件名与目录名称：</strong></p><p><img src="https://s2.ax1x.com/2019/10/07/uRM9Ds.png" alt=""></p><h4 id="4-2-文件内容查阅"><a href="#4-2-文件内容查阅" class="headerlink" title="4.2 文件内容查阅"></a>4.2 文件内容查阅</h4><h5 id="4-2-1-cat-concatenate"><a href="#4-2-1-cat-concatenate" class="headerlink" title="4.2.1 cat (concatenate)"></a>4.2.1 <code>cat</code> (concatenate)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMCbn.png" alt=""></p><h5 id="4-2-2-more-可向下一页页翻动"><a href="#4-2-2-more-可向下一页页翻动" class="headerlink" title="4.2.2 more (可向下一页页翻动)"></a>4.2.2 <code>more</code> (可向下一页页翻动)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMiEq.png" alt=""></p><h5 id="4-2-3-less-可向上下一页页翻动"><a href="#4-2-3-less-可向上下一页页翻动" class="headerlink" title="4.2.3 less (可向上下一页页翻动)"></a>4.2.3 <code>less</code> (可向上下一页页翻动)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMFU0.png" alt=""></p><h4 id="4-3-资料撷取"><a href="#4-3-资料撷取" class="headerlink" title="4.3 资料撷取"></a>4.3 资料撷取</h4><h5 id="4-3-1-head-取出前面几行"><a href="#4-3-1-head-取出前面几行" class="headerlink" title="4.3.1 head (取出前面几行)"></a>4.3.1 <code>head</code> (取出前面几行)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMk5V.png" alt=""></p><h5 id="4-3-2-tail-取出后面几行"><a href="#4-3-2-tail-取出后面几行" class="headerlink" title="4.3.2 tail (取出后面几行)"></a>4.3.2 <code>tail</code> (取出后面几行)</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMECT.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRMV8U.png" alt=""></p><h4 id="4-4-指令与文件的搜寻"><a href="#4-4-指令与文件的搜寻" class="headerlink" title="4.4 指令与文件的搜寻"></a>4.4 指令与文件的搜寻</h4><h5 id="4-4-1-which-（寻找【执行档】）"><a href="#4-4-1-which-（寻找【执行档】）" class="headerlink" title="4.4.1 which （寻找【执行档】）"></a>4.4.1 <code>which</code> （寻找【执行档】）</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMZ2F.png" alt=""></p><h5 id="4-4-2-whereis-（由一些特定的目录中寻找文件文件名）"><a href="#4-4-2-whereis-（由一些特定的目录中寻找文件文件名）" class="headerlink" title="4.4.2 whereis （由一些特定的目录中寻找文件文件名）"></a>4.4.2 <code>whereis</code> （由一些特定的目录中寻找文件文件名）</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMev4.png" alt=""></p><h5 id="4-4-3-find-（较全的文件位置查找）"><a href="#4-4-3-find-（较全的文件位置查找）" class="headerlink" title="4.4.3 find （较全的文件位置查找）"></a>4.4.3 <code>find</code> （较全的文件位置查找）</h5><p><img src="https://s2.ax1x.com/2019/10/07/uRMnKJ.png" alt=""></p><h3 id="五、压缩与解压缩"><a href="#五、压缩与解压缩" class="headerlink" title="五、压缩与解压缩"></a>五、压缩与解压缩</h3><h4 id="5-1-linux常见压缩文件扩展名"><a href="#5-1-linux常见压缩文件扩展名" class="headerlink" title="5.1 linux常见压缩文件扩展名"></a>5.1 linux常见压缩文件扩展名</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRMur9.png" alt=""></p><h4 id="5-2-gzip-指令"><a href="#5-2-gzip-指令" class="headerlink" title="5.2 gzip 指令"></a>5.2 <code>gzip</code> 指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRMKbR.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRMQV1.png" alt=""></p><h4 id="5-3-bzip2-指令"><a href="#5-3-bzip2-指令" class="headerlink" title="5.3 bzip2 指令"></a>5.3 <code>bzip2</code> 指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRMlUx.png" alt=""></p><h4 id="5-4-xz-指令"><a href="#5-4-xz-指令" class="headerlink" title="5.4 xz 指令"></a>5.4 <code>xz</code> 指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRM156.png" alt=""></p><h4 id="5-5-tar-打包指令"><a href="#5-5-tar-打包指令" class="headerlink" title="5.5 tar 打包指令"></a>5.5 <code>tar</code> 打包指令</h4><p><img src="https://s2.ax1x.com/2019/10/07/uRM8PK.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/10/07/uRMG8O.png" alt=""></p><p><strong>（注：压缩指令默认情况会删除源文件，而打包指令不会）</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化算法(三):粒子群算法</title>
      <link href="/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95.html"/>
      <url>/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%B8%89-%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>粒子群算法源于复杂适应系统（Complex Adaptive System, CAS）。CAS理论于1994年正式提出，CAS中的成员称为主体。比如研究鸟群系统，每个鸟在这个系统中就称为主体。主体有适应性，它能够与环境及其他的主体进行交流，并且根据交流的过程“学习”或“积累经验”改变自身结构与行为。整个系统的演变或进化包括：新层次的产生（小鸟的出生）；分化和多样性的出现（鸟群中的鸟分成许多小的群）；新的主题的出现（鸟寻找食物过程中，不断发现新的食物）。</p><p>所以CAS系统中的主体具有4个基本特点（这些特点是粒子群算法发展变化的依据）：</p><ul><li>首先，主体是主动的、活动的。</li><li>主体与环境及其他主体是相互影响、相互作用的，这种影响是系统发展变化的主要动力。</li><li>环境的影响是宏观的，主体之间的影响是微观的，宏观与微观要有机结合。</li><li>最后，整个系统可能还要受一些随机因素的影响。</li></ul><p>粒子群算法就是对一个CAS系统－－－鸟群社会系统的研究得出的。<br><span id="more"></span></p><h3 id="一、粒子群算法"><a href="#一、粒子群算法" class="headerlink" title="一、粒子群算法"></a>一、粒子群算法</h3><p>  粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，<strong>粒子仅具有两个属性：速度和位置</strong>，速度代表移动的快慢，位置代表移动的方向。每个粒子在<strong>搜索空间</strong>中单独的搜寻最优解，并将其记为<strong>当前个体极值</strong>，并将个体极值与整个粒子群里的其他粒子共享，<strong>找到最优的那个个体极值作为整个粒子群的当前全局最优解</strong>，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来<strong>调整自己的速度和位置</strong>。粒子群算法的思想相对比较简单，主要分为：</p><ul><li>(a) 初始化粒子群；</li><li>(b) 评价粒子，即计算适应值；</li><li>(c) 更新个体极值；</li><li>(d) 更新全局最优解；</li><li>(e) 更新粒子的速度和位置并迭代(b)~(e)。</li></ul><p>（1）初始化<br>   首先，我们需要设置最大的速度区间，防止超出最大的区间。位置信息即为整个搜索空间，我们在速度区间和搜索空间上随机初始化速度和位置，设置群体规模。</p><p>（2）个体极值与全局最优解<br>   个体极值为每个粒子找到的历史上最优的位置信息，并从这些个体历史最优解中找到一个全局最优解，<strong>并与历史最优解比较，选出最佳的作为当前的历史最优解</strong>。</p><p>（3）更新速度和位置的公式</p><script type="math/tex; mode=display">V_{id}^{n+1} = \omega V_{id}^{n} + C_1rand_1(P_{id}-X_{id}^n)+C_2rand_2(P_{gd}-X_{id}^n))</script><script type="math/tex; mode=display">X_{id}^{n+1} = X_{id}^n + rV_{id}^{n+1}</script><ul><li>$\omega$ 是保持原来速度的系数，所以叫做惯性权重；</li><li>$C_1$ 是粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，称为“自身认知”，通常设置为2；</li><li>$C_2$ 是粒子跟踪群体最优值的权重系数，它表示粒子对整个群体知识的认识，所以叫做“社会知识”，通常设置为2；</li><li>$rand1$ 、$rand2$ 是 区间 $[0,1]$ 上的随机浮点数；</li><li>$r$ 是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做”约束因子“。通常设置为1；</li><li>$P_{id}$ 是粒子个体历史上最优值对应的位置信息；$P_{gd}$ 是粒子群中最优值对应的位置信息；</li></ul><p>（4）终止条件<br>  有两种终止条件可以选择，一是设置最大迭代次数；二是相邻两代之间的偏差在一个指定的范围内。</p><p><strong>（注：位置信息可能是多维度的，比如 $O-xy$ 位置就是一维； $O-xyz$ 位置就是二维…）</strong>  </p><h3 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h3><p><strong>研究函数 $y = xsin(10πx)+1$ 在区间 $[-1,1]$ 上的最值问题。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, position, speed, best_fitness, best_position</span>):</span></span><br><span class="line">        self.position = position               <span class="comment"># 个体当前位置</span></span><br><span class="line">        self.speed = speed                     <span class="comment"># 个体当前速度</span></span><br><span class="line">        self.best_fitness = best_fitness       <span class="comment"># 个体历史最优适应值</span></span><br><span class="line">        self.best_position = best_position     <span class="comment"># 个体历史最优适应值对应的位置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSO</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, min_speed, max_speed, Iternumbers, C1, C2, R, W, particleNum</span>):</span></span><br><span class="line">        self.min_speed = min_speed       <span class="comment"># 系统最小速度</span></span><br><span class="line">        self.max_speed = max_speed       <span class="comment"># 系统最大速度</span></span><br><span class="line">        self.Iternumbers = Iternumbers   <span class="comment"># 系统迭代次数</span></span><br><span class="line">        self.C1 = C1                     <span class="comment"># 自身认知</span></span><br><span class="line">        self.C2 = C2                     <span class="comment"># 社会认知</span></span><br><span class="line">        self.R = R                       <span class="comment"># 约束因子</span></span><br><span class="line">        self.W = W                       <span class="comment"># 惯性因子</span></span><br><span class="line">        self.particleNum = particleNum   <span class="comment"># 粒子个数</span></span><br><span class="line">        self.best_position = <span class="literal">None</span>        <span class="comment"># 系统历史最优适应值</span></span><br><span class="line">        self.best_fitness = -<span class="number">100000</span>      <span class="comment"># 系统历史最优适应值对应的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initial</span>(<span class="params">self</span>):</span>    <span class="comment"># 初始化粒子群</span></span><br><span class="line">        particles = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.particleNum): <span class="comment"># 每轮创建随机粒子</span></span><br><span class="line">            <span class="comment"># 初始化随机位置</span></span><br><span class="line">            rand_position = np.random.rand() * (self.max_speed-self.min_speed) + self.min_speed</span><br><span class="line">            <span class="comment"># 初始化随即速度</span></span><br><span class="line">            rand_speed = np.random.rand() * (self.max_speed-self.min_speed) + self.min_speed</span><br><span class="line">            <span class="comment"># 计算适应值</span></span><br><span class="line">            fitness = self.compute_fitness(rand_position)</span><br><span class="line">            <span class="comment"># 更新系统历史最优适应值和位置</span></span><br><span class="line">            <span class="keyword">if</span> fitness &gt; self.best_fitness:</span><br><span class="line">                self.best_fitness = fitness</span><br><span class="line">                self.best_position = rand_position</span><br><span class="line">            <span class="comment"># 创建粒子</span></span><br><span class="line">            particle = Particle(rand_position, rand_speed, fitness, rand_position)</span><br><span class="line">            particles.append(particle)</span><br><span class="line">        <span class="keyword">return</span> particles</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_fitness</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * np.sin(<span class="number">10</span>*np.pi*x) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_speed</span>(<span class="params">self, particle</span>):</span></span><br><span class="line">        rand1 = np.random.rand()</span><br><span class="line">        rand2 = np.random.rand()</span><br><span class="line">        V_next = self.W * particle.speed + self.C1 * rand1 * (particle.best_position - particle.position) \</span><br><span class="line">                 + self.C2 * rand2 * (self.best_position - particle.position)</span><br><span class="line">        <span class="keyword">if</span> V_next &gt; self.max_speed:</span><br><span class="line">            V_next = self.max_speed</span><br><span class="line">        <span class="keyword">elif</span> V_next &lt; self.min_speed:</span><br><span class="line">            V_next = self.min_speed</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            V_next = V_next</span><br><span class="line">        <span class="keyword">return</span> V_next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_position</span>(<span class="params">self, particle, V_next</span>):</span></span><br><span class="line">        X_next = particle.position + self.R * V_next</span><br><span class="line">        <span class="keyword">if</span> X_next &gt; self.max_speed:</span><br><span class="line">            X_next = self.max_speed</span><br><span class="line">        <span class="keyword">elif</span> X_next &lt; self.min_speed:</span><br><span class="line">            X_next = self.min_speed</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_next = X_next</span><br><span class="line">        <span class="keyword">return</span> X_next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, particles</span>):</span></span><br><span class="line">        temp_fitness = <span class="number">0</span>     <span class="comment"># 记录当前更新的最优适应值及位置</span></span><br><span class="line">        temp_position = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> particle <span class="keyword">in</span> particles: <span class="comment"># 遍历每个粒子</span></span><br><span class="line">            V_next = self.update_speed(particle)</span><br><span class="line">            X_next = self.update_position(particle,V_next)</span><br><span class="line">            particle.position = X_next   <span class="comment"># 更新粒子的位置及速度</span></span><br><span class="line">            particle.speed = V_next</span><br><span class="line">            fitness = self.compute_fitness(X_next)</span><br><span class="line">            <span class="keyword">if</span> fitness &gt; particle.best_fitness:  <span class="comment"># 如果适应值大于个体历史适应值，进行更新</span></span><br><span class="line">                particle.best_fitness = fitness</span><br><span class="line">                particle.best_position = X_next</span><br><span class="line">                <span class="keyword">if</span> fitness &gt; self.best_fitness:  <span class="comment"># 如果大于系统历史适应值，保留当前值</span></span><br><span class="line">                    temp_fitness = fitness</span><br><span class="line">                    temp_position = X_next</span><br><span class="line">        <span class="keyword">if</span> temp_fitness &gt; self.best_fitness:  <span class="comment"># 更新</span></span><br><span class="line">            self.best_fitness = temp_fitness</span><br><span class="line">            self.best_position = temp_position</span><br><span class="line">        <span class="keyword">return</span> particles</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot</span>(<span class="params">self, particles</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(particles)):</span><br><span class="line">            position = particles[i].position</span><br><span class="line">            fitness = self.compute_fitness(position)</span><br><span class="line">            plt.vlines(position,<span class="number">0</span>,fitness,colors=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            plt.scatter(position,fitness, c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self</span>):</span></span><br><span class="line">        particles = self.initial()        <span class="comment"># 初始化粒子群</span></span><br><span class="line">        self.plot(particles)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.Iternumbers): <span class="comment"># 迭代更新</span></span><br><span class="line">            particles = self.update(particles)</span><br><span class="line">            self.plot(particles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pso = PSO(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    X = np.arange(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0.01</span>)</span><br><span class="line">    Y = pso.compute_fitness(X)</span><br><span class="line">    plt.plot(X, Y, linewidth = <span class="number">2</span>)</span><br><span class="line">    pso.solve()</span><br><span class="line"></span><br><span class="line">    plt.grid()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>粒子群迭代图如下：</strong></p><center><img src="https://s2.ax1x.com/2019/09/07/n1gzKs.png" /></center>]]></content>
      
      
      <categories>
          
          <category> 优化算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习日记(四):奇异值分解</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%9B%9B-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%9B%9B-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在学习奇异值分解前，请<strong>务必</strong>看一下以下对于奇异值的直观理解：<a href="https://www.zhihu.com/question/22237507/answer/53804902">奇异值的物理意义是什么？</a></p><p>奇异值分解是一种矩阵因子分解方法，任意一个 $m×n$ 矩阵，都可以表示为三个矩阵的乘积(因子分解)形式，分别是 $m$ 阶正交矩阵、由降序排列的非负的对角线元素组成的 $m×n$ 矩阵对角矩阵和 $n$ 阶正交矩阵，称为该矩阵的奇异值分解。矩阵的奇异值分解一定存在，但不唯一。奇异值分解可以看作是矩阵数据压缩的一种方法，即用因子分解的方式近似地表示原始矩阵，这种近似是在平方损失意义下的最有近似。</p><span id="more"></span><h3 id="一、定理与定义"><a href="#一、定理与定义" class="headerlink" title="一、定理与定义"></a>一、定理与定义</h3><p><strong>定义1&nbsp;  (奇异值分解)</strong>  矩阵的奇异值分解是指，将一个非零的 $m×n$ 实矩阵 $A$, $A\in R^{m×n}$，表示为以下三个实矩阵乘积形式的运算，即进行矩阵因子分解：</p><script type="math/tex; mode=display">A=U\sum V^T</script><p>其中 $U$ 是 $m$ 阶正交矩阵，$V$ 是 $n$ 阶正交矩阵，$\sum$ 是由降序排列的非负的对角线元素组成的 $m×n$ 矩阵对角矩阵，</p><script type="math/tex; mode=display">UU^T=I</script><script type="math/tex; mode=display">VV^T=I</script><script type="math/tex; mode=display">\sum = diag(\sigma_1,\sigma_2,\cdots,\sigma_p)</script><script type="math/tex; mode=display">\sigma_1\geq \sigma_2 \geq \cdots \geq \sigma_p \geq 0</script><script type="math/tex; mode=display">p=min(m,n)</script><p>$U\sum V^T$ 称为矩阵 $A$ 的奇异值分解， $\sigma_i$ 称为矩阵 $A$ 的奇异值， $U$ 的列向量称为左奇异向量，$V$ 的列向量称为右奇异向量。</p><p><strong>那么任意给定一个实矩阵，其奇异值分解是否一定存在呢？答案是肯定的，下面的奇异值分解的基本定理给予保证。</strong></p><hr><p><strong>定理1&nbsp; (奇异值分解基本定理)</strong> 若 $A$ 为一 $m×n$ 实矩阵，$A\in R^{m×n}$，则 $A$ 的奇异值分解存在</p><script type="math/tex; mode=display">A=U\sum V^T</script><p><strong>证明：</strong>证明是构造性的，对给定的矩阵 $A$，构造出其奇异值分解的各个矩阵。为了方便，不放假设 $m\geq n$，如果 $m&lt;n$ 证明仍然成立。证明由三步完成。</p><p>(1) 确定 $V$ 和 $\sum$</p><p>首先构造 $n$ 阶正交实矩阵 $V$ 和 $m×n$ 矩阵对角实矩阵 $\sum$。</p><p>矩阵 $A$ 是 $m×n$ 实矩阵，则矩阵 $A^TA$ 是 $n$ 阶实对称矩阵。因而 $A^TA$ 的特征值都是实数，并且存在一个 $n$ 阶正交实矩阵 $V$ 实现 $A^TA$ 的对角化，使得 $V^T(A^TA)V= \Lambda$ 成立，其中 $\Lambda$ 是 $n$ 阶对角矩阵，其对角线元素由 $A^TA$ 的特征值组成。</p><p>而且，$A^TA$ 的特征值都是非负的。事实上，令 $\lambda$ 是 $A^TA$ 的一个特征值，$x$ 是对应的特征向量，则</p><script type="math/tex; mode=display">||Ax||^2=x^TA^TAx=\lambda x^Tx=\lambda ||x||^2</script><p>于是</p><script type="math/tex; mode=display">\lambda=\frac{||Ax||^2}{||x||^2}\geq0</script><p>可以假设正交矩阵 $V$ 的列的排列使得对应的特征值形成降序排列</p><script type="math/tex; mode=display">\lambda_1\geq \lambda_2\geq \cdots \geq \lambda_n \geq 0</script><p>计算特征值的平方根（实际就是矩阵 $A$ 的奇异值）</p><script type="math/tex; mode=display">\sigma_j=\sqrt{\lambda_j}，j=1,2,\cdots,n</script><p>设矩阵 $A$ 的秩是 $r$ , $rank(A) = r$，则矩阵 $A^TA$ 的秩也是 $r$。由于 $A^TA$ 是对称矩阵，它的秩等于正的特征值的个数，所以</p><script type="math/tex; mode=display">\lambda_1 \geq \lambda_2 \geq \cdots \lambda_r >0，\lambda_{r+1}=\lambda_{r+2}=\cdots=\lambda_n=0</script><p>对应的有</p><script type="math/tex; mode=display">\sigma_1 \geq \sigma_2 \geq \cdots \sigma_r >0，\sigma_{r+1}=\sigma_{r+2}=\cdots=\sigma_n=0</script><p>令</p><script type="math/tex; mode=display">V_1 = [v_1\quad v_2\quad \cdots\quad v_r]，V_2=[v_{r+1}\quad v_{r+2}\quad \cdots\quad v_n]</script><p>其中 $v_1,\cdots,v_r$ 为 $A^TA$ 的正特征值对应的特征向量，$v_{r+1},\cdots,v_n$ 为 $0$ 特征值对应的特征向量，则</p><script type="math/tex; mode=display">V = [V_1\quad V_2]</script><p>这就是矩阵 $A$ 的奇异值分解中的 $n$ 阶正交矩阵 $V$。</p><p>令</p><script type="math/tex; mode=display">\sum_1=\left[\begin{matrix}\sigma_1 &\quad & \quad &\quad \\ \quad & \sigma_2 &\quad & \quad \\ \quad& \quad & \cdots & \quad \\ \quad & \quad & \quad & \sigma_r \end{matrix}\right]</script><p>则 $\sum_1$ 是一个 $r$ 阶对角矩阵，其对角线元素为按降序排列的正的 $\sigma_1,\cdots,\sigma_r$，于是 $m×n$ 矩阵对角矩阵 $\sum$ 可以表示为</p><script type="math/tex; mode=display">\sum = \left[\begin{matrix} \sum_1 & 0 \\ 0 & 0\end{matrix}\right]</script><p>这就是矩阵 $A$ 的奇异值分解中的 $m×n$ 矩阵对角矩阵 $\sum$。</p><p>下面推出后面要用到的一个公式。 $V_2$ 的列向量是 $A^TA$ 对应于特征值为 $0$ 的特征向量。因此</p><script type="math/tex; mode=display">A^TAv_j=0，j=r+1,\cdots,n</script><p>于是， $V_2$ 的列向量构成了 $A^TA$ 的零空间 $N(A^TA)$，而 $N(A^TA)=N(A)$。所以 $V_2$ 的列向量构成 $A$ 的零空间的一组标准正交基。因此</p><script type="math/tex; mode=display">AV_2=0</script><p>由于 $V$ 是正交矩阵，所以</p><script type="math/tex; mode=display">I=VV^T=V_1V_1^T+V_2V_2^T</script><script type="math/tex; mode=display">A =AI=AV_1V_1^T+AV_2V_2^T=AV_1V_1^T</script><p>(2) 确定 $U$</p><p>接着构造 $m$ 阶正交实矩阵 $U$。</p><p>令</p><script type="math/tex; mode=display">u_j=\frac{1}{\sigma_j}Av_j，j=1,2,\cdots,r</script><script type="math/tex; mode=display">U_1=[u_1\quad u_2 \quad \cdots \quad u_r]</script><p>则有</p><script type="math/tex; mode=display">AV_1=U_1 \sum_{1}</script><p>$U_1$ 的列向量构成了一组标准正交基。</p><p>若 $R(A)^\bot$ 表示 $R(A)$ 的正交补，则有 $R(A)$ 的维数为 $r$， $R(A)^\bot$ 的维数为 $m-r$，两者的维数之和等于 $m$。而且有 $R(A)^\bot =N(A^T)$ 成立。</p><p>令 $\{u_{r+1},u_{r+2},\cdots,u_m\}$ 为 $N(A^T)$ 的一组标准正交基，并令</p><script type="math/tex; mode=display">U_2 = [u_{r+1}\quad u_{r+2} \quad \cdots \quad u_m]</script><script type="math/tex; mode=display">U = [U_1\quad U_2]</script><p>则 $u_1,u_2,\cdots,u_m$ 构成了 $R^m$ 的一组标准正交基。因此，$U$ 是 $m$ 阶正交矩阵，这就是矩阵 $A$ 的奇异值分解中的 $m$ 阶正交矩阵。</p><p>(3) 证明 $U\sum V^T=A$</p><script type="math/tex; mode=display">U\sum V^T= [U_1\quad U_2]\left[\begin{matrix} \sum_1 & 0 \\ 0 & 0\end{matrix}\right]\left[\begin{matrix}V_1^T \\ V_2^T \end{matrix}\right]</script><script type="math/tex; mode=display">=U_1 \sum_{1} V_1^T</script><script type="math/tex; mode=display">=AV_1V_1^T</script><script type="math/tex; mode=display">=A</script><p>至此证明了矩阵 $A$ 存在奇异值分解。</p><h3 id="二、紧奇异值分解与截断奇异值分解"><a href="#二、紧奇异值分解与截断奇异值分解" class="headerlink" title="二、紧奇异值分解与截断奇异值分解"></a>二、紧奇异值分解与截断奇异值分解</h3><p>定理1给出的奇异值分解</p><script type="math/tex; mode=display">A=U\sum V^T</script><p>又称为矩阵的完全奇异值分解。实际常用的是奇异值分解的紧凑形式和截断形式。紧奇异值分解是与原始矩阵等秩的奇异值分解，截断奇异值分解是比原始矩阵低秩的奇异值分解。</p><h4 id="2-1紧奇异值分解"><a href="#2-1紧奇异值分解" class="headerlink" title="2.1紧奇异值分解"></a>2.1紧奇异值分解</h4><p>设有 $m×n$ 实矩阵 $A$，其秩为 $rank(A)=r，r\leq min(m,n)$，则称 $U_r\sum_rV_r^T$ 为 $A$ 的紧奇异值分解，即</p><script type="math/tex; mode=display">A=U_r \sum_{r} V_r^T</script><p>其中 $U_r$ 是 $m×r$ 矩阵，$V_r$ 是 $n×r$ 矩阵，$\sum_r$ 是 $r$ 阶对角矩阵；矩阵 $U_r$ 由完全奇异值分解中 $U$ 的前 $r$ 列、矩阵 $V_r$ 由 $V$ 的前 $r$ 列、矩阵 $\sum_r$ 由 $\sum$ 的前 $r$ 个对角线元素得到。紧奇异值分解的对角矩阵 $\sum_r$ 的秩与原始矩阵 $A$ 的秩相等。</p><h4 id="2-2-截断奇异值分解"><a href="#2-2-截断奇异值分解" class="headerlink" title="2.2 截断奇异值分解"></a>2.2 截断奇异值分解</h4><p>在矩阵的奇异值分解中，只取最大的 $k$ 个奇异值 $(k&lt;r)$ 对应的部分，就得到矩阵的截断奇异值分解。实际应用中提到的矩阵的奇异值分解时，通常指截断奇异值分解。</p><p>设 $A$ 为 $m×n$ 实矩阵，其秩 $rank(A)=r$，且 $0&lt;k&lt;r$，则称 $U_k\sum_kV_k^T$ 为矩阵 $A$ 的截断奇异值分解</p><script type="math/tex; mode=display">A \approx U_k \sum_{k} V_k^T</script><p>其中 $U_k$ 是 $m×$k 矩阵，$V_k$ 是 $n×k$ 矩阵，$\sum_k$ 是 $k$ 阶对角矩阵；矩阵 $U_k$ 由完全奇异值分解中 $U$ 的前 $k$ 列、矩阵 $V_k$ 由 $V$ 的前 $k$ 列、矩阵 $\sum_k$ 由 $\sum$ 的前 $k$ 个对角线元素得到。对角矩阵 $\sum_k$ 的秩比原始矩阵 $A$ 的秩低。</p><p>在实际应用中，常常需要对矩阵的数据进行压缩，将其近似表示，奇异值分解提供了一种方法。紧奇异值分解对应着无损压缩，截断奇异值分解对应着有损压缩。</p><h3 id="三、几何解释"><a href="#三、几何解释" class="headerlink" title="三、几何解释"></a>三、几何解释</h3><p>从线性变换的角度理解奇异值分解，$m×n$ 矩阵 $A$ 表示从 $n$ 维空间 $R^n$ 到 $m$ 维空间 $R^m$ 的一个线性变换，</p><script type="math/tex; mode=display">T:x\rightarrow Ax</script><p>$x\in R^n，Ax\in R^m$，$x$ 和 $Ax$ 分别是各自空间的向量。线性变换可以分解为三个简单的变换：一个坐标系的旋转或发射变换、一个坐标轴的缩放变换、另一个坐标系的旋转或反射变换。奇异值定理保证这种分解一定存在。这就是奇异值分解的几何解释。</p><p>对矩阵 $A$ 进行奇异值分解，得到 $A=U\sum V^T$ ，$V$ 和 $U$ 都是正交矩阵。所以 $V$ 的列向量 $v_1,v_2,\cdots,v_n$ 构成 $R^n$ 空间的一组标准正交基，表示 $R^n$ 中的正交坐标系的旋转或反射变换； $U$ 的列向量 $u_1,u_2,\cdots,u_m$ 构成 $R^m$ 空间的一组标准正交基，表示 $R^m$ 中的正交坐标系的旋转或反射变换； $\sum$ 的对角元素 $\sigma_1,\sigma_2,\cdots,\sigma_n$ 是一组非负实数，表示 $R^n$ 中的原始正交坐标系坐标轴的 $\sigma_1,\sigma_2,\cdots,\sigma_n$ 倍的缩放变换。</p><p>任意一个向量 $x\in R^n$，经过基于 $A=U\sum V^T$ 的线性变换，等价于经过坐标系的旋转或反射变换 $V^    T$，坐标轴的缩放变换 $\sum$，以及坐标系的旋转或反射变换 $U$，得到向量 $Ax\in R^m$。下图给出了直观的几何解释。</p> <center><img src="https://s2.ax1x.com/2019/09/04/nZrhlQ.png" /></center><h3 id="四、主要性质"><a href="#四、主要性质" class="headerlink" title="四、主要性质"></a>四、主要性质</h3><p>(1) 设矩阵 $A$ 的奇异值分解为 $A=U\sum V^T$，则以下关系成立：</p><script type="math/tex; mode=display">A^TA=(U \sum V^T)^T(U \sum V^T)=V(\sum^{T} \sum)V^T</script><script type="math/tex; mode=display">AA^T = (U\sum V^T)(U \sum V^T)^T=U(\sum \sum^{T})U^T</script><p>也就是说，矩阵 $A^TA$ 和 $AA^T$ 的特征分解存在，且可以有矩阵 $A$ 的奇异值分解的矩阵表示。$V$ 的列向量是 $A^TA$ 的特征向量，$U$ 的列向量是 $AA^T$ 的特征向量， $\sum$ 的奇异值是$A^TA$ 和 $AA^T$ 的特征值的平方根。</p><p>(2) 在矩阵 $A$ 的奇异值分解中，奇异值、左奇异向量和右奇异向量之间存在对于关系。</p><p>由 $A=U\sum V^T$ 易知</p><script type="math/tex; mode=display">AV=U\sum</script><p>比较这一等式两端的第 $j$ 列，得到</p><script type="math/tex; mode=display">Av_j=\sigma_ju_j \tag{关系一}</script><p>这是矩阵 $A$ 的右奇异向量和奇异值、左奇异向量的关系。</p><p>类似的，由</p><script type="math/tex; mode=display">A^TU = V \sum^{T}</script><p>得到</p><script type="math/tex; mode=display">A^Tu_j=\sigma_jv_j，j=1,2,\cdots,r \tag{关系二}</script><script type="math/tex; mode=display">A^Tu_j=0，j=r+1,r+2,\cdots,m \tag{关系三}</script><p>这是矩阵 $A$ 的左奇异向量和奇异值、右奇异向量的关系。</p><p>(3) 矩阵 $A$ 的奇异值分解中，奇异值 $\sigma_1,\cdots,\sigma_n$ 是唯一的，而矩阵 $U$ 和 $V$ 不是唯一的。</p><p>(4) 矩阵 $A$ 和 $\sum$  的秩相等，等于正奇异值的个数 $r$。</p><h3 id="五、奇异值分解的计算"><a href="#五、奇异值分解的计算" class="headerlink" title="五、奇异值分解的计算"></a>五、奇异值分解的计算</h3><p>给定 $m×n$ 矩阵 $A$，可以按照上面的叙述写出矩阵奇异值分解的计算过程。</p><p>(1) 首先求 $A^TA$ 的特征值和特征向量。</p><p>计算对称矩阵 $W=A^TA$。</p><p>求解特征方程</p><script type="math/tex; mode=display">(W-\lambda I)x=0</script><p>得到特征值 $\lambda_i(i=1,2,\cdots,n)$，并将特征值由大到小排列</p><script type="math/tex; mode=display">\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_n \geq 0</script><p>将特征值带入特征方程求得对应的特征向量。</p><p>(2) 求 $n$ 阶正交矩阵 $V$ </p><p><strong>将特征向量单位化</strong>， 得到单位特征向量 $v_1,\cdots,v_n$，构成 $n$ 阶正交矩阵 $V$ :</p><script type="math/tex; mode=display">V=[v_1\quad v_2\quad \cdots\quad v_n]</script><p>(3) 求 $m×n$ 对角矩阵 $\sum$ </p><p>计算 $A$ 的奇异值</p><script type="math/tex; mode=display">\sigma_i=\sqrt{\lambda_i}，i=1,2,\cdots,n</script><p>构造 $m×n$ 矩阵对角矩阵 $\sum$，主对角线元素是奇异值，其余元素是 $0$，</p><script type="math/tex; mode=display">\sum = diag(\sigma_1,\sigma_2,\cdots,\sigma_n)</script><p>(4) 求 $m$ 阶正交矩阵 $U$ </p><p>对 $A$ 的前 $r$ 个正奇异值，令</p><script type="math/tex; mode=display">u_j=\frac{1}{\sigma_j}Av_j，j=1,2,\cdots,r</script><p>得到</p><script type="math/tex; mode=display">U_1=[u_1\quad u_2\quad \cdots \quad u_r]</script><p><strong>利用上面所述性质等式</strong>求 $A^T$ 的零空间的一组标准正交基 $\{u_{r+1}，u_{r+2},\cdots,u_m\}$，令</p><script type="math/tex; mode=display">U_2=[u_{r+1}\quad u_{r+2}\quad \cdots \quad u_m]</script><p>并令</p><script type="math/tex; mode=display">U=[U_1\quad U_2]</script><p>(5) 得到奇异值分解</p><script type="math/tex; mode=display">A=U\sum V^T</script><h3 id="六、奇异值分解与矩阵近似"><a href="#六、奇异值分解与矩阵近似" class="headerlink" title="六、奇异值分解与矩阵近似"></a>六、奇异值分解与矩阵近似</h3><h4 id="6-1-弗罗贝尼乌斯范数"><a href="#6-1-弗罗贝尼乌斯范数" class="headerlink" title="6.1 弗罗贝尼乌斯范数"></a>6.1 弗罗贝尼乌斯范数</h4><p>奇异值分解也是一种矩阵近似的方法，这个近似是在弗罗贝尼乌斯范数意义下的近似。矩阵的弗罗贝尼乌斯范数是向量的 $L_2$ 范数的直接推广，对应着机器学习中平方损失函数。</p><p><strong>定义 （弗罗贝尼乌斯范数）</strong> 设矩阵 $A \in R^{m×n}，A=[a_{ij}]_{m×n}$，定义矩阵 $A$ 的弗罗贝尼乌斯为</p><script type="math/tex; mode=display">||A||_F = \left(\mathop{\sum}\limits_{i=1}^{m}\mathop{\sum}\limits_{j=1}^{n}(a_{ij})^2\right)^{1\over2}</script><p><strong>引理</strong>  &nbsp; &nbsp;&nbsp;设矩阵 $A \in R^{m×n}$，$A$ 的奇异值分解为 $U\sum V^T$，其中 $\sum=diag(\sigma_1,\sigma_2,\cdots,\sigma_n)$，则</p><script type="math/tex; mode=display">||A||_F = (\sigma_1^2+\sigma_2^2+\cdots+\sigma_n^2)^{1\over 2}</script><h4 id="6-2-矩阵的最优近似"><a href="#6-2-矩阵的最优近似" class="headerlink" title="6.2 矩阵的最优近似"></a>6.2 矩阵的最优近似</h4><p><strong>奇异值分解是在平方损失(弗罗贝尼乌斯范数)意义下对矩阵的最优近似，即数据压缩。</strong></p><p><strong>定理1&nbsp;&nbsp;&nbsp;</strong>&nbsp; &nbsp;&nbsp;设矩阵 $A\in R^{m×n}$，矩阵得秩 $rank(A)=r$，并设 $M$ 为 $R^{m×n}$ 中所有秩不超过 $k$ 的矩阵集合， $0&lt;k&lt;r$，则存在一个秩为 $k$ 的矩阵 $X \in M$，使得</p><script type="math/tex; mode=display">||A-X||_F=\mathop{min}\limits_{S\in M} ||A-S||_F</script><p><strong>称矩阵 $X$ 为矩阵 $A$ 在弗罗贝尼乌斯范数意义下的最优近似。</strong></p><p><strong>定理2&nbsp;&nbsp;&nbsp;</strong>&nbsp; 设矩阵 $A\in R^{m×n}$，矩阵得秩 $rank(A)=r$，有奇异值分解$A=U\sum V^T$，并设 $M$ 为 $R^{m×n}$ 中所有秩不超过 $k$ 的矩阵的集合，$0&lt;k&lt;r$，若秩为 $k$ 的矩阵 $X \in M$ 满足</p><script type="math/tex; mode=display">||A-X||_F=\mathop{min}\limits_{S\in M} ||A-S||_F</script><p>则</p><script type="math/tex; mode=display">||A-X||_F=(\sigma_{k+1}^2+\sigma_{k+2}^2+\cdots+\sigma_{n}^2)^{1\over2}</script><p><strong>特别的</strong>，若 $A^{‘}=U\sum^{‘}V^T$，其中</p><script type="math/tex; mode=display">\sum^{'}=\left[\begin{matrix} \sigma_1 & \quad& \quad& \quad& \quad& \quad \\  \quad & \ddots & \quad& \quad & 0 & \quad \\ \quad & \quad & \sigma_k & \quad& \quad& \quad \\  \quad& \quad& \quad &0 & \quad& \quad\\ \quad & 0 & \quad& \quad & \ddots & \quad \\ \quad & \quad& \quad& \quad& \quad&0\end{matrix}\right]=\left[\begin{matrix} \sum_k & 0 \\ 0 & 0\end{matrix}\right]</script><p>则</p><script type="math/tex; mode=display">||A-A^{'}||_F=(\sigma_{k+1}^2+\sigma_{k+2}^2+\cdots+\sigma_{n}^2)^{1\over2}=\mathop{min}\limits_{S\in M} ||A-S||_F</script><p><strong>上式表明，在秩不超过 $k$ 的矩阵集合中，存在矩阵 $A$ 的弗罗贝尼乌斯范数意义下的最优近似矩阵 $X$。 $A^{‘}=U\sum^{‘}V^T$ 是达到最优值的一个矩阵。</strong></p><h4 id="6-3-矩阵的外积展开式"><a href="#6-3-矩阵的外积展开式" class="headerlink" title="6.3 矩阵的外积展开式"></a>6.3 矩阵的外积展开式</h4><p>矩阵 $A$  的奇异值分解也可以由外积形式表示。事实上，若将 $A$ 的奇异值分解看成矩阵 $U\sum$ 和 $V^T$ 的乘积，将 $U\sum$ 按列向量分块，将 $V^T$按行向量分块，即得</p><script type="math/tex; mode=display">U\sum=[\sigma_1u_1\quad \sigma_2u_2\quad\cdots\quad \sigma_nu_n]</script><script type="math/tex; mode=display">V^T=\left[\begin{matrix} v_1^T \\ v_2^T \\ \vdots \\ v_n^T\end{matrix}\right]</script><p>则</p><script type="math/tex; mode=display">A=\sigma_1u_1v_1^T+\sigma_2u_2v_2^T+\cdots+\sigma_nu_nv_n^T</script><p>上式称为矩阵 $A$ 的外积展开式。其中 $u_kv_k^T$ 为 $m×n$ 的矩阵，是列向量 $u_k$ 和行向量 $v_k^T$ 的外积，其第 $i$ 行第 $j$ 列元素为 $u_k$ 的第 $i$ 个元素与 $v_k^T$ 的第 $j$ 个元素的乘积。</p><p>一般的，设矩阵</p><script type="math/tex; mode=display">A_k=\sigma_1u_1v_1^T+\sigma_2u_2v_2^T+\cdots+\sigma_ku_kv_k^T</script><p><strong>则 $A_k$ 的秩为 $k$，并且 $A_k$ 是秩为 $k$ 的矩阵在弗罗贝尼乌斯范数意义下 $A$ 的最优近似矩阵。矩阵 $A_k$ 就是 $A$ 的截断奇异值分解。</strong></p><p>由于通常奇异值 $\sigma_i$ 递减很快，所以 $k$ 取很小值时， $A_k$  也可以对 $A$ 有很好得近似。</p><h3 id="七、Reference"><a href="#七、Reference" class="headerlink" title="七、Reference"></a>七、Reference</h3><ul><li>李航《统计学习方法》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(七):PageRank</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%83-PageRank.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%83-PageRank.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>历史上，<strong>PageRank算法作为计算互联网网页重要度</strong>的算法被提出。PageRank是定义在网页集合上的一个函数，它<strong>对每个网页给出一个正实数，表示网页的重要程度，PageRank值越高，网页就越重要，在互联网搜索的排序中可能就被排在前面。</strong></p><p><strong>假设互联网是一个有向图，在其基础上定义随机游走模型，即一阶马尔可夫链，表示网页浏览者在互联网上随机浏览网页的过程。</strong>假设浏览者在每个网页依照连接出去的超链接以<strong>等概率</strong>跳转到下一个网页，并在网上持续不断进行这样的随机跳转，这个过程形成一阶马尔可夫链。PageRank表示这个马尔可夫的平稳分布。每个网页的PageRank值就是平稳概率。</p><p><strong>直观上，一个网页，如果指向该网页的超链接越多，随即跳转到该网页的概率也就越高，该网页的PageRank值就越高，这个网页也就越重要。</strong>PageRank值依赖于网络的拓扑结构，一旦网络的拓扑确定，PageRank值就确定。</p><span id="more"></span><h3 id="一、随机游走模型"><a href="#一、随机游走模型" class="headerlink" title="一、随机游走模型"></a>一、随机游走模型</h3><p>给定一个含有 $n$ 个结点的有向图，在有向图上定义随机游走模型，即一阶马尔可夫链，其中节点表示状态，有向边表示状态之间的转移，假设从一个结点到通过有向边相连的所有结点的转移概率相等。具体的，转移矩阵是一个 $n$ 阶矩阵 $M$ </p><script type="math/tex; mode=display">M=[m_{ij}]_{n×n}</script><p>第 $i$ 行第 $j$ 列的元素 $m_{ij}$ 取值规则如下：如果结点 $j$ 有 $k$ 个有向边连出，并且结点 $i$ 是其连出的一个结点，则 $m_{ij} = \frac{1}{k}$ ；否则 $m_{ij}=0(i,j=1,2,\cdots,n)$ </p><p>注意转移矩阵具有性质：</p><script type="math/tex; mode=display">m_{ij}\geq 0　 且 　\mathop{\sum}\limits_{i=1}^{n}m_{ij}=1</script><p>在有向图上的随机游走形成马尔可夫链。也就是说，随机游走者没经一个单位时间转移一个状态，如果当前时刻在第 $j$ 个结点，那么下一个时刻在第 $i$ 个结点的概率是 $m_{ij}$ ，这一概率只依赖于当前的状态，与过去无关，具有马尔可夫性。</p><p>随机游走在某个时刻 $t$ 访问各个结点的概率分布就是马尔可夫链在时刻 $t$ 的状态分布，可以用一个 $n$ 维列向量 $R_t$ 表示，那么在时刻 $t+1$ 访问各个结点的概率分布 $R_{t+1}$ 满足</p><script type="math/tex; mode=display">R_{t+1}=MR_t</script><h3 id="二、PageRank的基本定义"><a href="#二、PageRank的基本定义" class="headerlink" title="二、PageRank的基本定义"></a>二、PageRank的基本定义</h3><p>给定一个包含 $n$ 个结点的<strong>强连通且非周期性</strong>的有向图，在其基础上定义随机游走模型。假设转移矩阵为 $M$，在时刻 $0,1,2,\cdots,t,\cdots$ 访问各个结点的概率分布为</p><script type="math/tex; mode=display">R_0,MR_0,M^2R_0,\cdots,M^tR_0,\cdots</script><p>则<strong>极限</strong></p><script type="math/tex; mode=display">\mathop{\lim}\limits_{t\rightarrow \infty} M^tR_0=R</script><p>存在，<strong>极限向量 $R$ 表示马尔可夫链的平稳分布</strong>，满足</p><script type="math/tex; mode=display">MR=R</script><p><strong>定义 $1$ ($PageRank$ 的基本定义)</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给定一个包含 $n$ 个结点 $v_1,v_2,\cdots,v_n$ 的<strong>强连通且非周期性</strong>的有向图，在有向图上定义随机游走模型，即一阶马尔可夫链。随机游走的特点是从一个结点到有有向边连出的所有结点的<strong>转移概率相等</strong>，转移矩阵为 $M$ 。这个马尔可夫链具有平稳分布 $R$ </p><script type="math/tex; mode=display">MR=R</script><p>平稳分布 $R$ 称为这个有向图的 $PageRank$。 $R$ 的各个分量称为各个结点的 $PageRank$ 值。</p><script type="math/tex; mode=display">R= \left[\begin{matrix}PR(v_1) \\ PR(v_2) \\ \cdots \\ PR(v_n) \end{matrix}\right]</script><p>其中，$PR(v_i)，i=1,2,\cdots,n$， 表示结点 $v_i$ 的 $PageRank$ 值</p><p>显然有</p><script type="math/tex; mode=display">PR(v_i) \geq 0， i=1,2,\cdots,n</script><script type="math/tex; mode=display">\mathop{\sum}\limits_{i=1}^{n}PR(v_i)=1</script><script type="math/tex; mode=display">PR(v_i)=\mathop{\sum}\limits_{v_j\in M(v_i)}\frac{PR(v_j)}{L(v_j)}，i=1,2,\cdots, n</script><p>这里 $M(v_i)$ 表示指向结点 $v_i$ 的结点集合，$L(v_j)$ 表示结点 $v_j$ 连出的有向边的个数。</p><p><strong>定理1</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不可约且非周期的有限状态马尔可夫链，有唯一平稳分布存在，并且当时间趋于无穷时状态分布收敛于唯一的平稳分布。</strong></p><h3 id="三、PageRank的一般定义"><a href="#三、PageRank的一般定义" class="headerlink" title="三、PageRank的一般定义"></a>三、PageRank的一般定义</h3><p>一般的有向图<strong>未必满足强连通且非周期性的条件</strong>。比如在互联网，<strong>大部分网页没有连接出去的超链接</strong>，也就是说<strong>从这些网页无法跳转到其他网页</strong>，所以<strong>$PageRank$ 的基本定义不适用</strong>（因为<strong>这种情况下某结点状态转移全为0</strong>，导致收敛结果全是0）。</p><p><strong>$PageRank$ 一般定义的想法是在基本定义的基础上导入平滑项。</strong></p><p>给定一个含有 $n$ 个结点 $v_i$ 的任意有向图，假设考虑一个在图上随机游走模型，即一阶马尔可夫链，其转移矩阵是 $M$，<strong>从一个结点到其连出的所有结点的转移概率相等</strong>，这个马尔可夫链未必具有平稳分布。假设考虑另一个完全随机游走的模型，其转移矩阵的元素全部为 $1\over n$，也就是说<strong>从任意一个结点到任意一个结点的转移概率都是 $1\over n$</strong>。<strong>两个转移矩阵的线性组合有构成一个新的转移矩阵，在其上可以定义一个新的马尔可夫链。</strong>容易证明这个马尔可夫链一定具有平稳分布，且平稳分布满足</p><script type="math/tex; mode=display">R=dMR+\frac{1-d}{n}1</script><p>式中 $d(0\leq d \leq 1)$ 是系数，称为<strong>阻尼因子</strong>，$R$ 是 $n$ 维向量，$\large 1$ 是所有分量为1的 $n$ 维向量。$R$ 表示的就是有向图的一般 $PageRank$。 </p><p><strong>上式第一项表示（状态分布是平稳分布时）依照状态转移矩阵 $M$ 访问各个结点的概率，第二项表示完全随机访问各个结点的概率。 阻尼因子 $d$ 取值由经验决定。当 $d$ 接近 $1$ 时，随机游走主要依照状态转移矩阵 $M$ 进行；当 $d$ 接近 $0$ 时，随机游走主要以等概率随机访问各个结点。</strong></p><p>$PageRank$ 的一般定义由于采用平滑项，<strong>所有结点的PageRank值都不会为0</strong>，具有以下性质：</p><script type="math/tex; mode=display">PR(v_i)>0，i=1,2,\cdots,n</script><script type="math/tex; mode=display">\mathop{\sum}\limits_{i=1}^{n}PR(v_i)=1</script><h3 id="四、PageRank的计算"><a href="#四、PageRank的计算" class="headerlink" title="四、PageRank的计算"></a>四、PageRank的计算</h3><p>$PageRank$ 的定义是构造性的，即定义本身就给出了算法。<strong>$PageRank$ 的计算方法包括迭代算法、幂法、代数算法</strong>，常用的方法是幂法。</p><h4 id="4-1-迭代算法"><a href="#4-1-迭代算法" class="headerlink" title="4.1 迭代算法"></a>4.1 迭代算法</h4><p>给定一个含有 $n$ 个结点的有向图，转移矩阵为 $M$，有向图的一般 $PageRank$ 由迭代公式</p><script type="math/tex; mode=display">R_{t+1}=dMR_t+\frac{1-d}{n}1</script><p>的极限向量 $R$ 确定。</p><p>$PageRank$ 的迭代算法，就是按照这个一般定义进行迭代，直至收敛。</p><p><strong>算法4.1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($PageRank$ 的迭代算法)</strong></p><blockquote><p>输入：含有 $n$ 个结点的有向图，转移矩阵 $M$，阻尼因子 $d$，初始向量 $R_0$;</p><p>输出：有向图的 $PageRank$ 向量 $R$。</p></blockquote><ul><li><p>(a) 令 $t=0$ </p></li><li><p>(b) 计算</p><script type="math/tex; mode=display">R_{t+1}=dMR_t+\frac{1-d}{n}1</script></li><li><p>(c) 如果$R_{t+1}$ 与 $R_t$ 充分接近，令 $R=R_{t+1}$，停止迭代。</p></li><li><p>(d) 否则，令 $t=t+1$，执行步骤(2)。</p></li></ul><h4 id="4-2-幂法"><a href="#4-2-幂法" class="headerlink" title="4.2 幂法"></a>4.2 幂法</h4><p>幂法(power method)是一个常用的 $PageRank$ 计算方法，通过<strong>近似计算矩阵的主特征值和主特征向量</strong>求得有向图的一般 $PageRank$。</p><p><strong>幂法主要用于近似计算矩阵的主特征值和主特征向量</strong>。<strong>主特征值是指绝对值最大的特征值</strong>，主特征向量是其对应的特征向量。注意特征向量不是唯一的，只是其方向是确定的，乘上任意系数还是特征向量。</p><p>假设要求 $n$ 阶矩阵 $A$ 的主特征值和主特征向量，采用下面的步骤。</p><p>首先，任取一个初始的 $n$ 维向量 $x_0$，构造如下的一个 $n$ 维向量序列</p><script type="math/tex; mode=display">x_0,\quad x1=Ax_0,\quad x2=Ax_1,\quad \cdots,\quad x_k=Ax_{k-1}</script><p>然后，假设矩阵 $A$ 有 $n$ 个特征值，<strong>按照绝对值大小排列</strong></p><script type="math/tex; mode=display">|\lambda_1|\geq|\lambda_2|\geq\cdots\geq|\lambda_n|</script><p>对应的 $n$ 个线性无关的特征向量为</p><script type="math/tex; mode=display">u_1,u_2,\cdots,u_n</script><p>这 $n$ 个特征向量构成 $n$ 维空间的一组基。</p><p>于是，可以将初始向量 $x_0$ 表示为 $u_1,u_2,\cdots,u_n$ 的线性组合</p><script type="math/tex; mode=display">x_0=a_1u_1+a_2u_2+\cdots+a_nu_n</script><p>得到</p><script type="math/tex; mode=display">x_1 = Ax_0 = a_1Au_1+a_2Au_2+\cdots+a_nAu_n</script><script type="math/tex; mode=display">\vdots</script><script type="math/tex; mode=display">x_k = A^kx_0=a_1A^ku_1+a_2A^ku_2+\cdots+a_nA^ku_n</script><script type="math/tex; mode=display">=a_1\lambda_1^ku_1+a_2\lambda_2^ku_2+\cdots+a_n\lambda_n^ku_n</script><p>接着，假设矩阵 $A$ 的主特征值 $\lambda_1$ 是特征方程的单根，由上式得</p><script type="math/tex; mode=display">x_k=a_1\lambda_1^k\left[u_1+\frac{a_2}{a_1}(\frac{\lambda_2}{\lambda_1})^ku_2+\cdots+\frac{a_n}{a_1}(\frac{\lambda_n}{\lambda_1})^ku_n\right]</script><p>由于 $|\lambda_1|&gt;|\lambda_j|,j=2,\cdots,n$，当 $k$ 充分大时有</p><script type="math/tex; mode=display">x_k=a_1\lambda_1^k[u_1+\epsilon_k]</script><p>这里 $\epsilon_k$ 是当 $k\rightarrow\infty$ 时的无穷小量， $\epsilon_k \rightarrow 0(k\rightarrow\infty)$。即</p><script type="math/tex; mode=display">x_k\rightarrow a_1\lambda_1^ku_1(k\rightarrow\infty)</script><p>说明当 $k$ 充分大时向量 $x_k$ 与特征向量 $u_1$ 只相差一个系数。由上式可知</p><script type="math/tex; mode=display">x_k\approx a_1\lambda_1^ku_1</script><script type="math/tex; mode=display">x_{k+1}\approx a_1\lambda_1^{k+1}u_1</script><p>于是主特征值 $\lambda_1$ 可表示为</p><script type="math/tex; mode=display">\lambda_1\approx \frac{x_{k+1,j}}{x_{k,j}}</script><p>其中 $x_{k,j}$ 和 $x_{k+1,j}$分别是 $x_k$ 和 $x_{k+1}$ 的第 $j$ 个分量。</p><p>在实际计算时，为了避免出现绝对值过大或过小的情况，<strong>通常在每步迭代后即进行规范化</strong>，将向量除以范数，即</p><script type="math/tex; mode=display">y_{t+1}=Ax_t</script><script type="math/tex; mode=display">x_{t+1}=\frac{y_{t+1}}{||y_{t+1}||}</script><p>现在回到计算一般 $PageRank$。</p><p>转移矩阵可以写作</p><script type="math/tex; mode=display">R=\left(dM+\frac{1-d}{n}E\right)R=AR</script><p>其中 $d$ 是阻尼因子，E是所有元素为1的 $n$ 阶方阵。根据 <code>Perron-Frobenius</code> 定理，<strong>一般 $PageRank$ 的向量 $R$ 是矩阵 $A$ 的主特征向量，主特征值是1</strong>。所以可以使用幂法近似计算一般 $PageRank$。</p><p><strong>算法4.2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(计算一般$PageRank$ 的幂法)</strong></p><blockquote><p>输入：含有 $n$ 个结点的有向图，有向图的转移矩阵 $M$，系数 $d$，初始向量 $x_0$，计算精度 $\epsilon$；</p><p>输出：有向图的 $PageRank\ R$</p></blockquote><ul><li><p>(a) 令 $t=0$，选择初始向量 $x_0$</p></li><li><p>(b) 计算有向图的一般转移矩阵 $A$</p><script type="math/tex; mode=display">A=dM+\frac{1-d}{n}E</script></li><li><p>(c) 迭代并规范化结果向量</p><script type="math/tex; mode=display">y_{t+1}=Ax_t</script><script type="math/tex; mode=display">x_{t+1}=\frac{y_{t+1}}{||y_{t+1}||}</script></li><li><p>(d) 当 $||x_{t+1}-x_t||&lt;\epsilon$时，令 $R=x_t$，停止迭代</p></li><li><p>(e) 否则，令 $t=t+1$，执行步(c)</p></li><li><p>(f) 对 $R$ 进行规范化处理，使其表示概率分布</p></li></ul><h4 id="4-3-代数算法"><a href="#4-3-代数算法" class="headerlink" title="4.3 代数算法"></a>4.3 代数算法</h4><p>代数算法通过一般转移矩阵的逆矩阵计算求有向图的一般 $PageRank$。</p><p>按照一般 $PageRank$ 的定义式</p><script type="math/tex; mode=display">R=dMR+\frac{1-d}{n}1</script><p>于是，</p><script type="math/tex; mode=display">(I-dM)R=\frac{1-d}{n}1</script><script type="math/tex; mode=display">R=(I-dM)^{-1}\frac{1-d}{n}1</script><p>这里 $I$ 是单位矩阵。当 $0&lt;d&lt;1$时，线性方程组的解存在且唯一。这样，可以通过求逆矩阵 $(I-dM)^{-1}$ 得到有向图的一般 $PageRank$。</p><h3 id="五、Reference"><a href="#五、Reference" class="headerlink" title="五、Reference"></a>五、Reference</h3><ul><li>李航《统计学习方法》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(六):EM算法</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%85%AD-EM%E7%AE%97%E6%B3%95.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%85%AD-EM%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>概率模型有时既含有观测变量，又含有隐变量或潜在变量。</strong>如果概率模型的变量都是观测变量，那么给定数据，可以直接用极大似然估计法，或贝叶斯估计法估计模型参数。但是 ，当模型含有隐变量时，就不能简单地使用这些估计方法。E<strong>M算法就是含有隐变量的概率模型参数的极大似然估计法，或极大后验概率估计法。</strong></p><p>EM算法作为一种<strong>数据添加</strong>算法，在近几十年得到迅速的发展，主要源于当前科学研究以及各方面实际应用中数据量越来越大的情况下，经常<strong>存在数据缺失或者不可用</strong>的的问题，这时候直接处理数据比较困难，而数据添加办法有很多种，常用的有神经网络拟合、添补法、卡尔曼滤波法等等，但是<strong>EM算法之所以能迅速普及主要源于它算法简单，稳定上升的步骤能非常可靠地找到“最优的收敛值”。</strong>随着理论的发展，EM算法己经不单单用在处理缺失数据的问题，运用这种思想，它所能处理的问题更加广泛。有时候缺失数据并非是真的缺少了，而是为了简化问题而采取的策略，这时EM算法被称为数据添加技术，所添加的数据通常被称为“潜在数据”，复杂的问题通过引入恰当的潜在数据，能够有效地解决我们的问题。</p><p>介绍EM算法之前，我们需要介绍<strong>极大似然估计以及Jensen不等式</strong>。</p><span id="more"></span><h3 id="一、极大似然估计"><a href="#一、极大似然估计" class="headerlink" title="一、极大似然估计"></a>一、极大似然估计</h3><p><strong>(1) 学生身高问题</strong><br>  我们需要调查学校的男生和女生的身高分布。 假设在校园里随机找了100个男生和100个女生。他们共200个人。将他们按照性别划分为两组，然后先统计抽样得到的100个男生的身高。假设他们的身高是服从正态分布的，但是这个分布的均值 $\mu$ 和方差 $\sigma^2$ 我们不知道，这两个参数就是我们要估计的。记作 $\theta = [\mu, \sigma]^T$。 </p><p>  <strong>问题：</strong>我们知道样本所服从的概率分布模型和一些样本，需要求解该模型的参数。</p><p>我们已知的有两个：样本服从的分布模型、随机抽取的样本；我们未知的有一个：模型的参数。根据已知条件，通过极大似然估计，求出未知参数。总的来说：<strong>极大似然估计就是用来估计模型参数的统计学方法。</strong> </p><p><strong>(2) 如何估计</strong></p><p>设样本集 $X=x_1,x_2,\cdots,x_N$，其中 $N=100$ , $p(x_i|\theta)$ 为概率密度函数，表示抽到男生的身高 $x_i$的概率。由于100个样本之间独立同分布，所以同时抽到这100个男生的概率就是他们各自概率的乘机，也就是样本集 $X$ 中各样本的联合概率，用下式表示：</p><script type="math/tex; mode=display">L(\theta) = L(x_1,\cdots,x_n;\theta)=\prod_{i=1}^np(x_i;\theta)</script><p>这个概率反映了，在概率密度函数的参数是 $\theta$  时，得到 $X$ 这组样本的概率。 我们需要找到一个参数 $\theta$ ，使得抽到 $X$ 这组样本的概率最大，也就是说需要其对应的似然函数 $L(\theta)$ 最大。满足条件的 $\theta$ 叫做 $\theta$ 的最大似然估计量，记为 ：</p><script type="math/tex; mode=display">\hat{\theta} = argmax L(\theta)</script><p><strong>(3) 求最大似然函数估计值的一般步骤</strong> </p><ul><li><p><strong>(a) 首先，写出似然函数：</strong> </p><script type="math/tex; mode=display">L(\theta) = L(x_1,\cdots,x_n;\theta)=\prod_{i=1}^np(x_i;\theta)</script></li><li><p><strong>(b) 然后，对似然函数取对数：</strong> </p></li></ul><script type="math/tex; mode=display">H(\theta) = \ln L(\theta) = \ln\prod_{i=1}^np(x_i;\theta) = \sum_{i=1}^n\ln p(x_i;\theta)</script><ul><li><strong>(c) 接着，对上式待求参数求导，令导数为0，得到似然方程</strong></li><li><strong>(d) 最后，求解似然方程，得到的参数 $\theta$ 即为所求。</strong></li></ul><h3 id="二、Jensen不等式"><a href="#二、Jensen不等式" class="headerlink" title="二、Jensen不等式"></a>二、Jensen不等式</h3><p><strong>设 $f(x)$ 是定义域为实数的函数，如果对于所有的实数 $x$， $f(x)$ 的二次导数大于等于0，那么 $f(x)$ 是凸函数(下凹)。 </strong></p><p>$Jensen$ 不等式表述如下：如果 $f(x)$ 是凸函数，$X$ 是随机变量，那么：$E[f(x)] \geq f[E(x)]$ 。当且仅当$X$ 是常量时，上式取等号。其中，$E(x)$ 表示 $X$ 的数学期望。 </p><p>图示中，实线 $f(x)$ 是凸函数，$X$ 是随机变量，有0.5的概率是 $a$，有0.5的概率是 $b$。$X$ 的期望值就是 $a$ 和 $b$ 的中值了，图中可以看到 $E[f(x)] \geq f[E(x)]$ 成立。 </p><center><img src="https://s2.ax1x.com/2019/09/03/nAcyRg.png" /></center><p><strong>注：</strong> </p><ul><li>Jensen不等式应用于凹函数时，不等号方向反向。当且仅当 $X$ 是常量时，Jensen不等式等号成立。 </li><li>关于凸函数，百度百科中是这样解释的——“ 对于实数集上的凸函数，一般的判别方法是求它的二阶导数，如果其二阶导数在区间上非负，就称为凸函数（向下凸）”。关于函数的凹凸性，中国数学界关于函数凹凸性定义和国外很多定义是反的。国内教材中的凹凸，是指曲线，而不是指函数，图像的凹凸与直观感受一致，却与函数的凹凸性相反。只要记住“函数的凹凸性与曲线的凹凸性相反”就不会把概念搞乱了”。关于凹凸性这里，确实解释不统一。这里暂时以函数的二阶导数大于零定义凸函数，此处不会过多影响EM算法的理解，只要能够确定何时 $E[f(x)] \geq f[E(x)]$ 或者 $E[f(x)] \leq f[E(x)]$ 就可以。 </li></ul><h3 id="三、EM算法"><a href="#三、EM算法" class="headerlink" title="三、EM算法"></a>三、EM算法</h3><h4 id="3-1-问题引进"><a href="#3-1-问题引进" class="headerlink" title="3.1 问题引进"></a>3.1 问题引进</h4><p>我们目前有100个男生和100个女生的身高，共200个数据，但是<strong>我们不知道这200个数据中哪个是男生的身高，哪个是女生的身高。</strong>假设男生、女生的身高分别服从正态分布，则<strong>每个样本是从哪个分布抽取的，我们目前是不知道的。</strong>这个时候，对于每一个样本，就有两个方面需要猜测或者估计： <strong>这个身高数据是来自于男生还是来自于女生？男生、女生身高的正态分布的参数分别是多少？</strong>EM算法要解决的问题正是这两个问题。<br><img src="https://s2.ax1x.com/2019/09/03/nAWAm9.png" alt=""></p><h4 id="3-2-EM算法的导出"><a href="#3-2-EM算法的导出" class="headerlink" title="3.2 EM算法的导出"></a>3.2 EM算法的导出</h4><p>我们面对一个含有隐变量的概率模型（如上面的男女，即各自的正态分布），<strong>目标是极大化观测数据 $Y$ 关于参数 $\theta$ 的对数似然函数</strong>，即极大化</p><script type="math/tex; mode=display">L(\theta) = \log P(Y|\theta)=\log\mathop{\sum}\limits_{Z}P(Y,Z|\theta)=\log\left(\mathop{\sum}\limits_{Z }P(Y|Z,\theta)P(Z|\theta)\right)</script><p><strong>注意到这一极大化的主要困难是式中有未观测数据并有包含和的对数。</strong></p><p>事实上，EM算法是通过迭代逐步近似极大化 $L(\theta)$ 的。假设在第 $i$ 次迭代后 $\theta$ 的估计值是 $\theta^{(i)}$。我们希望新估计值 $\theta$ 能使 $L(\theta) $ 增加，即 $L(\theta)&gt;L(\theta^{(i)})$ ，并逐步达到极大值。为此，<strong>考虑两者的差</strong>：</p><script type="math/tex; mode=display">L(\theta)-L(\theta^{(i)})= \log\left(\mathop{\sum}\limits_{Z }P(Y|Z,\theta)P(Z|\theta)\right)-\log P(Y|\theta^{(i)})</script><p><strong>利用Jensen不等式得到其下界：</strong></p><script type="math/tex; mode=display">L(\theta)-L(\theta^{(i)})= \log\left(\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})}\right)-\log P(Y|\theta^{(i)})</script><script type="math/tex; mode=display">\geq \mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})}-\log P(Y|\theta^{(i)})</script><script type="math/tex; mode=display">= \mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}</script><p>令</p><script type="math/tex; mode=display">B(\theta,\theta^{(i)})\hat{=}L(\theta^{(i)})+\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}</script><p>则</p><script type="math/tex; mode=display">L(\theta) \geq B(\theta,\theta^{(i)})</script><p>即函数 $B(\theta,\theta^{(i)})$ 是 $L(\theta)$ 的一个下界，而且由 $B(\theta,\theta^{(i)})$ 定义式可知，</p><script type="math/tex; mode=display">L(\theta^{(i)})=B(\theta^{(i)},\theta^{(i)})</script><p>因此，任何可以使 $B(\theta^{(i)},\theta^{(i)})$ 增大的 $\theta$ ，也可以使 $L(\theta)$ 增大。为了使 $L(\theta)$ 有尽可能大的增长，选择 $\theta^{(i+1)}$ 使 $B(\theta,\theta^{(i)})$ 达到极大，即</p><script type="math/tex; mode=display">\theta^{(i+1)}=arg \mathop{max}\limits_{\theta}B(\theta,\theta^{(i)})</script><p>现在求 $\theta^{(i+1)}$ 的表达式，<strong>省去对 $\theta$ 的极大化而言是常数的项</strong>，有</p><script type="math/tex; mode=display">\theta^{(i+1)}=arg \mathop{max}\limits_{\theta}\left(L(\theta^{(i)})+\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log \frac{P(Y|Z,\theta)P(Z|\theta)}{P(Z|Y,\theta^{(i)})P(Y|\theta^{(i)})}\right)</script><script type="math/tex; mode=display">=arg \mathop{max}\limits_{\theta}\left(\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log P(Y|Z,\theta)P(Z|\theta)\right)</script><script type="math/tex; mode=display">=arg \mathop{max}\limits_{\theta}\left(\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i)})\log P(Y,Z|\theta)\right)</script><script type="math/tex; mode=display">=arg \mathop{max}\limits_{\theta}Q(\theta,\theta^{(i)})</script><p><strong>上式等价于EM算法的一次迭代，即求Q函数及其极大化。EM算法是通过不断求解下界的极大化逼近求解对数似然函数极大化的算法。</strong></p><h4 id="3-3-EM算法"><a href="#3-3-EM算法" class="headerlink" title="3.3 EM算法"></a>3.3 EM算法</h4><blockquote><ul><li>输入：观测变量数据 $Y$，隐变量数据 $Z$，联合分布 $P(Y,Z|\theta)$ ，条件分布 $P(Z|Y,\theta)$；</li><li>输出：模型参数 $\theta$ </li></ul></blockquote><p><strong>(1) 选择参数的初值</strong> $\theta^{(0)}$，开始迭代；</p><p><strong>(2) E步：</strong>记 $\theta^{(i)}$ 为第 $i$ 次迭代参数 $\theta$ 的估计值，在第 $i+1$ 次迭代的E步，计算</p><script type="math/tex; mode=display">Q(\theta,\theta^{(i)})=E_z[\log P(Y,Z|\theta)|Y,\theta^{(i)}]</script><script type="math/tex; mode=display">=\mathop{\sum}\limits_{Z}\log P(Y,Z|\theta)P(Z|Y,\theta^{(i)})</script><p>这里，$P(Z|Y,\theta^{(i)})$ 是在给定观测数据 $Y$ 和当前的参数估计 $\theta^{(i)}$ 下隐变量数据 $Z$ 的条件概率分布；</p><p><strong>(3) M步：</strong>求使 $Q(\theta,\theta^{(i)})$ 极大化的 $\theta$ ，确定第 $i+1$ 次迭代的参数的估计值 $\theta^{(i+1)}$</p><script type="math/tex; mode=display">\theta^{(i+1)}=arg \mathop{max}\limits_{\theta}Q(\theta,\theta^{(i)})</script><p><strong>(4) 重复第(2)步和第(3)步，直至收敛</strong></p><p>上式的函数 $Q(\theta,\theta^{(i)})$ 是EM算法的核心，称为 <strong>$Q$ 函数。</strong></p><p><strong>下面关于EM算法作几点说明：</strong></p><p><strong>步骤(1)：</strong>参数的初值可以任意选择，但需注意EM算法<strong>对初值是敏感的</strong>。</p><p><strong>步骤(2)：</strong>每次迭代实际在<strong>求Q函数及其极大</strong>。</p><p><strong>步骤(3)：</strong>M步每次迭代<strong>使似然函数增大或达到局部极值</strong>。</p><p><strong>步骤(4)：</strong>给出<strong>停止迭代的条件</strong>，一般是对较小的正数 $\epsilon_1,\epsilon_2$，若满足</p><p>$||\theta^{(i+1)}-\theta^{(i)}||&lt;\epsilon_1$ 或  $||Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})||&lt;\epsilon_2$</p><p>则停止迭代。</p><h4 id="3-4-EM算法的收敛性"><a href="#3-4-EM算法的收敛性" class="headerlink" title="3.4 EM算法的收敛性"></a>3.4 EM算法的收敛性</h4><p><strong>问题：EM算法是否收敛？如果收敛，是否收敛到全局最大值或局部极大值？</strong></p><p><strong>定理1：设 $P(Y|\theta)$ 为观测数据的似然函数， $\theta^{(i)}$ 为EM算法得到的参数估计序列， $P(Y|\theta^{(i)})$ 为对应的似然函数序列，则 $ P(Y|\theta^{(i)})$ 是单调递增的，即</strong></p><script type="math/tex; mode=display">P(Y|\theta^{(i+1)})\geq P(Y|\theta^{(i)})</script><p><strong>证明：</strong>由于</p><script type="math/tex; mode=display">P(Y|\theta) = \frac{P(Y,Z|\theta)}{P(Z|Y,\theta)}</script><p>取对数有</p><script type="math/tex; mode=display">\log P(Y|\theta) = \log P(Y,Z|\theta)-\log P(Z|Y,\theta)</script><p>又因为</p><script type="math/tex; mode=display">Q(\theta,\theta^{(i)})=\mathop{\sum}\limits_{Z}\log P(Y,Z|\theta)P(Z|Y,\theta^{(i)})</script><p>令 </p><script type="math/tex; mode=display">H(\theta,\theta^{(i)})=\mathop{\sum}\limits_{Z}\log P(Z|Y,\theta)P(Z|Y,\theta^{(i)})</script><p>于是对数似然函数可以写成</p><script type="math/tex; mode=display">\log P(Y|\theta)=Q(\theta,\theta^{(i)})-H(\theta,\theta^{(i)})</script><p>在上式分别取 $\theta$ 为 $\theta^{(i)}$ 和 $\theta^{(i+1)}$ 并相减，有</p><script type="math/tex; mode=display">\log P(Y|\theta^{(i+1)}) - \log P(Y|\theta^{(i)})</script><script type="math/tex; mode=display">=[Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})]-[H(\theta^{(i+1)},\theta^{(i)})-H(\theta^{(i)},\theta^{(i)})]</script><p><strong>为证明定理成立，只需证明上式是非负的。</strong>上式右端第1项，由于 $\theta^{(i+1)}$ 使 $Q(\theta,\theta^{(i)})$ 达到极大，所以有</p><script type="math/tex; mode=display">Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})\geq 0</script><p>其第2项，由H定义式可得：</p><script type="math/tex; mode=display">H(\theta^{(i+1)},\theta^{(i)})-H(\theta^{(i)},\theta^{(i)})=\mathop{\sum}\limits_{Z}\left(\log \frac{P(Z|Y,\theta^{(i+1)})}{P(Z|Y,\theta^{(i)})}\right)P(Z|Y,\theta^{(i)})</script><script type="math/tex; mode=display">\leq \log\left(\mathop{\sum}\limits_{Z}\frac{P(Z|Y,\theta^{(i+1)})}{P(Z|Y,\theta^{(i)})}P(Z|Y,\theta^{(i)})\right)</script><script type="math/tex; mode=display">=\log \left(\mathop{\sum}\limits_{Z}P(Z|Y,\theta^{(i+1)})\right)=0</script><p><strong>这里的不等号由Jensen不等式得到。</strong></p><p><strong>综上所述，右端是非负的，定理成立。</strong></p><hr><p><strong>定理2：设 $L(\theta)=\log P(Y|\theta)$ 为观测数据的对数似然函数， $\theta^{(i)}$ 为EM算法得到的参数估计序列， $L(\theta^{(i)})$ 为对应的对数似然函数序列。</strong></p><p><strong>(1) 如果 $ P(Y|\theta)$ 有上界，则$L(\theta^{(i)})=\log P(Y|\theta^{(i)})$  收敛到某一值 $L^*$ ；</strong></p><p><strong>(2) 在函数 $Q(\theta,\theta^{‘})$ 与 $L(\theta)$ 满足一定条件下，由EM算法得到的参数估计序列 $\theta^{(i)}$ 的收敛值 $\theta^*$ 是 $L(\theta)$ 的稳定点。</strong></p><p><strong>证明：</strong></p><ul><li><p>(1) $L(\theta)=\log P(Y|\theta)$ 的单调性及 $ P(Y|\theta)$ 的有界性</p></li><li><p>(2) 证明从略</p></li></ul><h3 id="四、Reference"><a href="#四、Reference" class="headerlink" title="四、Reference"></a>四、Reference</h3><ul><li>李航《统计学习方法》</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(五):AdaBoost</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%BA%94-Adaboost.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%BA%94-Adaboost.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>提升(boosting)方法是一种常用的统计学习方法，应用广泛且有效。在分类问题中，它通过改变训练样本的权重，<strong>学习多个分类器</strong>，并<strong>将这些分类器进行线性组合</strong>，提高分类的性能。</p><p>提升方法基于这样一种思想：对于一个复杂任务来说，<strong>将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家的单独判断好</strong>。实际上，就是“三个臭皮匠顶个诸葛亮”的道理。提升方法就是<strong>从弱学习算法出发，反复学习，得到一系列弱分类器，然后组合这些弱分类器，构成一个强分类器</strong>。大多数提升方法都是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列的弱分类器。</p><p>这样，对提升方法来说，有<strong>两个问题</strong>：一是<strong>每一轮如何改变训练数据的权值分布</strong>；二是<strong>如何将弱分类器组合成一个强分类器</strong>。关于第一个问题，AdaBoost的做法是<strong>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值</strong>。这样一来，那些没有得到正确分类的数据，由于其权值的加大而收到后一轮的弱分类器的更大关注。至于第二个问题，<strong>AdaBoost采取加权多数表决的方法</strong>，即加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用；减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用。</p><p><strong>AdaBoost的巧妙之处就在于它将这些想法自然且有效的实现在一种算法里。</strong></p><span id="more"></span><h3 id="一、AdaBoost算法"><a href="#一、AdaBoost算法" class="headerlink" title="一、AdaBoost算法"></a>一、AdaBoost算法</h3><p>假定给定一个二分类的训练数据集：</p><script type="math/tex; mode=display">T=\{(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)\}</script><p>其中，每个样本点由实例与标记组成。实例 $x_i\in X \subseteq R^n$ ，标记 $y_i \in Y = \{-1, +1\}$，X是实例空间，Y是标记集合。 AdaBoost利用以下算法，从训练数据中学习一系列弱分类器或基本分类器，并将这些弱分类器线性组合成一个强分类器。</p><h4 id="1-1-算法-—-AdaBoost"><a href="#1-1-算法-—-AdaBoost" class="headerlink" title="1.1 算法 — AdaBoost"></a>1.1 算法 — AdaBoost</h4><blockquote><ul><li><p>输入：训练数据集 $T$；弱学习算法；</p></li><li><p>输出：最终分类器 $G(x)$</p></li></ul></blockquote><p><strong>(1) 初始化训练数据的权值分布</strong></p><script type="math/tex; mode=display">D_1 = (w_{11},\cdots,w_{1i},\cdots,w_{1N})，w_{1i} = \frac{1}{N}，i=1,2,\cdots,N</script><p><strong>(2) 对 $m=1,2,\cdots,M$</strong></p><ul><li><strong>(a)</strong> 使用具有权值分布 $D_m$ 的训练数据集学习，得到基本分类器</li></ul><script type="math/tex; mode=display">G_m(x):X\rightarrow\{-1,+1\}</script><ul><li><strong>(b)</strong> 计算 $G_m(x)$ 在训练数据集上的分类误差率</li></ul><script type="math/tex; mode=display">e_m=\sum_{i=1}^NP(G_m(x_i) \neq y_i)=\sum_{i=1}^Nw_{mi}I(G_m(x_i)\neq y_i)</script><ul><li><strong>(c)</strong> 计算 $G_m(x)$ 的系数</li></ul><script type="math/tex; mode=display">a_m=\frac{1}{2} \ln\frac{1-e_m}{e_m}</script><ul><li><strong>(d)</strong> 更新训练数据集的权值分布</li></ul><script type="math/tex; mode=display">D_{m+1}=(w_{m+1,1},\cdots,w_{m+1,i},\cdots,w_{m+1,N})</script><script type="math/tex; mode=display">w_{m+1,i}=\frac{w_{mi}}{Z_m}exp(-a_my_iG_m(x_i))，i=1,2,\cdots, N</script><script type="math/tex; mode=display">Z_m=\sum_{i=1}^{N}w_{mi}exp(-a_my_iG_m(x_i))</script><p><strong>(3) 构建基本分类器的线性组合</strong></p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^Ma_mG_m(x)</script><p>得到最终分类器</p><script type="math/tex; mode=display">G(x)=sign(f(x))=sign(\sum_{m=1}^Ma_mG_m(x))</script><h4 id="1-2-AdaBoost算法说明"><a href="#1-2-AdaBoost算法说明" class="headerlink" title="1.2 AdaBoost算法说明"></a>1.2 AdaBoost算法说明</h4><p><strong>步骤(1)：</strong>假设训练数据集具有均匀的权值分布，即每个训练样本在基本分类器的学习中作用相同，这一假设保证第1步能够在原始数据上学习基本分类器 $G_1(x)$。</p><p><strong>步骤(2)：</strong> AdaBoost反复学习基本的分类器，在每一轮 $m=1,2,\cdots, M$ 顺次执行下列操作：</p><ul><li><p><strong>(a)</strong> 使用当前分布 $D_m$ 加权的训练数据集，<strong>学习基本分类器</strong> $G_m(x)$。</p></li><li><p><strong>(b)</strong> <strong>计算</strong>基本分类器 $G_m(x)$ 在加权训练数据集上的<strong>分类误差率</strong>。</p></li><li><p><strong>(c)</strong> <strong>计算</strong>基本分类器 $G_m(x)$ 的<strong>系数</strong> $a_m$。$a_m$ 表示 $G_m(x)$ 在最终分类器中的重要性。由公式可知，分类误差率越小的基本分类器在最终分类器中的作用越大。</p></li><li><p><strong>(d)</strong> <strong>更新训练数据的权值</strong>分布为下一轮做准备，被基本分类器误分类样本的权值得以扩大，而被正确分类样本的权值得以缩小。因此，<strong>误分类样本在下一轮学习中起更大的作用</strong>。不改变所给的训练数据，而不断改变训练数据的权值分布，使得训练数据在基本分类器的学习中起不同的作用，这是AdaBoost的<strong>一个特点</strong>。</p></li></ul><p><strong>步骤(3)：</strong> <strong>线性组合</strong> $f(x)$ 实现 $M$ 个基本分类器的加权表决。<strong>系数 $a_m$ 表示了基本分类器 $G_m(x)$ 的重要性。</strong>这里，<strong>所有 $a_m$ 之和并不为1</strong>。<strong>$f(x)$的符号决定实例 $x$ 的类，$f(x)$ 的绝对值表示分类的确信度</strong>。利用基本分类器的线性组合构建最终分类器是AdaBoost的<strong>另一特点</strong>。 </p><h3 id="二、AdaBoost实例"><a href="#二、AdaBoost实例" class="headerlink" title="二、AdaBoost实例"></a>二、AdaBoost实例</h3><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th></tr></thead><tbody><tr><td style="text-align:center">$x$</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">$y$</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">-1</td><td style="text-align:center">-1</td><td style="text-align:center">-1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">-1</td></tr></tbody></table></div><p><strong>(1) 初始化数据权值分布</strong></p><script type="math/tex; mode=display">D_1 = (w_{11},w_{12},\cdots,w_{110})</script><script type="math/tex; mode=display">w_{1i}=0.1，i=1,2,\cdots,10</script><p><strong>(2) 对 $m=1$ ：</strong></p><ul><li><strong>(a)</strong> 在权值分布为 $D_1$ 的训练数据上，阈值 $v$ 取2.5时分类误差率最低，故基本分类器为</li></ul><script type="math/tex; mode=display">G_1(x)=\begin{cases}1,&x<2.5 \cr -1,&x>2.5\end{cases}</script><ul><li><p><strong>(b)</strong> $G_1(x)$ 在训练数据集上的误差率 $e_1 = P(G_1(x_i)\neq y_i)=0.3$ </p></li><li><p><strong>(c)</strong> 计算 $G_1(x) 的系数：a_1=\frac{1}{2}\ln\frac{1-e_1}{e_1}=0.4236$</p></li><li><p><strong>(d)</strong> 更新训练数据的权值分布</p></li></ul><script type="math/tex; mode=display">D_2=(w_{21},\cdots,w_{2i},\cdots,w_{210})</script><script type="math/tex; mode=display">w_{2i}=\frac{w_{1i}}{Z_1}exp(-a_1y_iG_1(x_i))，i=1,2,\cdots,10</script><script type="math/tex; mode=display">D_2 = (0.07143,0.07143,0.07143,0.07143,0.07143,0.07143,0.16667,0.16667,0.16667,0.07143)</script><script type="math/tex; mode=display">f_1(X)=0.4236G_1(x)</script><p>  分类器 $sign[f_1(x)]$ 在训练数据集上有3个误分类点。</p><p><strong>(3) 对 $m=2$：</strong></p><ul><li><strong>(a)</strong> 在权值分布为 $D_2$ 的训练数据上，阈值 $v$ 取8.5时分类误差率最低，故基本分类器为</li></ul><script type="math/tex; mode=display">G_2(x)=\begin{cases}1,&x<8.5 \cr -1,&x>8.5\end{cases}</script><ul><li><p><strong>(b)</strong> $G_2(x)$ 在训练数据集上的误差率 $e_2 = P(G_2(x_i)\neq y_i)=0.2143$ </p></li><li><p><strong>(c)</strong> 计算 $G_2(x) 的系数：a_2=\frac{1}{2}\ln\frac{1-e_2}{e_2}=0.6496$</p></li><li><p><strong>(d)</strong> 更新训练数据的权值分布</p></li></ul><script type="math/tex; mode=display">D_3=(w_{31},\cdots,w_{3i},\cdots,w_{310})</script><script type="math/tex; mode=display">w_{3i}=\frac{w_{2i}}{Z_2}exp(-a_2y_iG_2(x_i))，i=1,2,\cdots,10</script><script type="math/tex; mode=display">D_3 = (0.0455,0.0455,0.0455,0.1667,0.1667,0.1667,0.1060,0.1060,0.1060,0.0455)</script><script type="math/tex; mode=display">f_2(X)=0.4236G_1(x)+0.6496G_2(x)</script><p>  分类器 $sign[f_2(x)]$ 在训练数据集上有3个误分类点。</p><p><strong>(4) 对 $m=3$：</strong></p><ul><li><strong>(a)</strong> 在权值分布为 $D_3$ 的训练数据上，阈值 $v$ 取5.5时分类误差率最低，故基本分类器为</li></ul><script type="math/tex; mode=display">G_3(x)=\begin{cases}1,&x>5.5 \cr -1,&x<5.5\end{cases}</script><ul><li><p><strong>(b)</strong> $G_3(x)$ 在训练数据集上的误差率 $e_3 = P(G_3(x_i)\neq y_i)=0.1820$ </p></li><li><p><strong>(c)</strong> 计算 $G_3(x) 的系数：a_3=\frac{1}{2}\ln\frac{1-e_3}{e_3}=0.7514$</p></li><li><p><strong>(d)</strong> 更新训练数据的权值分布</p></li></ul><script type="math/tex; mode=display">D_4=(w_{41},\cdots,w_{4i},\cdots,w_{410})</script><script type="math/tex; mode=display">w_{4i}=\frac{w_{3i}}{Z_3}exp(-a_3y_iG_3(x_i))，i=1,2,\cdots,10</script><script type="math/tex; mode=display">D_4 = (0.125,0.125,0.125,0.102,0.102,0.102,0.065,0.065,0.065,0.125)</script><script type="math/tex; mode=display">f_3(X)=0.4236G_1(x)+0.6496G_2(x)+0.7514G_3(x)</script><p>  分类器 $sign[f_2(x)]$ 在训练数据集上误分类点个数为0。</p><p><strong>于是最终分类器为</strong></p><script type="math/tex; mode=display">G(x)=sign[f_3(x)]=sign[0.4236G_1(x)+0.6496G_2(x)+0.7514G_3(x)]</script><h3 id="三、Reference"><a href="#三、Reference" class="headerlink" title="三、Reference"></a>三、Reference</h3><ul><li>李航《统计学习方法》</li></ul><p>（注：公式证明过程略，可以去B站找对应视频，这篇只用作日后回忆）</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化算法(二):遗传算法</title>
      <link href="/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%BA%8C-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html"/>
      <url>/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%BA%8C-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是遗传算法"><a href="#一、什么是遗传算法" class="headerlink" title="一、什么是遗传算法"></a>一、什么是遗传算法</h3><h4 id="1-1-遗传算法的科学定义"><a href="#1-1-遗传算法的科学定义" class="headerlink" title="1.1 遗传算法的科学定义"></a>1.1 遗传算法的科学定义</h4><p>遗传算法（Genetic Algorithm, GA）是<strong>模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型</strong>，是<strong>一种通过模拟自然进化过程搜索最优解</strong>的方法。</p><p>其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的<strong>全局寻优</strong>能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。</p><p>遗传算法以<strong>一种群体中的所有个体为对象</strong>，并利用随机化技术指导<strong>对一个被编码的参数空间进行高效搜索</strong>。其中，<strong>选择、交叉和变异</strong>构成了遗传算法的遗传操作；<strong>参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定</strong>五个要素组成了遗传算法的核心内容。</p><span id="more"></span><h4 id="1-2-遗传算法的执行过程"><a href="#1-2-遗传算法的执行过程" class="headerlink" title="1.2 遗传算法的执行过程"></a>1.2 遗传算法的执行过程</h4><p>遗传算法是从代表问题可能潜在的解集的<strong>一个种群</strong>（population）开始的，而一个种群则由经过基因（gene）编码的<strong>一定数目的个体</strong>(individual)组成。<strong>每个个体实际上是染色体(chromosome)带有特征的实体。</strong></p><p>染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，<strong>在一开始需要实现从表现型到基因型的映射即编码工作</strong>。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。</p><p>初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根<strong>据问题域中个体的适应度（fitness）大小选择（selection）个体</strong>，并借助于自然遗传学的遗<strong>传算子（genetic operators）进行组合交叉（crossover）和变异（mutation）</strong>，<strong>产生出代表新的解集的种群</strong>。</p><p><strong>这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境</strong>，末代种群中的<strong>最优个体经过解码</strong>（decoding），<strong>可以作为问题近似最优解</strong>。</p><h4 id="1-3-遗传算法过程图解"><a href="#1-3-遗传算法过程图解" class="headerlink" title="1.3 遗传算法过程图解"></a>1.3 遗传算法过程图解</h4><p><img src="https://s2.ax1x.com/2019/08/18/mQ66YT.png" alt=""></p><h3 id="二、相关生物学术语"><a href="#二、相关生物学术语" class="headerlink" title="二、相关生物学术语"></a>二、相关生物学术语</h3><ul><li><p>基因型(genotype)：性状染色体的内部表现；</p></li><li><p>表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现；</p></li><li><p>个体（individual）：指染色体带有特征的实体；</p></li><li><p>种群（population）：个体的集合，该集合内个体数称为种群；</p></li><li><p>进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。</p></li><li><p>适应度(fitness)：度量某个物种对于生存环境的适应程度。</p></li><li><p>选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程；</p></li><li><p>复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因；</p></li><li><p>交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；</p></li><li><p>变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状；</p></li><li><p>编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射；</p></li><li><p>解码(decoding)：基因型到表现型的映射；</p></li></ul><h3 id="三、问题的引出与解决"><a href="#三、问题的引出与解决" class="headerlink" title="三、问题的引出与解决"></a>三、问题的引出与解决</h3><h4 id="3-1-现在我们要在-1-1-的区间内找出如下函数的最大值："><a href="#3-1-现在我们要在-1-1-的区间内找出如下函数的最大值：" class="headerlink" title="3.1 现在我们要在[-1,1]的区间内找出如下函数的最大值："></a>3.1 现在我们要在[-1,1]的区间内找出如下函数的最大值：</h4><p><img src="https://s2.ax1x.com/2019/08/18/mQgqLd.png" alt=""></p><p>我们可以很容易的看到，上面的函数存在很多极大值和极小值，而最大值是指定区间种极大值最大的那一个。从图像上具体表现为，极大值像是一座座山峰，极小值则是像一座座山谷。因此，我们可以把遗传算法的过程看作是一个在多元函数里面求最优解的过程。这些山峰对应着局部最优解，其中有一个山峰是海拔最高的，这个山峰则对应的是全局最优解。那么，遗传算法要做的就是尽量爬到最高峰，而不是困在较低的小山峰上。（如果问题求解是最小值，那么要做的就是尽量走到最低谷，道理是一样的）。</p><h4 id="3-2-“袋鼠蹦跳”"><a href="#3-2-“袋鼠蹦跳”" class="headerlink" title="3.2 “袋鼠蹦跳”"></a>3.2 “袋鼠蹦跳”</h4><p>既然我们把函数曲线理解成一个一个山峰和山谷组成的山脉。那么我们可以设想所得到的每一个解就是一只袋鼠，我们希望它们不断的向着更高处跳去，直到跳到最高的山峰。<strong>所以求最大值的过程就转化成一个“袋鼠跳”的过程。</strong></p><p>下面介绍介绍“袋鼠跳”的几种方式。</p><ul><li><strong>爬山算法</strong>：一只袋鼠朝着比现在高的地方跳去。它找到了不远处的最高的山峰。但是这座山不一定是最高峰。这就是爬山算法，<strong>它不能保证局部最优值就是全局最优值</strong>。</li><li><strong>模拟退火</strong>：袋鼠喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它<strong>渐渐清醒</strong>了并朝最高峰跳去。这就是模拟退火算法。</li><li><strong>遗传算法</strong>：有很多袋鼠，它们降落到喜玛拉雅山脉的<strong>任意地方</strong>。这些袋鼠并不知道它们的任务是寻找珠穆朗玛峰。但<strong>每过几年，就在一些海拔高度较低的地方射杀一些袋鼠</strong>。于是，不断有袋鼠死于海拔较低的地方，而越是在海拔高的袋鼠越是能活得更久，也越有机会生儿育女。就这样经过许多年，这些袋鼠们竟然都<strong>不自觉地聚拢到了一个个的山峰上</strong>，可是在所有的袋鼠中，只有聚拢到珠穆朗玛峰的袋鼠被带回了美丽的澳洲。</li></ul><h3 id="四、大体实现过程"><a href="#四、大体实现过程" class="headerlink" title="四、大体实现过程"></a>四、大体实现过程</h3><p><strong>遗传算法中每一条染色体，对应着遗传算法的一个解决方案，一般我们用适应性函数（fitness function）来衡量这个解决方案的优劣</strong>。所以从一个基因组到其解的适应度形成一个映射。<strong>遗传算法的实现过程实际上就像自然界的进化过程那样。</strong></p><p>下面我们用袋鼠跳中的步骤一一对应解释，以方便大家理解：</p><ol><li>首先寻找一种对问题潜在解进行“数字化”编码的方案。（建立表现型和基因型的映射关系）</li><li>随机初始化一个种群（那么第一批袋鼠就被随意地分散在山脉上），种群里面的个体就是这些数字化的编码。</li><li>接下来，通过适当的解码过程（得到袋鼠的位置坐标）。</li><li>用适应性函数对每一个基因个体作一次适应度评估（袋鼠爬得越高当然就越好，所以适应度相应越高）。</li><li>用选择函数按照某种规定择优选择（每隔一段时间，射杀一些所在海拔较低的袋鼠，以保证袋鼠总体数目持平。）。</li><li>让个体基因变异（让袋鼠随机地跳一跳）。</li><li>然后产生子代（希望存活下来的袋鼠是多产的，并在那里生儿育女）。</li></ol><p><strong>遗传算法并不保证你能获得问题的最优解，但是使用遗传算法的最大优点在于你不必去了解和操心如何去“找”最优解。（你不必去指导袋鼠向那边跳，跳多远。）而只要简单的“否定”一些表现不好的个体就行了。（把那些总是爱走下坡路的袋鼠射杀，这就是遗传算法的精髓！）</strong></p><p>由此我们可以得出遗传算法的一般步骤：</p><ol><li>随机产生种群。</li><li>根据策略判断个体的适应度，是否符合优化准则，若符合，输出最佳个体及其最优解，结束。否则，进行下一步。</li><li>依据适应度选择父母，适应度高的个体被选中的概率高，适应度低的个体被淘汰。</li><li>用父母的染色体按照一定的方法进行交叉，生成子代。</li><li>对子代染色体进行变异。</li><li>由交叉和变异产生新一代种群，返回步骤2，直到最优解产生。</li></ol><h3 id="五、具体实现过程"><a href="#五、具体实现过程" class="headerlink" title="五、具体实现过程"></a>五、具体实现过程</h3><h4 id="5-1-编码"><a href="#5-1-编码" class="headerlink" title="5.1 编码"></a>5.1 编码</h4><p><strong>编码是应用遗传算法时要解决的首要问题</strong>，也是设计遗传算法时的一个<strong>关键步骤</strong>。编码方法影响到交叉算子、变异算子等遗传算子的运算方法，<strong>很大程度上决定了遗传进化的效率</strong>。</p><p>迄今为止人们已经提出了许多种不同的编码方法。总的来说，这些编码方法可以分为三大类：<strong>二进制编码法、浮点编码法、符号编码法</strong>。下面分别进行介绍：</p><h5 id="5-1-1-二进制编码"><a href="#5-1-1-二进制编码" class="headerlink" title="5.1.1 二进制编码"></a>5.1.1 二进制编码</h5><p>就像人类的基因有<code>AGCT</code>这4种碱基序列一样，不过在这里我们只用了<strong>0和1</strong>两种碱基,然后将他们<strong>串成一条链形成染色体</strong>。一个位能表示出2种状态的信息量，因此足够长的二进制染色体便能表示所有的特征，这便是二进制编码。如下： <u>1110001010111</u></p><p>它由二进制符号0和1所组成的二值符号集。它有以下一些<strong>优点</strong>：</p><ol><li>编码、解码操作简单易行</li><li>交叉、变异等遗传操作便于实现</li><li>合最小字符集编码原则</li><li>利用模式定理对算法进行理论分析</li></ol><p>二进制编码的<strong>缺点</strong>是：对于一些连续函数的优化问题，由于其随机性使得其局部搜索能力较差，如<strong>对于一些高精度的问题（如上题），当解迫近于最优解后，由于其变异后表现型变化很大，不连续，所以会远离最优解，达不到稳定。</strong></p><h5 id="5-1-2-浮点编码法"><a href="#5-1-2-浮点编码法" class="headerlink" title="5.1.2 浮点编码法"></a>5.1.2 浮点编码法</h5><p>二进制编码虽然简单直观，但明显的存在着连续函数离散化时的映射误差。个体长度较短时，可能达不到精度要求，而个体编码长度较长时，虽然能提高精度，但增加了解码的难度，使遗传算法的搜索空间急剧扩大。</p><p>所谓浮点法，是指个体的每个基因值用某一范围内的一个浮点数来表示。在浮点数编码方法中，必须保证基因值在给定的区间限制范围内，遗传算法中所使用的交叉、变异等遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。如下所示：</p><p>1.2-3.2-5.3-7.2-1.4-9.7</p><p>浮点数编码方法有下面几个优点：</p><ol><li>适用于在遗传算法中表示范围较大的数</li><li>适用于精度要求较高的遗传算法</li><li>便于较大空间的遗传搜索</li><li>改善了遗传算法的计算复杂性，提高了运算交率</li><li>便于遗传算法与经典优化方法的混合使用</li><li>便于设计针对问题的专门知识的知识型遗传算子</li><li>便于处理复杂的决策变量约束条件</li></ol><h5 id="5-1-3-符号编码法"><a href="#5-1-3-符号编码法" class="headerlink" title="5.1.3 符号编码法"></a>5.1.3 符号编码法</h5><p>符号编码法是指个体染色体编码串中的基因值<strong>取一个无数值含义、而只有代码含义的符号集如｛A,B,C…｝</strong>。<br>符号编码的主要优点是：</p><ol><li>符合有意义积术块编码原则</li><li>便于在遗传算法中利用所求解问题的专门知识</li><li>便于遗传算法与相关近似算法之间的混合使用</li></ol><h4 id="5-2-为我们的袋鼠染色体编码"><a href="#5-2-为我们的袋鼠染色体编码" class="headerlink" title="5.2 为我们的袋鼠染色体编码"></a>5.2 为我们的袋鼠染色体编码</h4><p>在上面介绍了一系列编码方式以后，那么，如何利用上面的编码来为我们的袋鼠染色体编码呢？首先我们要<strong>明确一点</strong>：<strong>编码无非就是建立从基因型到表现型的映射关系</strong>。这里的表现型可以理解为个体特征（比如身高、体重、毛色等等）。那么，在此问题下，我们关心的个体特征就是：<strong>袋鼠的位置坐标</strong>（因为我们要把海拔低的袋鼠给杀掉）。无论袋鼠长什么样，爱吃什么。我们关心的始终是袋鼠在哪里，并且只要知道了袋鼠的位置坐标（位置坐标就是相应的染色体编码，可以通过解码得出），我们就可以：</p><ol><li>在喜马拉雅山脉的地图上找到相应的位置坐标，算出海拔高度。（相当于通过自变量求得适应函数的值）然后判断该不该射杀该袋鼠。</li><li>可以知道染色体交叉和变异后袋鼠新的位置坐标。</li></ol><p>回到求一元函数最大值的问题。在上面我们把极大值比喻为山峰，那么，袋鼠的位置坐标可以比喻为区间[-1, 1]的某一个x坐标。这个x坐标是一个实数，现在，说白了就是怎么对这个x坐标进行编码。下面我们以二进制编码为例讲解。（如果以浮点数编码，其实就很简洁了，就一浮点数而已。）</p><p>我们说过，一定长度的二进制编码序列，只能表示一定精度的浮点数。<strong>在这里假如我们要求解精确到六位小数，由于区间长度为<code>1 - (-1) = 2</code> ,为了保证精度要求，至少把区间 <code>[-1,1]</code> 分为2 × 10^6等份</strong>。又因为:</p><blockquote><p>2^20 = 1048576 &lt; 2*10^6 &lt; 2^21 = 2097152</p></blockquote><p><strong>所以编码的二进制串至少需要21位。</strong></p><blockquote><p><strong>把一个二进制串 $(b_0 \dots b_{19}b_{20})$ 转化为区间里面对应的实数值可以通过下面两个步骤:</strong></p><ul><li><p>将一个二进制串代表的二进制数转化为10进制数：</p><script type="math/tex; mode=display">(b_0 \dots b_{19}b_{20})_2 = (\sum^{20}_{i=0}b_i·2^i)_{10} = x^t</script></li><li><p>对应区间内的实数：</p><script type="math/tex; mode=display">x = -1 + x^t \frac{(1-(-1))}{2^{21}-1}</script></li></ul></blockquote><p>上面的编码方式只是举个例子让大家更好理解而已，编码的方式千奇百怪，层出不穷，每个问题可能采用的编码方式都不一样。</p><h4 id="5-3-评价个体的适应度—适应度函数（fitness-function）"><a href="#5-3-评价个体的适应度—适应度函数（fitness-function）" class="headerlink" title="5.3 评价个体的适应度—适应度函数（fitness function）"></a>5.3 评价个体的适应度—适应度函数（fitness function）</h4><p>前面说了，适应度函数主要是通过个体特征从而判断个体的适应度。在本例的袋鼠跳中，我们只关心袋鼠的海拔高度，以此来判断是否该射杀该袋鼠。这样一来，该函数就非常简单了。只要输入袋鼠的位置坐标，在通过相应查找运算，返回袋鼠当前位置的海拔高度就行。</p><p>适应度函数也称评价函数，是根据目标函数确定的用于区分群体中个体好坏的标准。<strong>适应度函数总是非负的</strong>，<strong>而目标函数可能有正有负，故需要在目标函数与适应度函数之间进行变换</strong>。</p><p><strong>评价个体适应度的一般过程为</strong>：</p><ol><li>对个体编码串进行解码处理后，可得到个体的表现型。</li><li>由个体的表现型可计算出对应个体的目标函数值。</li><li>根据最优化问题的类型，由目标函数值按一定的转换规则求出个体的适应度。</li></ol><h4 id="5-4-射杀一些袋鼠—选择函数（selection）"><a href="#5-4-射杀一些袋鼠—选择函数（selection）" class="headerlink" title="5.4 射杀一些袋鼠—选择函数（selection）"></a>5.4 射杀一些袋鼠—选择函数（selection）</h4><p><strong>遗传算法中的选择操作就是用来确定如何从父代群体中按某种方法选取那些个体，以便遗传到下一代群体</strong>。选择操作用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。前面说了，我们希望海拔高的袋鼠存活下来，并尽可能繁衍更多的后代。但我们都知道，在自然界中，适应度高的袋鼠越能繁衍后代，但这也是从概率上说的而已，毕竟有些适应度低的袋鼠也可能逃过我们的眼睛。</p><p>那么，怎么建立这种概率关系呢？</p><p><strong>下面介绍几种常用的选择算子：</strong></p><ol><li><strong>轮盘赌选择</strong>（Roulette Wheel Selection）：是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例，选择误差较大。</li><li><strong>随机竞争选择</strong>（Stochastic Tournament）：每次按轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复，直到选满为止。</li><li><strong>最佳保留选择</strong>：首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。</li></ol><p><strong>具体介绍一下轮盘赌选择：</strong></p><p>轮盘赌选择又称比例选择方法。其基本思想是：<strong>各个个体被选中的概率与其适应度大小成正比</strong>。</p><blockquote><p>具体操作如下：</p><ol><li>计算出群体中每个个体的适应度大小</li><li>计算出每个个体被遗传到下一代群体中的概率: $P(x_i) = \frac{f(x_i)}{\sum_{j=1}^{N}f(x_j)}$</li><li>计算出每个个体的累积概率: $q_i = \sum_{j=1}^{i}P(x_j)$</li><li>在[0，1]区间内产生一个均匀分布的随机数r；</li><li>若 r &lt; q[1]，则选择个体1，否则，选择个体k，使得：q[k-1]&lt;r≤q[k] 成立；</li><li>重复4、5</li></ol></blockquote><h4 id="5-5-遗传—染色体交叉-crossover"><a href="#5-5-遗传—染色体交叉-crossover" class="headerlink" title="5.5 遗传—染色体交叉(crossover)"></a>5.5 遗传—染色体交叉(crossover)</h4><p>遗传算法的交叉操作，是指对两个相互配对的染色体<strong>按某种方式相互交换其部分基因，从而形成两个新的个体。</strong></p><p>适用于二进制编码个体或浮点数编码个体的交叉算子：</p><ol><li><strong>单点交叉</strong>（One-point Crossover）：指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。</li><li><strong>两点交叉与多点交叉</strong>：(1) 两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换。(2) 多点交叉（Multi-point Crossover）</li><li><strong>均匀交叉</strong>（也称一致交叉，Uniform Crossover）：两个配对个体的每个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新个体。</li><li><strong>算术交叉</strong>（Arithmetic Crossover）：由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。</li></ol><h4 id="5-6-变异—基因突变-Mutation"><a href="#5-6-变异—基因突变-Mutation" class="headerlink" title="5.6 变异—基因突变(Mutation)"></a>5.6 变异—基因突变(Mutation)</h4><p>遗传算法中的变异运算，是指<strong>将个体染色体编码串中的某些基因座上的基因值用该基因座上的其它等位基因来替换，从而形成新的个体。</strong></p><p>例如下面这串二进制编码：</p><p>101101001011001</p><p>经过基因突变后，可能变成以下这串新的编码：</p><p><strong>0</strong>011010<strong>1</strong>1011001</p><p>以下变异算子适用于二进制编码和浮点数编码的个体：</p><ol><li><strong>基本位变异</strong>（Simple Mutation）：对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。</li><li><strong>均匀变异</strong>（Uniform Mutation）：分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。（特别适用于在算法的初级运行阶段）</li><li><strong>边界变异</strong>（Boundary Mutation）：随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。</li><li><strong>非均匀变异</strong>：对原有的基因值做一随机扰动，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一次轻微的变动。</li><li><strong>高斯近似变异</strong>：进行变异操作时用符号均值为 $P$ 的平均值，方差为 $P^2$ 的正态分布的一个随机数来替换原有的基因值。</li></ol><h3 id="六、利用Python实现遗传算法解决上述问题"><a href="#六、利用Python实现遗传算法解决上述问题" class="headerlink" title="六、利用Python实现遗传算法解决上述问题"></a>六、利用Python实现遗传算法解决上述问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GA</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b, init_num</span>):</span></span><br><span class="line">        self.a = a                  <span class="comment"># 区间左端</span></span><br><span class="line">        self.b = b                  <span class="comment"># 区间右端</span></span><br><span class="line">        self.init_num = init_num    <span class="comment"># 初始个体数目</span></span><br><span class="line">        self.bin_length = <span class="number">0</span>         <span class="comment"># 二进制编码长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initial</span>(<span class="params">self</span>):</span>  <span class="comment"># 在给定区间上实现二进制编码</span></span><br><span class="line">        dec_num = (self.b - self.a) * <span class="number">10</span> ** <span class="number">6</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">30</span>):</span><br><span class="line">            <span class="keyword">if</span> dec_num &gt;= <span class="number">2</span>**i <span class="keyword">and</span> dec_num &lt; <span class="number">2</span>**(i+<span class="number">1</span>):</span><br><span class="line">                self.bin_length = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> np.random.randint(<span class="number">0</span>,<span class="number">2</span>,(self.init_num, self.bin_length))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">self, ss</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param ss:  type(str)</span></span><br><span class="line"><span class="string">        :return:    float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> + <span class="built_in">int</span>(ss, <span class="number">2</span>) * (self.b-self.a) / (<span class="number">2</span>**self.bin_length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcY</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * np.sin(<span class="number">10</span>*np.pi*x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_fitness</span>(<span class="params">self, lst</span>):</span></span><br><span class="line">        code_string = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> lst])</span><br><span class="line">        value = self.decode(code_string)  <span class="comment"># 十进制数值</span></span><br><span class="line">        <span class="keyword">return</span> self.funcY(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">circle</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        fitness = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(array.shape[<span class="number">0</span>]):  <span class="comment"># 计算每个个体适应度</span></span><br><span class="line">            fitness.append(self.compute_fitness(array[i]))</span><br><span class="line">        fitness = np.array(fitness)</span><br><span class="line">        fitness = np.e ** fitness</span><br><span class="line">        <span class="comment"># 轮盘赌选择</span></span><br><span class="line">        f = fitness / np.<span class="built_in">sum</span>(fitness)</span><br><span class="line">        q = np.cumsum(f)</span><br><span class="line">        rand = np.random.rand(array.shape[<span class="number">0</span>])</span><br><span class="line">        rand_index = np.zeros(array.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> rand:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(array.shape[<span class="number">0</span>]):</span><br><span class="line">                left = <span class="number">0</span> <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">else</span> q[j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> r &gt; left <span class="keyword">and</span> r &lt; q[j]:</span><br><span class="line">                    rand_index[j] += <span class="number">1</span></span><br><span class="line">        rand_index = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(array.shape[<span class="number">0</span>]) <span class="keyword">if</span> rand_index[i]]  <span class="comment"># 轮盘赌索引</span></span><br><span class="line">        next_array = np.array([<span class="built_in">list</span>(array[i]) <span class="keyword">for</span> i <span class="keyword">in</span> rand_index])  <span class="comment"># 选择后的个体矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择剩下的30%进行交叉</span></span><br><span class="line">        newgroup_num = next_array.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> xnum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(newgroup_num * <span class="number">0.3</span>)):</span><br><span class="line">            randnum1 = np.random.randint(<span class="number">0</span>, newgroup_num)</span><br><span class="line">            randnum2 = np.random.randint(<span class="number">0</span>, newgroup_num)</span><br><span class="line">            <span class="keyword">if</span> randnum1 != randnum2:</span><br><span class="line">                individual1 = next_array[randnum1]</span><br><span class="line">                individual2 = next_array[randnum2]</span><br><span class="line">                midvar = copy.deepcopy(individual1[<span class="built_in">int</span>(self.bin_length * <span class="number">0.3</span>):])</span><br><span class="line">                individual1[<span class="built_in">int</span>(self.bin_length * <span class="number">0.3</span>):] = individual2[<span class="built_in">int</span>(self.bin_length * <span class="number">0.3</span>):]</span><br><span class="line">                individual2[<span class="built_in">int</span>(self.bin_length * <span class="number">0.3</span>):] = midvar</span><br><span class="line">                next_array[randnum1] = individual1</span><br><span class="line">                next_array[randnum2] = individual2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 变异</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(newgroup_num):</span><br><span class="line">            rand1 = np.random.rand()</span><br><span class="line">            <span class="keyword">if</span> rand1 &lt; <span class="number">0.01</span>:</span><br><span class="line">                next_array[i][<span class="built_in">int</span>(self.bin_length * <span class="number">0.8</span>)] = <span class="number">0</span> <span class="keyword">if</span> next_array[i][<span class="built_in">int</span>(self.bin_length * <span class="number">0.8</span>)] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_array</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">self</span>):</span></span><br><span class="line">        init_array = self.initial()    <span class="comment"># 初始化</span></span><br><span class="line">        next_array = self.circle(init_array)</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            next_array = self.circle(next_array)</span><br><span class="line"></span><br><span class="line">        X = []</span><br><span class="line">        Y = []</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> next_array:</span><br><span class="line">            X.append(self.decode(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> ii])))</span><br><span class="line">            Y.append(self.compute_fitness(ii))</span><br><span class="line">        <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ga = GA(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    X, Y = ga.main()</span><br><span class="line">    <span class="built_in">print</span>(X,Y)</span><br><span class="line">    rowX = np.arange(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0.01</span>)</span><br><span class="line">    plt.plot(rowX, ga.funcY(rowX), linewidth=<span class="number">2</span>)</span><br><span class="line">    plt.scatter(X, Y,c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>图示如下：</p><p><img src="https://s2.ax1x.com/2019/08/18/mlQJV1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 优化算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python地理编码库geopy的使用</title>
      <link href="/Python%E5%9C%B0%E7%90%86%E7%BC%96%E7%A0%81%E5%BA%93geopy%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
      <url>/Python%E5%9C%B0%E7%90%86%E7%BC%96%E7%A0%81%E5%BA%93geopy%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>处理地理数据经常会涉及到地理编码的问题。地理编码指的是将地理信息转化成坐标关系的过程。分为正向和反向的编码。正向的是指将地址信息转换为坐标点，比如：武汉市武汉大学—&gt;(114.3594147, 30.5401222)；反向地理编码就是将地理坐标转换为具体的地址，是一个与前面相反的过程。</p><p>基于Python的地理编码库geopy 是用于地理编码的常用工具，使用它可获取多种地图服务的坐标。Python开发者可以使用geopy很容易的获取全球的某个街道地址，城市，国家和地块的地理坐标，它是通过第三方的地理编码器和数据源来解析的。</p><p>主要有以下几个功能：</p><ol><li>地理编码：将字符串转换为地理位置</li><li>逆地理编码：用于将地理坐标转换为具体地址</li><li>计算两个点的距离：经纬度距离和球面距离</li></ol><span id="more"></span><h3 id="二、地理编码"><a href="#二、地理编码" class="headerlink" title="二、地理编码"></a>二、地理编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim</span><br><span class="line"></span><br><span class="line">geolocator = Nominatim()                       <span class="comment"># 定义对象</span></span><br><span class="line">location = geolocator.geocode(<span class="string">&quot;北京天安门&quot;</span>)      <span class="comment"># 传入位置字符串</span></span><br><span class="line"><span class="built_in">print</span>(location.address)                   <span class="comment"># 打印地址信息</span></span><br><span class="line"><span class="built_in">print</span>((location.latitude,location.longitude))  <span class="comment"># 打印纬度、经度</span></span><br><span class="line"><span class="built_in">print</span>(location.altitude)       <span class="comment"># 打印海拔</span></span><br><span class="line"><span class="built_in">print</span>(location.raw)   <span class="comment"># 打印地图信息</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">天安门, <span class="number">1</span>, 西长安街, 崇文, 北京市, 东城区, 北京市, <span class="number">100010</span>, 中国</span><br><span class="line">(<span class="number">39.9073426</span>, <span class="number">116.391264649167</span>)</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line">&#123;<span class="string">&#x27;place_id&#x27;</span>: <span class="number">242516302</span>, <span class="string">&#x27;licence&#x27;</span>: <span class="string">&#x27;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&#x27;</span>, <span class="string">&#x27;osm_type&#x27;</span>: <span class="string">&#x27;relation&#x27;</span>, <span class="string">&#x27;osm_id&#x27;</span>: <span class="number">8847697</span>, <span class="string">&#x27;boundingbox&#x27;</span>: [<span class="string">&#x27;39.9071466&#x27;</span>, <span class="string">&#x27;39.9075289&#x27;</span>, <span class="string">&#x27;116.3905678&#x27;</span>, <span class="string">&#x27;116.3919619&#x27;</span>], <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.9073426&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.391264649167&#x27;</span>, <span class="string">&#x27;display_name&#x27;</span>: <span class="string">&#x27;天安门, 1, 西长安街, 崇文, 北京市, 东城区, 北京市, 100010, 中国&#x27;</span>, <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;historic&#x27;</span>, <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;city_gate&#x27;</span>, <span class="string">&#x27;importance&#x27;</span>: <span class="number">0.001</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="三、逆地理编码"><a href="#三、逆地理编码" class="headerlink" title="三、逆地理编码"></a>三、逆地理编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geopy.geocoders <span class="keyword">import</span> Nominatim</span><br><span class="line"></span><br><span class="line">geolocator = Nominatim()</span><br><span class="line">location = geolocator.reverse(<span class="string">&quot;39.9073426, 116.391264649167&quot;</span>)   <span class="comment"># 传入纬度、经度字符串</span></span><br><span class="line"><span class="built_in">print</span>(location.address)</span><br><span class="line"><span class="built_in">print</span>((location.latitude,location.longitude))</span><br><span class="line"><span class="built_in">print</span>(location.altitude)</span><br><span class="line"><span class="built_in">print</span>(location.raw)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">天安门, <span class="number">1</span>, 西长安街, 崇文, 北京市, 东城区, 北京市, <span class="number">100010</span>, 中国</span><br><span class="line">(<span class="number">39.9073426</span>, <span class="number">116.391264649167</span>)</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line">&#123;<span class="string">&#x27;place_id&#x27;</span>: <span class="number">242516302</span>, <span class="string">&#x27;licence&#x27;</span>: <span class="string">&#x27;Data © OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright&#x27;</span>, <span class="string">&#x27;osm_type&#x27;</span>: <span class="string">&#x27;relation&#x27;</span>, <span class="string">&#x27;osm_id&#x27;</span>: <span class="number">8847697</span>, <span class="string">&#x27;lat&#x27;</span>: <span class="string">&#x27;39.9073426&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>: <span class="string">&#x27;116.391264649167&#x27;</span>, <span class="string">&#x27;display_name&#x27;</span>: <span class="string">&#x27;天安门, 1, 西长安街, 崇文, 北京市, 东城区, 北京市, 100010, 中国&#x27;</span>, <span class="string">&#x27;address&#x27;</span>: &#123;<span class="string">&#x27;address29&#x27;</span>: <span class="string">&#x27;天安门&#x27;</span>, <span class="string">&#x27;house_number&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;road&#x27;</span>: <span class="string">&#x27;西长安街&#x27;</span>, <span class="string">&#x27;suburb&#x27;</span>: <span class="string">&#x27;崇文&#x27;</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;东城区&#x27;</span>, <span class="string">&#x27;state&#x27;</span>: <span class="string">&#x27;北京市&#x27;</span>, <span class="string">&#x27;postcode&#x27;</span>: <span class="string">&#x27;100010&#x27;</span>, <span class="string">&#x27;country&#x27;</span>: <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;country_code&#x27;</span>: <span class="string">&#x27;cn&#x27;</span>&#125;, <span class="string">&#x27;boundingbox&#x27;</span>: [<span class="string">&#x27;39.9071466&#x27;</span>, <span class="string">&#x27;39.9075289&#x27;</span>, <span class="string">&#x27;116.3905678&#x27;</span>, <span class="string">&#x27;116.3919619&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="四、计算经纬度距离"><a href="#四、计算经纬度距离" class="headerlink" title="四、计算经纬度距离"></a>四、计算经纬度距离</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> geodesic</span><br><span class="line"></span><br><span class="line">tian_an_men = (<span class="number">39.9073285</span>, <span class="number">116.391242416486</span>)</span><br><span class="line">xiaozhai = (<span class="number">34.2253171</span>, <span class="number">108.9426205</span>)</span><br><span class="line"><span class="comment"># 可以是meters（米）、kilometers（千米）、miles（英里）、nautical（海里）、feet（英尺）</span></span><br><span class="line"><span class="built_in">print</span>(geodesic(tian_an_men, xiaozhai).meters)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">913925.3165094886</span></span><br></pre></td></tr></table></figure><h3 id="五、计算球面距离"><a href="#五、计算球面距离" class="headerlink" title="五、计算球面距离"></a>五、计算球面距离</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geopy.distance <span class="keyword">import</span> great_circle</span><br><span class="line"></span><br><span class="line">tian_an_men = (<span class="number">39.9073285</span>, <span class="number">116.391242416486</span>)</span><br><span class="line">xiaozhai = (<span class="number">34.2253171</span>, <span class="number">108.9426205</span>)</span><br><span class="line"><span class="comment"># 可以是meters（米）、kilometers（千米）、miles（英里）、nautical（海里）、feet（英尺）</span></span><br><span class="line"><span class="built_in">print</span>(great_circle(tian_an_men, xiaozhai).meters)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">913657.4596518732</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> geopy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10搭建Tensorflow-GPU环境</title>
      <link href="/Win10%E6%90%AD%E5%BB%BATensorflow-GPU%E7%8E%AF%E5%A2%83.html"/>
      <url>/Win10%E6%90%AD%E5%BB%BATensorflow-GPU%E7%8E%AF%E5%A2%83.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近在使用人脸识别FaceNet碰到了些训练上的速度问题，特来此记录下配置Tensorflow-GPU环境的过程，防止以后还需要用到。</p><blockquote><p><strong>自己的环境：</strong></p><p>操作系统： Windows 10</p><p>GPU:           GTX1050+CUDA9.0+cuDNN</p><p>Python：   Version 3.7</p><p>深度学习框架：tensorflow-gpu</p></blockquote><p><strong>注意：CUDA 选择安装的版本一定要和你电脑上的显卡信息相匹配，否则tensorflow-gpu会报错！！！</strong></p><span id="more"></span><h3 id="二、安装过程"><a href="#二、安装过程" class="headerlink" title="二、安装过程"></a>二、安装过程</h3><h4 id="2-1-安装-CUDA-9-0"><a href="#2-1-安装-CUDA-9-0" class="headerlink" title="2.1 安装 CUDA 9.0"></a>2.1 安装 <a href="https://developer.nvidia.com/cuda-90-download-archive">CUDA 9.0</a></h4><p><img src="https://s2.ax1x.com/2019/07/26/enwaW9.png" alt=""></p><p><strong>下载好后打开进行安装：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endAN4.jpg" alt=""></p><p><strong>下一步会检测系统兼容性，有些显卡是不支持GPU的:</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endiHU.png" alt=""></p><p><strong>接收协议，开始安装：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endMDK.png" alt=""></p><p><strong>安装选择自定义安装，自定义安装选项如下，我们只选择我们需要的：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endPBT.png" alt=""></p><p><strong>安装位置默认就好，不然之后可能会有一系列问题：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endE4J.png" alt=""></p><p><strong>等待安装完成：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endmg1.png" alt=""></p><p><strong>安装完成之后，下一步需要配置环境变量：</strong></p><p><strong>如果安装成功，系统变量会多出两个为：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/ende3R.png" alt=""></p><p><strong>还需要自己添加几个系统变量：</strong></p><blockquote><p>CUDA_SDK_PATH = C:\ProgramData\NVIDIA Corporation\CUDA Samples\v9.0(这是默认安装位置的路径，如果自己设置路径安装成功的话就用自己的路径)</p><p>CUDA_LIB_PATH = %CUDA_PATH%\lib\x64 </p><p>CUDA_BIN_PATH = %CUDA_PATH%\bin </p><p>CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\bin\win64 </p><p>CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\common\lib\x64</p></blockquote><p><strong>添加好之后应该像下面这样：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/end84H.png" alt=""></p><p><strong>下一步在系统变量PATH里添加东西。找到系统变量的PATH双击，添加下列东西：</strong></p><blockquote><p>%CUDA_LIB_PATH%</p><p>%CUDA_BIN_PATH%</p><p>%CUDA_SDK_LIB_PATH%</p><p>%CUDA_SDK_BIN_PATH%</p><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\lib\x64   (这些均为默认路径，有需要的话自行修改)</p><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin </p><p>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v9.0\common\lib\x64</p><p>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v9.0\bin\win64</p></blockquote><p><strong>添加完之后CUDA就算安装完成了，我们可以检验是否安装成功：</strong></p><p>① 打开CMD，cd 到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\extras\demo_suite（这是默认路径）</p><p>② 分别执行命令：</p><blockquote><p>bandwidthTest.exe</p><p>deviceQuery.exe</p></blockquote><p><img src="https://s2.ax1x.com/2019/07/26/endY8A.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/07/26/endJCd.png" alt=""></p><p><strong>若分别返回图示结果则CUDA 9.0安装成功！</strong></p><h3 id="2-2-安装cuDNN"><a href="#2-2-安装cuDNN" class="headerlink" title="2.2 安装cuDNN"></a>2.2 安装cuDNN</h3><p><strong>去<a href="https://developer.nvidia.com/cudnn">cuDNN官网</a>上下载搭配 CUDA 9.0 的 cuDNN ，一定要注意搭配9.0，会需要注册英伟达的账号：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endtgI.png" alt=""></p><p><strong>注册好之后进行下载：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/endNvt.png" alt=""></p><p><strong>下载好之后进行解压，分别将<code>.h</code> <code>.lib</code> 和 <code>.dll</code> 文件分别拷贝到 CUDA 的<code>include</code>, <code>lib/x64</code>, <code>bin</code> 文件夹下，其实也就是对应的文件夹。</strong></p><p><strong>到这里就安装好了CUDA 9.0及其对应的 cuDNN！</strong></p><h3 id="2-3-安装Tensorflow-GPU"><a href="#2-3-安装Tensorflow-GPU" class="headerlink" title="2.3 安装Tensorflow-GPU"></a>2.3 安装Tensorflow-GPU</h3><p><strong>之前安装的是CPU版本，所以先删除</strong></p><blockquote><p>pip uninstall tensorflow</p></blockquote><p><strong>删除之后我选择使用 pip 安装 tensorflow-gpu：</strong></p><blockquote><p>pip install tensorflow-gpu</p></blockquote><p><strong>进入Python环境检测是否安装成功：</strong></p><p><img src="https://s2.ax1x.com/2019/07/26/enhS2V.md.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Pulp解决线性规划问题</title>
      <link href="/%E5%88%A9%E7%94%A8Pulp%E8%A7%A3%E5%86%B3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98.html"/>
      <url>/%E5%88%A9%E7%94%A8Pulp%E8%A7%A3%E5%86%B3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、常用的线性规划求解器"><a href="#一、常用的线性规划求解器" class="headerlink" title="一、常用的线性规划求解器"></a>一、常用的线性规划求解器</h3><ul><li>Excel</li><li>Lingo</li><li>Matlab</li></ul><h3 id="二、Python-interface-for-optimization"><a href="#二、Python-interface-for-optimization" class="headerlink" title="二、Python interface for optimization"></a>二、Python interface for optimization</h3><ul><li>Pulp<ul><li>LP Modules</li></ul></li><li>OpenOpt<ul><li>LP Modules</li><li>non-LP Modules</li></ul></li></ul><span id="more"></span><h3 id="三、Pulp"><a href="#三、Pulp" class="headerlink" title="三、Pulp"></a>三、Pulp</h3><h5 id="3-1-安装pulp"><a href="#3-1-安装pulp" class="headerlink" title="3.1 安装pulp"></a>3.1 安装pulp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pulp</span><br></pre></td></tr></table></figure><h5 id="3-2-导入库函数"><a href="#3-2-导入库函数" class="headerlink" title="3.2 导入库函数"></a>3.2 导入库函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h5 id="3-3-定义线性规划问题"><a href="#3-3-定义线性规划问题" class="headerlink" title="3.3 定义线性规划问题"></a>3.3 定义线性规划问题</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PB = LpProblen(Problem name, sense)</span><br></pre></td></tr></table></figure><p>构造函数，用来构造一个LP问题实例，其中name指定问题名（输出信息用），sense值是 LpMinimize 或 LpMaximize 中的一个，用来指定目标函数是求最大值还是最小值。</p><h5 id="3-4-定义决策变量"><a href="#3-4-定义决策变量" class="headerlink" title="3.4 定义决策变量"></a>3.4 定义决策变量</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X1 = LpVariable(variable name, lowbound, upbound, category)</span><br></pre></td></tr></table></figure><p>variable name 指定变量名， lowbound 和 upbound 是下界和上界，默认分别是 -inf 到 inf，category 用来指定变量是离散（LpInteger，LpBinary）还是连续（LpContinuous）。</p><h5 id="3-5-添加目标函数"><a href="#3-5-添加目标函数" class="headerlink" title="3.5 添加目标函数"></a>3.5 添加目标函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PB += linear objective <span class="keyword">in</span> equantion <span class="keyword">for</span> objective name</span><br></pre></td></tr></table></figure><h5 id="3-6-添加约束条件"><a href="#3-6-添加约束条件" class="headerlink" title="3.6 添加约束条件"></a>3.6 添加约束条件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PB += linear objective <span class="keyword">in</span> equantion <span class="keyword">for</span> constraint name</span><br></pre></td></tr></table></figure><h5 id="3-7-写入LP文件"><a href="#3-7-写入LP文件" class="headerlink" title="3.7 写入LP文件"></a>3.7 写入LP文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PB.writeLP(filename)</span><br></pre></td></tr></table></figure><h5 id="3-8-模型求解"><a href="#3-8-模型求解" class="headerlink" title="3.8 模型求解"></a>3.8 模型求解</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PB.slove()</span><br></pre></td></tr></table></figure><h5 id="3-9-结果显示"><a href="#3-9-结果显示" class="headerlink" title="3.9 结果显示"></a>3.9 结果显示</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pulp.LpStatus[PB.status]</span><br></pre></td></tr></table></figure><h3 id="四、Python实例"><a href="#四、Python实例" class="headerlink" title="四、Python实例"></a>四、Python实例</h3><p><img src="https://s2.ax1x.com/2019/07/12/ZWP36A.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">prob = LpProblem(<span class="string">&#x27;Problem1&#x27;</span>, LpMaximize)</span><br><span class="line"></span><br><span class="line">x1 = LpVariable(<span class="string">&#x27;x1&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x2 = LpVariable(<span class="string">&#x27;x2&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line">x3 = LpVariable(<span class="string">&#x27;x2&#x27;</span>, <span class="number">0</span>, <span class="literal">None</span>, LpContinuous)</span><br><span class="line"></span><br><span class="line">prob += <span class="number">1000</span> * x1 + <span class="number">2000</span> * x2 + <span class="number">3000</span> * x3</span><br><span class="line"></span><br><span class="line">prob += x1 + <span class="number">2</span> * x2 + <span class="number">3</span> * x3 &lt;= <span class="number">10</span></span><br><span class="line">prob += <span class="number">0</span> * x1 + x2 + <span class="number">2</span> * x3 &lt;= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">prob.writeLP(<span class="string">&#x27;Problem1.lp&#x27;</span>)</span><br><span class="line">prob.solve()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;status: &quot;</span>, LpStatus[prob.status])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> prob.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name,<span class="string">&#x27;=&#x27;</span>,v.variable)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Maximun Profit = &quot;</span>, value(prob.objective))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seaborn-statistical-data-visualization</title>
      <link href="/Seaborn-statistical-data-visualization.html"/>
      <url>/Seaborn-statistical-data-visualization.html</url>
      
        <content type="html"><![CDATA[<h3 id="Seaborn简介"><a href="#Seaborn简介" class="headerlink" title="Seaborn简介"></a>Seaborn简介</h3><p>Seaborn是一个用Python制作统计图形的库。它建立在matplotlib之上，并与pandas数据结构紧密集成。</p><p>以下是seaborn提供的一些功能：</p><ul><li>面向数据集的API，用于检查多个变量之间的关系</li><li>专门支持使用分类变量来显示观察结果或汇总统计数据</li><li>可视化单变量或双变量分布以及在数据子集之间进行比较的选项</li><li>不同类型因变量的线性回归模型的自动估计和绘图</li><li>方便地查看复杂数据集的整体结构</li><li>用于构建多绘图网格的高级抽象，可让您轻松构建复杂的可视化</li><li>简洁的控制matplotlib图形样式与几个内置主题</li><li>用于选择调色板的工具，可以忠实地显示数据中的模式</li><li>Seaborn旨在使可视化成为探索和理解数据的核心部分。其面向数据集的绘图功能对包含整个数据集的数据框和数组进行操作，并在内部执行必要的语义映射和统计聚合，以生成信息图。</li></ul><blockquote><p>Seaborn官方文档：&lt;<a href="http://seaborn.pydata.org/">http://seaborn.pydata.org/</a></p></blockquote><hr><span id="more"></span><h3 id="一、set-style-set"><a href="#一、set-style-set" class="headerlink" title="一、set_style()/set()"></a>一、set_style()/set()</h3><h5 id="1-1-set-style"><a href="#1-1-set-style" class="headerlink" title="1.1 set_style()"></a>1.1 set_style()</h5><p>set_style()是用来设置主题的，Seaborn有五个预设好的主题：darkgrid，whitegrid，dark，white和ticks  默认：darkgrid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">10</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/29/E3IM8S.png" alt=""></p><h5 id="1-2-set"><a href="#1-2-set" class="headerlink" title="1.2 set()"></a>1.2 set()</h5><p>set( )通过设置参数可以用来设置背景，调色板等，更加常用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;white&quot;</span>, palette=<span class="string">&quot;muted&quot;</span>, color_codes=<span class="literal">True</span>)  </span><br><span class="line">plt.plot(np.arange(<span class="number">10</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p>style就是所说的主题，白话一点就是背景，和set_style()是一样的。</p><p>palette是画板的意思，白话一点就是颜色，常见的颜色有：①deep/深色风，②muted/柔和风，③pastel/粉腊笔风，④bright/明亮风，⑤dark/黑暗风，⑥colorblind/色盲风，具体如下图所示。</p></blockquote><p><img src="https://s2.ax1x.com/2019/04/29/E37CCV.png" alt=""></p><h3 id="二、kdeplot-distplot"><a href="#二、kdeplot-distplot" class="headerlink" title="二、kdeplot( )/distplot( )"></a>二、kdeplot( )/distplot( )</h3><h5 id="2-1-kdeplot-核密度估计图"><a href="#2-1-kdeplot-核密度估计图" class="headerlink" title="2.1 kdeplot(核密度估计图)"></a>2.1 kdeplot(核密度估计图)</h5><p>核密度估计(kernel density estimation)是在<strong>概率论</strong>中用来估计未知的<strong>密度函数</strong>，属于非参数检验方法之一。通过核密度估计图可以比较直观的看出数据样本本身的分布特征。具体用法如下：</p><blockquote><p>seaborn.kdeplot(data,data2=None,shade=False,vertical=False,kernel=’gau’,bw=’scott’,gridsize=100,cut=3,clip=None,legend=True,cumulative=False,shade_lowest=True,cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs)</p></blockquote><p>我们通过一些具体的例子来学习一些参数的用法。</p><p>首先导入我们所需的相关库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h6 id="2-1-1-绘制简单的一维kde图像"><a href="#2-1-1-绘制简单的一维kde图像" class="headerlink" title="2.1.1 绘制简单的一维kde图像"></a>2.1.1 绘制简单的一维kde图像</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">100</span>) <span class="comment"># 创建100个服从正态分布的一维数据</span></span><br><span class="line">sns.kdeplot(x)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EG3YhF.png" alt=""></p><h6 id="2-1-2-shade：设置阴影，color：设置曲线及阴影颜色"><a href="#2-1-2-shade：设置阴影，color：设置曲线及阴影颜色" class="headerlink" title="2.1.2 shade：设置阴影，color：设置曲线及阴影颜色"></a>2.1.2 shade：设置阴影，color：设置曲线及阴影颜色</h6><p>shade若为True，则在kde曲线下面的区域中进行阴影处理，color控制曲线及阴影的颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x,shade=<span class="literal">False</span>,color=<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGJ74K.png" alt=""></p><h6 id="2-1-3-vertical：表示以X轴还是Y轴进行绘制"><a href="#2-1-3-vertical：表示以X轴还是Y轴进行绘制" class="headerlink" title="2.1.3 vertical：表示以X轴还是Y轴进行绘制"></a>2.1.3 vertical：表示以X轴还是Y轴进行绘制</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x,vertical=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYSEt.png" alt=""></p><h6 id="2-1-4-二元kde图像"><a href="#2-1-4-二元kde图像" class="headerlink" title="2.1.4 二元kde图像"></a>2.1.4 二元kde图像</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.randn(<span class="number">100</span>)</span><br><span class="line">y = np.random.randn(<span class="number">100</span>)</span><br><span class="line">sns.kdeplot(x,y,shade=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYmEq.png" alt=""></p><h6 id="2-1-5-cbar：若为True，则会添加一个颜色棒-颜色棒在二元kde图像中才有"><a href="#2-1-5-cbar：若为True，则会添加一个颜色棒-颜色棒在二元kde图像中才有" class="headerlink" title="2.1.5 cbar：若为True，则会添加一个颜色棒(颜色棒在二元kde图像中才有)"></a>2.1.5 cbar：若为True，则会添加一个颜色棒(颜色棒在二元kde图像中才有)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x,y,shade=<span class="literal">True</span>,cbar=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYGr9.png" alt=""></p><h5 id="2-2-distplot"><a href="#2-2-distplot" class="headerlink" title="2.2 distplot()"></a>2.2 distplot()</h5><p>distplot()集合了matplotlib的hist()与核函数估计kdeplot的功能，增加了rugplot分布观测条显示与利用scipy库fit拟合参数分布的新颖用途。具体用法如下：</p><blockquote><p>seaborn.distplot(a, bins=None, hist=True, kde=True, rug=False, fit=None, hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None, color=None, vertical=False, norm_hist=False, axlabel=None, label=None, ax=None)</p><p>先介绍一下直方图(Histograms)：</p><p>直方图又称<strong>质量分布图</strong>，它是表示资料变化情况的一种主要工具。用直方图可以解析出资料的规则性，比较直观地看出产品质量特性的分布状态，对于资料分布状况一目了然，便于判断其总体质量的分布情况。直方图表示通过沿数据范围<strong>形成分箱</strong>，然后绘制条以<strong>显示落入每个分箱的观测次数</strong>的数据分布。</p></blockquote><h6 id="2-2-1-绘制distplot"><a href="#2-2-1-绘制distplot" class="headerlink" title="2.2.1 绘制distplot"></a>2.2.1 绘制distplot</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.distplot(x,color=<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYjRU.png" alt=""></p><h6 id="2-2-2-通过hist和kde参数调节是否显示直方图及核密度估计-默认hist-kde均为True"><a href="#2-2-2-通过hist和kde参数调节是否显示直方图及核密度估计-默认hist-kde均为True" class="headerlink" title="2.2.2 通过hist和kde参数调节是否显示直方图及核密度估计(默认hist,kde均为True)"></a>2.2.2 通过<strong>hist</strong>和<strong>kde</strong>参数调节是否显示直方图及核密度估计(默认hist,kde均为True)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">sns.distplot(x,ax=axes[<span class="number">0</span>])</span><br><span class="line">sns.distplot(x,hist=<span class="literal">False</span>,ax=axes[<span class="number">1</span>])</span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,ax=axes[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYvzF.png" alt=""></p><h6 id="2-2-3-bins：int或list，控制直方图的划分"><a href="#2-2-3-bins：int或list，控制直方图的划分" class="headerlink" title="2.2.3 bins：int或list，控制直方图的划分"></a>2.2.3 bins：int或list，控制直方图的划分</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>) </span><br><span class="line"><span class="comment">#左图：分成20个区间</span></span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,bins=<span class="number">20</span>,ax=axes[<span class="number">0</span>]) </span><br><span class="line"><span class="comment">#右图：以0,1,2,3为分割点，形成区间[0,1],[1,2],[2,3]，区间外的值不计入。</span></span><br><span class="line">sns.distplot(x,kde=<span class="literal">False</span>,bins=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)],ax=axes[<span class="number">1</span>]) </span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYzM4.png" alt=""></p><h6 id="2-2-4-rag：控制是否生成观测数值的小细条"><a href="#2-2-4-rag：控制是否生成观测数值的小细条" class="headerlink" title="2.2.4 rag：控制是否生成观测数值的小细条"></a>2.2.4 rag：控制是否生成观测数值的小细条</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(x,rug=<span class="literal">True</span>,ax=axes[<span class="number">0</span>]) <span class="comment">#左图</span></span><br><span class="line">sns.distplot(x,ax=axes[<span class="number">1</span>]) <span class="comment">#右图</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYOiV.png" alt=""></p><h6 id="2-2-5-fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系-黑色线条为确定的分布"><a href="#2-2-5-fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系-黑色线条为确定的分布" class="headerlink" title="2.2.5 fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系(黑色线条为确定的分布)"></a>2.2.5 fit：控制拟合的参数分布图形，能够直观地评估它与观察数据的对应关系(黑色线条为确定的分布)</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> *</span><br><span class="line">sns.distplot(x,hist=<span class="literal">False</span>,fit=norm) <span class="comment">#拟合标准正态分布</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGYXGT.png" alt=""></p><h3 id="三、boxplot"><a href="#三、boxplot" class="headerlink" title="三、boxplot( )"></a>三、boxplot( )</h3><p>箱形图（Box-plot），是一种用作显示一组数据分散情况资料的统计图，因形状如箱子而得名。它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比 较。它能显示出一组数据的最大值、最小值、中位数、及上下四分位数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()[<span class="string">&#x27;sepal width&#x27;</span>]</span><br><span class="line">sns.boxplot(x=iris[<span class="string">&#x27;target&#x27;</span>],y=iris[<span class="string">&#x27;data&#x27;</span>][...,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGN1B9.png" alt=""></p><h3 id="四、jointplot"><a href="#四、jointplot" class="headerlink" title="四、jointplot( )"></a>四、jointplot( )</h3><blockquote><p>seaborn.jointplot(<em>x**</em>,<strong> <em>y</em></strong>,<strong> <em>data=None</em></strong>,<strong> <em>kind=’scatter’</em></strong>,<strong> <em>stat_func=None</em></strong>,<strong> <em>color=None</em></strong>,<strong> <em>height=6</em></strong>,<strong> <em>ratio=5</em></strong>,<strong> <em>space=0.2</em></strong>,<strong> <em>dropna=True</em></strong>,<strong> <em>xlim=None</em></strong>,<strong> <em>ylim=None</em></strong>,<strong> <em>joint_kws=None</em></strong>,<strong> <em>marginal_kws=None</em></strong>,<strong> <em>annot_kws=None</em></strong>,<strong> *</strong>kwargs*)</p></blockquote><h6 id="4-1-散点图-分布图"><a href="#4-1-散点图-分布图" class="headerlink" title="4.1 散点图 + 分布图"></a>4.1 散点图 + 分布图</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rs = np.random.RandomState(<span class="number">2</span>)</span><br><span class="line">df = pd.DataFrame(rs.randn(<span class="number">200</span>,<span class="number">2</span>), columns = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">sns.jointplot(</span><br><span class="line">         x=df[<span class="string">&#x27;A&#x27;</span>], y=df[<span class="string">&#x27;B&#x27;</span>], <span class="comment">#设置xy轴，显示columns名称</span></span><br><span class="line">              data = df,  <span class="comment">#设置数据</span></span><br><span class="line">              color = <span class="string">&#x27;b&#x27;</span>, <span class="comment">#设置颜色</span></span><br><span class="line">              s = <span class="number">50</span>,edgecolor = <span class="string">&#x27;w&#x27;</span>,linewidth = <span class="number">1</span>,<span class="comment">#设置散点大小、边缘颜色及宽度(只针对scatter)</span></span><br><span class="line">              kind = <span class="string">&#x27;scatter&#x27;</span>,<span class="comment">#设置类型：&#x27;scatter&#x27;,&#x27;reg&#x27;,&#x27;resid&#x27;,&#x27;kde&#x27;,&#x27;hex&#x27;</span></span><br><span class="line">              space = <span class="number">0.1</span>, <span class="comment">#设置散点图和布局图的间距</span></span><br><span class="line">              height = <span class="number">8</span>, <span class="comment">#图表大小(自动调整为正方形))</span></span><br><span class="line">              ratio = <span class="number">5</span>, <span class="comment">#散点图与布局图高度比，整型</span></span><br><span class="line">              marginal_kws = <span class="built_in">dict</span>(bins=<span class="number">15</span>, rug =<span class="literal">True</span>), <span class="comment">#设置柱状图箱数，是否设置rug</span></span><br><span class="line">             )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGaYQO.png" alt=""></p><h6 id="4-2-六边形图"><a href="#4-2-六边形图" class="headerlink" title="4.2 六边形图"></a>4.2 六边形图</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(</span><br><span class="line">      x=df[<span class="string">&#x27;A&#x27;</span>], y=df[<span class="string">&#x27;B&#x27;</span>], <span class="comment">#设置xy轴，显示columns名称</span></span><br><span class="line">              data = df,  <span class="comment">#设置数据</span></span><br><span class="line">              color = <span class="string">&#x27;grey&#x27;</span>, <span class="comment">#设置颜色</span></span><br><span class="line">              kind = <span class="string">&#x27;hex&#x27;</span>,<span class="comment">#设置类型：&#x27;scatter&#x27;,&#x27;reg&#x27;,&#x27;resid&#x27;,&#x27;kde&#x27;,&#x27;hex&#x27;</span></span><br><span class="line">              space = <span class="number">0.1</span>, <span class="comment">#设置散点图和布局图的间距</span></span><br><span class="line">              height = <span class="number">8</span>, <span class="comment">#图表大小(自动调整为正方形))</span></span><br><span class="line">              ratio = <span class="number">5</span>, <span class="comment">#散点图与布局图高度比，整型</span></span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGatyD.png" alt=""></p><h6 id="4-3-密度图"><a href="#4-3-密度图" class="headerlink" title="4.3 密度图"></a>4.3 密度图</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据</span></span><br><span class="line">rs = np.random.RandomState(<span class="number">15</span>)</span><br><span class="line">df = pd.DataFrame(rs.randn(<span class="number">300</span>,<span class="number">2</span>), columns = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="comment">#创建密度图</span></span><br><span class="line">g = sns.jointplot(</span><br><span class="line">      x = df[<span class="string">&#x27;A&#x27;</span>], y = df[<span class="string">&#x27;B&#x27;</span>], </span><br><span class="line">                  data = df,</span><br><span class="line">                  kind = <span class="string">&#x27;kde&#x27;</span>,</span><br><span class="line">                  color = <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">                  shade_lowest = <span class="literal">False</span></span><br><span class="line">                 )</span><br><span class="line"><span class="comment">#添加散点图</span></span><br><span class="line">g.plot_joint(plt.scatter, c = <span class="string">&#x27;w&#x27;</span>, s = <span class="number">30</span>, linewidth = <span class="number">1</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGaJSK.png" alt=""></p><h3 id="五、heatmap"><a href="#五、heatmap" class="headerlink" title="五、heatmap( )"></a>五、heatmap( )</h3><p>热力图可以体现数据集中特征的两两关系。简单地说，可以反应协方差矩阵。</p><blockquote><p>seaborn.heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt=’.2g’, annot<em>kws=None, linewidths=0, linecolor=’white’, cbar=True, cbar</em>kws=None, cbar_ax=None, square=False, ax=None, xticklabels=True, yticklabels=True, mask=None, **kwargs)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.rand(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment"># annot设置数字显示，linewidths设置小方格之间的线宽，vmin和vmax设置上下界</span></span><br><span class="line">sns.heatmap(data,annot=<span class="literal">True</span>,linewidths=<span class="number">0.5</span>,vmin=<span class="number">0</span>,vmax=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGdMjS.png" alt=""></p><h3 id="六、pairplot"><a href="#六、pairplot" class="headerlink" title="六、pairplot( )"></a>六、pairplot( )</h3><blockquote><p>seaborn.pairplot(data, hue=None, hue_order=None, palette=None, vars=None, x_vars=None, y_vars=None, kind=’scatter’, diag_kind=’auto’, markers=None, height=2.5, aspect=1, dropna=True, plot_kws=None, diag_kws=None, grid_kws=None, size=None)</p></blockquote><h6 id="6-1-普通矩阵图示意"><a href="#6-1-普通矩阵图示意" class="headerlink" title="6.1 普通矩阵图示意"></a>6.1 普通矩阵图示意</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(<span class="string">&#x27;iris&#x27;</span>)</span><br><span class="line">sns.pairplot(</span><br><span class="line">     iris,</span><br><span class="line">             kind = <span class="string">&#x27;scatter&#x27;</span>, <span class="comment">#散点图/回归分布图&#123;&#x27;scatter&#x27;, &#x27;reg&#x27;&#125;)</span></span><br><span class="line">             diag_kind = <span class="string">&#x27;hist&#x27;</span>, <span class="comment">#直方图/密度图&#123;&#x27;hist&#x27;， &#x27;kde&#x27;&#125;</span></span><br><span class="line">             hue = <span class="string">&#x27;species&#x27;</span>,   <span class="comment">#按照某一字段进行分类</span></span><br><span class="line">             palette = <span class="string">&#x27;husl&#x27;</span>,  <span class="comment">#设置调色板</span></span><br><span class="line">             markers = [<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], <span class="comment">#设置不同系列的点样式（这里根据参考分类个数）</span></span><br><span class="line">             height = <span class="number">2</span>  <span class="comment">#图标大小</span></span><br><span class="line">             )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGwJqe.png" alt=""></p><h6 id="6-2-提取局部变量进行对比"><a href="#6-2-提取局部变量进行对比" class="headerlink" title="6.2 提取局部变量进行对比"></a>6.2 提取局部变量进行对比</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(</span><br><span class="line">             iris, </span><br><span class="line">             <span class="built_in">vars</span> = [<span class="string">&#x27;sepal_width&#x27;</span>, <span class="string">&#x27;sepal_length&#x27;</span>],</span><br><span class="line">             kind = <span class="string">&#x27;reg&#x27;</span>, </span><br><span class="line">             diag_kind = <span class="string">&#x27;kde&#x27;</span>,</span><br><span class="line">             hue = <span class="string">&#x27;species&#x27;</span>, </span><br><span class="line">             palette = <span class="string">&#x27;husl&#x27;</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EGwGrD.png" alt=""></p><h3 id="七、violinplot"><a href="#七、violinplot" class="headerlink" title="七、violinplot()"></a>七、violinplot()</h3><p>violinplot与boxplot扮演类似的角色，它显示了定量数据在一个（或多个）分类变量的多个层次上的分布，这些分布可以进行比较。不像箱形图中所有绘图组件都对应于<strong>实际数据点</strong>，小提琴绘图以基础分布的<strong>核密度估计</strong>为特征。具体用法如下：</p><blockquote><p>seaborn.violinplot(x=None, y=None, hue=None, data=None, order=None, hue_order=None, bw=’scott’, cut=2, scale=’area’, scale_hue=True, gridsize=100, width=0.8, inner=’box’, split=False, dodge=True, orient=None, linewidth=None, color=None, palette=None, saturation=0.75, ax=None, **kwargs)</p></blockquote><h6 id="7-1-小提琴图指定类别"><a href="#7-1-小提琴图指定类别" class="headerlink" title="7.1 小提琴图指定类别"></a>7.1 小提琴图指定类别</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(<span class="string">&#x27;tips&#x27;</span>)</span><br><span class="line">sns.violinplot(</span><br><span class="line">       x = <span class="string">&#x27;day&#x27;</span>, y = <span class="string">&#x27;total_bill&#x27;</span>, <span class="comment"># x,y轴名字</span></span><br><span class="line">               data = tips,</span><br><span class="line">               linewidth = <span class="number">2</span>, <span class="comment">#线宽</span></span><br><span class="line">               width = <span class="number">0.8</span>,   <span class="comment">#箱之间的间隔比例</span></span><br><span class="line">               palette = <span class="string">&#x27;hls&#x27;</span>, <span class="comment">#设置调色板</span></span><br><span class="line">               order = &#123;<span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>,<span class="string">&#x27;Sun&#x27;</span>&#125;, <span class="comment">#筛选类别</span></span><br><span class="line">               scale = <span class="string">&#x27;count&#x27;</span>,  <span class="comment">#测度小提琴图的宽度： area-面积相同,count-按照样本数量决定宽度,width-宽度一样</span></span><br><span class="line">               gridsize = <span class="number">50</span>, <span class="comment">#设置小提琴图的平滑度，越高越平滑</span></span><br><span class="line">               inner = <span class="string">&#x27;box&#x27;</span>, <span class="comment">#设置内部显示类型 --&gt; &#x27;box&#x27;,&#x27;quartile&#x27;,&#x27;point&#x27;,&#x27;stick&#x27;,None</span></span><br><span class="line">               <span class="comment">#bw = 0.8      #控制拟合程度，一般可以不设置</span></span><br><span class="line">               )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EG08Wq.png" alt=""></p><h6 id="7-2-小提琴图通过hue分类"><a href="#7-2-小提琴图通过hue分类" class="headerlink" title="7.2 小提琴图通过hue分类"></a>7.2 小提琴图通过hue分类</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(</span><br><span class="line">               x = <span class="string">&#x27;day&#x27;</span>, y = <span class="string">&#x27;total_bill&#x27;</span>, </span><br><span class="line">               data = tips,</span><br><span class="line">               hue = <span class="string">&#x27;smoker&#x27;</span>, </span><br><span class="line">               palette = <span class="string">&#x27;muted&#x27;</span>,</span><br><span class="line">               split = <span class="literal">True</span>, <span class="comment">#设置是否拆分小提琴图</span></span><br><span class="line">               inner = <span class="string">&#x27;box&#x27;</span></span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/04/30/EG0tyT.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Modules </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习日记(三):浅谈L1正则化与L2正则化</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%89-%E6%B5%85%E8%B0%88L1%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%89-%E6%B5%85%E8%B0%88L1%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>监督学习问题无非就是在规则化参数的同时最小化误差。最小化误差是为了让我们的模型拟合我们的训练数据，而规则化参数是为了防止我们的模型过分拟合我们的训练数据。</strong> 因为参数太多，会导致我们的模型复杂度上升，容易产生过拟合，也就是我们的训练误差会很小。但训练误差小并不是我们的最终目标，我们的目标是希望模型的测试误差小，也就是能准确的预测新的样本。所以，我们需要保证模型在“简单”的基础上最小化训练误差，这样得到的参数才具有较好的泛化性能，而模型“简单”就是通过规则函数来实现的。另外，规则项的使用还可以约束我们的模型的特性。这样就可以将人对这个模型的先验知识融入到模型的学习当中，强行地让学习到的模型具有人想要的特性，例如稀疏、低秩、平滑等等。要知道，有时候人的先验是非常重要的。前人的经验会让你少走很多弯路，这就是为什么我们平时学习最好找个大牛带带的原因，一句点拨可以为我们拨开眼前乌云，还我们一片晴空万里，醍醐灌顶。对机器学习也是一样，如果被我们人稍微点拨一下，它肯定能更快的学习相应的任务。只是由于人和机器的交流目前还没有那么直接的方法，目前这个媒介只能由规则项来担当了。</p><span id="more"></span><h3 id="一、欠拟合与过拟合"><a href="#一、欠拟合与过拟合" class="headerlink" title="一、欠拟合与过拟合"></a>一、欠拟合与过拟合</h3><p><img src="https://s2.ax1x.com/2019/04/23/EAxlMq.png" alt=""></p><ul><li><p><strong>欠拟合</strong>：所建的机器学习模型在训练数据上表现不佳。</p></li><li><p><strong>过拟合</strong>：所建的机器学习模型在训练样本中表现得过于优越，导致在测试数据集中表现不佳。</p></li></ul><p>回想下我们的模型，假如我们采用梯度下降算法将模型中的损失函数不断减少，那么最终我们会在一定范围内求出最优解，最后损失函数不断趋近0。那么我们可以在所定义的损失函数后面加入一项永不为0的部分，那么最后经过不断优化，损失函数还是会存在。其实这就是所谓的“正则化”。</p><p>一般来说，监督学习可以看做最小化下面的目标函数：</p><script type="math/tex; mode=display">\omega^{*}=arg\mathop{min}\limits_{\omega}\sum_iL(y_i,f(x_i,\omega))+\lambdaΩ(\omega)</script><p>其中，$\sum_iL(y_i,f(x_i,\omega))$ 是我们的损失函数，$Ω(\omega)$ 是我们的正则化项。</p><p>常见的正则化方法包括L1正则化和L2正则化。</p><h3 id="二、什么是范数"><a href="#二、什么是范数" class="headerlink" title="二、什么是范数"></a>二、什么是范数</h3><p>我们知道距离的定义是一个宽泛的概念，只要满足非负、自反、三角不等式就可以称之为距离。<strong>范数是一种强化了的距离概念，它在定义上比距离多了一条数乘的运算法则。有时候为了便于理解，我们可以把范数当作距离来理解。</strong></p><p>在数学上，<strong>范数包括向量范数和矩阵范数，向量范数表征向量空间中向量的大小，矩阵范数表征矩阵引起变化的大小</strong>。一种非严密的解释就是，对应向量范数，向量空间中的向量都是有大小的，这个大小如何度量，就是用范数来度量的，不同的范数都可以来度量这个大小，就好比米和尺都可以来度量远近一样；对于矩阵范数，我们知道，通过运算 $AX=B$，可以将向量 $X$ 变化为 $B$，矩阵范数就是来度量这个变化大小的。</p><p>这里简单地介绍以下几种向量范数的定义和含义。</p><h4 id="2-1-L-P范数"><a href="#2-1-L-P范数" class="headerlink" title="2.1 L-P范数"></a>2.1 L-P范数</h4><p>L-P范数不是一个范数，而是一组范数，其定义如下：</p><script type="math/tex; mode=display">L_p=||\omega||_p=(\sum_{i=1}^n|\omega_i|^p)^{\frac{1}{p}}</script><p>根据P 的变化，范数也有着不同的变化，一个经典的有关P范数的变化图如下：</p><p><img src="https://s2.ax1x.com/2019/04/23/EEpJdf.png" alt=""></p><p>上图表示了p从无穷到0变化时，三维空间中到原点的距离（范数）为1的点构成的图形的变化情况。</p><h4 id="2-2-L0范数"><a href="#2-2-L0范数" class="headerlink" title="2.2 L0范数"></a>2.2 L0范数</h4><p>当P=0时，也就是L0范数，由上面可知，L0范数并不是一个真正的范数，它主要被用来度量向量中非零元素的个数。用上面的L-P定义可以得到L-0的定义为：</p><script type="math/tex; mode=display">||\omega||_0=(\sum_{i=1}^n|\omega_i|^0)^{\frac{1}{0}}</script><p>这里就有点问题了，我们知道非零元素的零次方为1，但零的零次方，非零数开零次方都不知道是什么，很不好说明L0的意义，所以在通常情况下，大家都用来表示向量 $x$ 中非零元素的个数。</p><h4 id="2-3-L1范数"><a href="#2-3-L1范数" class="headerlink" title="2.3 L1范数"></a>2.3 L1范数</h4><p>L1范数是我们经常见到的一种范数，它的定义如下：</p><script type="math/tex; mode=display">||\omega||_1=\sum_{i=1}^n|\omega_i|</script><p><strong>表示向量 $x$ 中非零元素的绝对值之和。</strong></p><p>对于L1范数，它的优化问题如下：</p><script type="math/tex; mode=display">min\ \ ||\omega||_1</script><p>由于L1范数的天然性质，对L1优化的解是一个<strong>稀疏解</strong>，因此L1范数也被叫做稀疏规则算子。<strong>通过L1可以实现特征的稀疏</strong>，去掉一些没有信息的特征。例如在对用户的电影爱好做分类的时候，用户有100个特征，可能只有十几个特征是对分类有用的，大部分特征如身高体重等可能都是无用的，利用L1范数就可以过滤掉。</p><h4 id="2-4-L2范数"><a href="#2-4-L2范数" class="headerlink" title="2.4 L2范数"></a>2.4 L2范数</h4><p>L2范数是我们最常见最常用的范数了，我们用的最多的欧氏距离就是一种L2范数，它的定义如下：</p><script type="math/tex; mode=display">||\omega||_2=\sqrt{\sum_{i=1}^n|\omega_i|^2}</script><p><strong>表示向量 $x$ 元素的平方和再开平方。</strong></p><p><strong>L2范数通常会被用来做优化目标函数的正则化项，防止模型为了迎合训练集而过于复杂造成的过拟合情况，从而提高模型的泛化能力。</strong></p><h3 id="三、L1正则化"><a href="#三、L1正则化" class="headerlink" title="三、L1正则化"></a>三、L1正则化</h3><script type="math/tex; mode=display">\omega^{*}=arg\mathop{min}\limits_{\omega}\sum_iL(y_i,f(x_i,\omega))+\lambda||\omega||_1</script><p>从上面的分析中我们可以了解到L1正则化可以实现稀疏。但为什么要稀疏？让我们的参数稀疏有什么好处呢？</p><ul><li><p>特征选择(Feature Selection)：</p><ul><li>大家对稀疏规则化趋之若鹜的一个关键原因在于它能实现特征的自动选择。一般来说，$x_i$ 的大部分元素（也就是特征）都是和最终的输出 $y_i$ 没有关系或者不提供任何信息的，在最小化目标函数的时候考虑 $x_i$ 这些额外的特征，虽然可以获得更小的训练误差，但在预测新的样本时，这些没用的信息反而会被考虑，从而干扰了对正确 $y_i$ 的预测。稀疏规则化算子的引入就是为了完成特征自动选择的光荣使命，它会学习地去掉这些没有信息的特征，也就是把这些特征对应的权重置为0。</li></ul></li><li><p>可解释性(Interpretability)：</p><ul><li>另一个青睐于稀疏的理由是，模型更容易解释。例如患某种病的概率是 $y$ ，然后我们收集到的数据 $x$ 是1000维的，也就是我们需要寻找这1000种因素到底是怎么影响患上这种病的概率的。假设我们这个是回归模型：$y=\omega_1*x_1+\omega_2*x_2+\ldots+\omega_{1000}*x_{1000}+b$ 。通过学习，如果最后学习到的 $\omega^{*}$ 就只有很少的非零元素，例如只有5个非零的 $\omega_i$，那么我们就有理由相信，这些对应的特征在患病分析上面提供的信息是巨大的。也就是说，患不患这种病只和这5个因素有关，那医生就好分析多了。但如果1000个 $\omega_i$ 都非0，医生面对这1000种因素，累觉不爱。</li></ul></li></ul><h3 id="四、L2正则化"><a href="#四、L2正则化" class="headerlink" title="四、L2正则化"></a>四、L2正则化</h3><script type="math/tex; mode=display">\omega^{*}=arg\mathop{min}\limits_{\omega}\sum_iL(y_i,f(x_i,\omega))+\lambda||\omega||_2</script><p><strong>L2正则化的强大功效是改善机器学习里面一个非常重要的问题：过拟合。</strong> 至于过拟合是什么，上面也解释了，就是模型训练时候的误差很小，但在测试的时候误差很大，也就是我们的模型复杂到可以拟合到我们的所有训练样本了，但在实际预测新的样本的时候，糟糕的一塌糊涂。通俗的讲就是应试能力很强，实际应用能力很差。擅长背诵知识，却不懂得灵活利用知识。</p><p><strong>为什么L2能防止过拟合呢？</strong> 过拟合的时候，拟合函数的系数往往非常大，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。我们让L2范数的规则项 $||\omega||_2$ 最小，可以使得 $\omega$ 的每个元素都很小，都接近于0，但与L1范数不同，<strong>它不会让它等于0，而是接近于0</strong>。而越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象。</p><h3 id="五、L1、L2正则化直观解释"><a href="#五、L1、L2正则化直观解释" class="headerlink" title="五、L1、L2正则化直观解释"></a>五、L1、L2正则化直观解释</h3><p><img src="https://s2.ax1x.com/2019/04/23/EEiitK.jpg" alt=""></p><center><p><b>左图为L1正则化，右图为L2正则化</b></p></center><p>为了更加直观的了解为什么L1正则化可以实现稀疏、L2正则化可以有效防止过拟合，这里我们只考虑二维的情况，即只有两个权值 $\omega_1,\omega_2$。</p><p><strong>此时 $L1=|\omega_1|+|\omega_2|$，在图像上表现为菱形。而$L2=\omega_1^2+\omega_2^2$，在图像上表现为圆。</strong></p><p>当我们每次取一组 $\omega_1,\omega_2$ 时，代价函数都会有对应的输出值。我们将代价函数的值用<strong>等值线</strong>来表示。最内层的等值线（图中表现为紫色）即最优化的结果。</p><p><strong>再来回顾一下我们的目标：我们现在的目标是不仅原曲线的值要小（越来越接近中心的紫色圈圈），还要使得这个菱形或圆越小越好。</strong> 那么还和原来一样的话，过中心紫色圈圈的那个菱形明显很大，因此我们要取到一个恰好的值。那么如何求值呢？</p><center><img src=https://s2.ax1x.com/2019/04/23/EEiPk6.jpg /></center><p>以同一条原曲线目标等值线来说，现在以最外圈的红色等值线为例，我们看到，对于红色曲线上的每个点都可以做一个菱形，根据上图可知，<strong>当这个菱形与某条等值线相切</strong>（仅有一个交点）的时候，这个菱形最小，对比上图相割的较大的两个菱形对应的1范数更大。</p><p>有了上面的说明，我们可以看出，最终加入L1范数得到的解，一定是某个菱形和某条原函数等值线的切点。现在有个比较重要的结论来了，我们经过观察可以看到，几乎对于很多原函数的等值曲线，<strong>和某个菱形相切的时候及其容易相交在坐标轴</strong>（比如上图）。也就是说最终的结果，解的某些维度及其容易是0，比如上图最终解是 $\omega = (0，x)$ ，<strong>这也就是我们所说的L1更容易得到稀疏解（解向量中0比较多）的原因。</strong></p><p><strong>(注:以上分析仅从直观上理解，有关具体证明可参考Google、baidu)</strong></p><p>当加入L2正则化的时候，分析和L1正则化是类似的，也就是说我们仅仅是从菱形变成了圆形而已，同样还是求原曲线和圆形的切点作为最终解。当然与L1范数比，我们这样求的L2范数的从图上来看，<strong>不容易交在坐标轴上，但是仍然比较靠近坐标轴</strong>。因此这也就是我们所说的，L2范数能让解比较小（靠近0），但是比较平滑（不等于0）。</p><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><p><a href="https://blog.csdn.net/jinping_shi/article/details/52433975">机器学习中正则化项L1和L2的直观理解</a></p></li><li><p><a href="https://blog.csdn.net/zouxy09/article/details/24971995">机器学习中的范数规则化之（一）L0、L1与L2范数</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/35356992">L1正则化与L2正则化</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习日记(二):批量梯度下降(BGD)、随机梯度下降(SGD)、小批量梯度下降(MBGD)</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-BGD-%E3%80%81%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-SGD-%E3%80%81%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-MBGD.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-BGD-%E3%80%81%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-SGD-%E3%80%81%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-MBGD.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>梯度下降法作为机器学习中较常使用的优化算法，其有着三种不同的形式：<strong>批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）以及小批量梯度下降（Mini-Batch Gradient Descent）</strong>。其中小批量梯度下降法也常用在深度学习中进行模型的训练。接下来，我们将对这三种不同的梯度下降法进行理解。</p><p>为了便于理解，这里我们将使用只含有<strong>一个特征</strong>的线性回归来展开。此时线性回归的<strong>假设函数</strong>为：</p><script type="math/tex; mode=display">h_{\theta}(x^{(i)})=\theta_1x^{(i)}+\theta_0</script><p>其中，$i=1,2,\ldots,m$ 表示样本数。</p><p>对应的<strong>目标函数（代价函数）</strong> 即为：</p><script type="math/tex; mode=display">J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2</script><span id="more"></span><h3 id="一、批量梯度下降（Batch-Gradient-Descent，BGD）"><a href="#一、批量梯度下降（Batch-Gradient-Descent，BGD）" class="headerlink" title="一、批量梯度下降（Batch Gradient Descent，BGD）"></a>一、批量梯度下降（Batch Gradient Descent，BGD）</h3><p><strong>批量梯度下降法</strong>是最原始的形式，它是指在<strong>每一次迭代</strong>时使用<strong>所有样本</strong>来进行梯度的更新。从数学上理解如下：</p><p>（1）对目标函数求偏导：</p><script type="math/tex; mode=display">\nabla J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>其中，$i=1,2,\ldots,m$ 表示样本数，$j=0,1$ 表示特征数。这里我们使用了偏置项 $x_0^{(i)}=1$。</p><p>（2）每次迭代对参数进行更新：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}</script><p><strong>注意这里更新时存在一个求和函数，即为对所有样本进行计算处理，可与下文SGD法进行比较。</strong></p><p>伪代码形式为：</p><blockquote><p>repeat{<br> 　　　$\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}$<br>　　　(for j=0,1)<br>}</p></blockquote><p><strong>优点：</strong></p><ul><li>一次迭代是对所有样本进行计算，此时利用矩阵进行操作，实现了并行。</li><li>由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。当目标函数为凸函数时，BGD一定能够得到全局最优。</li></ul><p><strong>缺点：</strong></p><ul><li>当样本数目 $m$ 很大时，每迭代一步都需要对所有样本计算，训练过程会很慢。</li><li>从迭代的次数上来看，BGD迭代的次数相对较少。</li></ul><h3 id="二、随机梯度下降（Stochastic-Gradient-Descent，SGD）"><a href="#二、随机梯度下降（Stochastic-Gradient-Descent，SGD）" class="headerlink" title="二、随机梯度下降（Stochastic Gradient Descent，SGD）"></a>二、随机梯度下降（Stochastic Gradient Descent，SGD）</h3><p><strong>随机梯度下降法</strong>不同于批量梯度下降，随机梯度下降是<strong>每次迭代</strong>使用<strong>一个样本</strong>来对参数进行更新。使得训练速度加快。</p><p>对于<strong>一个样本</strong>的目标函数为：</p><script type="math/tex; mode=display">J(\theta_0,\theta_1)=\frac{1}{2}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>（1）对目标函数求偏导：</p><script type="math/tex; mode=display">\nabla J(\theta_0,\theta_1)=(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>（2）参数更新：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}</script><p><strong>注意，这里不再有求和符号</strong></p><p>伪代码形式为：</p><blockquote><p>repeat{<br>　　　for i=1,2,…m{<br>　　　 　　$\theta_j:=\theta_j-\alpha(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}$<br>　　　　　(for j=0,1)<br>　　　}<br>}</p></blockquote><p><strong>优点：</strong></p><ul><li>由于不是在全部训练数据上的损失函数，而是在每轮迭代中，随机优化某一条训练数据上的损失函数，这样每一轮参数的更新速度大大加快。</li></ul><p><strong>缺点：</strong></p><ul><li>准确度下降。由于即使在目标函数为强凸函数的情况下，SGD仍旧无法做到线性收敛。</li><li>可能会收敛到局部最优，由于单个样本并不能代表全体样本的趋势。</li><li>不易于并行实现。</li></ul><h3 id="三、小批量梯度下降（Mini-Batch-Gradient-Descent-MBGD）"><a href="#三、小批量梯度下降（Mini-Batch-Gradient-Descent-MBGD）" class="headerlink" title="三、小批量梯度下降（Mini-Batch Gradient Descent, MBGD）"></a>三、小批量梯度下降（Mini-Batch Gradient Descent, MBGD）</h3><p><strong>小批量梯度下降</strong>，是对批量梯度下降以及随机梯度下降的一个折中办法。其思想是：每次迭代 使用 <strong>batch_size</strong> 个样本来对参数进行更新。</p><p>这里我们假设 $batchsize=10$ ，样本数 $m$ =1000。</p><p>伪代码形式为：</p><blockquote><p>repeat{<br>　　　　for i=1,11,21,31,…,991{<br>　　　　$\theta_j:=\theta_j-\alpha\frac{1}{10}\sum_{k=i}^{i+9}(h_{\theta}(x^{(k)})-y^{(k)})x_j^{(k)}$<br>　　　　(for j =0,1)<br>　　　　}<br>}</p></blockquote><p><strong>优点：</strong></p><ul><li>通过矩阵运算，每次在一个batch上优化神经网络参数并不会比单个数据慢太多。</li><li>每次使用一个batch可以大大减小收敛所需要的迭代次数，同时可以使收敛到的结果更加接近梯度下降的效果。</li><li>可实现并行化。</li></ul><p><strong>缺点：</strong></p><ul><li>$batchsize$ 的不当选择可能会带来一些问题。</li></ul><p><strong>$batchsize$ 的选择带来的影响：</strong></p><ul><li><p>在合理地范围内，增大 $batchsize$ 的好处</p><ul><li>内存利用率提高了，大矩阵乘法的并行化效率提高。</li><li>跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。</li><li>在一定范围内，一般来说 $batchsize$ 越大，其确定的下降方向越准，引起训练震荡越小。</li></ul></li><li><p>盲目增大batch_size的坏处：</p><ul><li>内存利用率提高了，但是内存容量可能撑不住了。</li><li>跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。</li><li>$batchsize$ 增大到一定程度，其确定的下降方向已经基本不再变化。</li></ul></li></ul><hr><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://www.cnblogs.com/lliuye/p/9451903.html">https://www.cnblogs.com/lliuye/p/9451903.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习日记(一):从零认识逻辑回归</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%80-%E4%BB%8E%E9%9B%B6%E8%AE%A4%E8%AF%86%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%80-%E4%BB%8E%E9%9B%B6%E8%AE%A4%E8%AF%86%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>分类技术是机器学习和数据挖掘应用中的重要组成部分。在数据科学中，大约70%的问题属于分类问题。解决分类问题的算法也有很多种，比如：KNN算法，使用距离计算来实现分类；决策树，通过构建直观易懂的树来实现分类；朴素贝叶斯，使用概率论构建分类器。<strong>本篇谈到的是Logistic回归，它是一种很常见的用来解决二元分类问题的方法。</strong></p><p><strong>逻辑回归(Logistic Regression,简称LR)，虽然它的名字中带有“回归”两个字，但是它最擅长处理的却是分类问题。</strong> LR分类器适用于各项广义上的分类任务，例如：评论信息的正负情感分析（二分类）、用户点击率（二分类）、用户违约信息预测（二分类）、垃圾邮件检测（二分类）、疾病预测（二分类）、用户等级分类（多分类）等场景。我们这里主要讨论的是二分类问题，<strong>解决了二分类自然就解决了多分类，因为N分类问题可以转化成N个二分类问题。</strong></p><span id="more"></span><hr><h3 id="一、线性回归（Linear-Regression）"><a href="#一、线性回归（Linear-Regression）" class="headerlink" title="一、线性回归（Linear Regression）"></a>一、线性回归（Linear Regression）</h3><p>线性回归的表达式：</p><script type="math/tex; mode=display">f(\bf{x})=\pmb{\omega^{T}x}+b</script><p>线性回归对于给定的输入 $x$，输出的是一个数值 $y$，因此它是一个解决回归问题的模型。</p><p>为了消除掉后面的常数项b，我们可以令 $x^{‘}=[1\ \ x]^{T}$，同时 $\omega^{‘}=[b\ \ w]^T$ ，直线方程可以化简成为：</p><script type="math/tex; mode=display">f(\bf{x^{'}})=\pmb{\omega^{'}x^{'}}</script><p>在接下来的文章中为了方便，我们所使用的 $\omega,x$ 其实指代的是 $\omega^{‘},x^{‘}$。</p><h3 id="二、如何用连续的数值去预测离散的标签值"><a href="#二、如何用连续的数值去预测离散的标签值" class="headerlink" title="二、如何用连续的数值去预测离散的标签值"></a>二、如何用连续的数值去预测离散的标签值</h3><p>线性回归的输出是一个数值，而不是一个标签，显然不能直接解决二分类问题。那我如何改进我们的回归模型来预测标签呢？</p><p>一个最直观的办法就是设定一个阈值，比如0。如果我们预测的数值 y&gt;0 ，那么属于标签A，反之属于标签B，采用这种方法的模型又叫做<strong>感知机（Perceptron）</strong>。</p><p>另一种方法，我们不去直接预测标签，而是去预测标签为A概率，我们知道概率是一个[0,1]区间的连续数值，那我们的输出的数值就是标签为A的概率。一般的如果标签为A的概率大于0.5，我们就认为它是A类，否则就是B类。这就是我们的这次的主角<strong>逻辑回归模型 (Logistics Regression)</strong>。</p><h3 id="三、逻辑回归（logistics-regression）"><a href="#三、逻辑回归（logistics-regression）" class="headerlink" title="三、逻辑回归（logistics regression）"></a>三、逻辑回归（logistics regression）</h3><p>通过以上分析，我们明确了预测目标是标签为A的概率。</p><p>我们知道，概率是属于[0,1]区间。但是线性模型 $f(x) = \omega^Tx$ 值域是 $(-\infty,\infty)$。</p><p>我们不能直接基于线性模型建模。我们需要找到一个模型的值域刚好在[0,1]区间，同时要足够好用。</p><p>于是，选择了我们的<strong>sigmoid函数</strong>：</p><script type="math/tex; mode=display">\sigma(x)=\frac{1}{1+e^{-x}}</script><p>函数图像为：</p><center><img src="https://pic3.zhimg.com/80/v2-ab82d755dba95f0585678fe2d4af28d6_hd.jpg"></center><p>但是我们不能直接拿sigmoid函数就用，毕竟它连要训练的参数 $\omega$ 都没有。</p><p>因此我们结合sigmoid函数，线性回归函数，把线性回归模型的输出作为sigmoid函数的输入。于是最后就变成了逻辑回归模型：</p><script type="math/tex; mode=display">y=\sigma(f(x))=\sigma(\omega^Tx)=\frac{1}{1+e^{-\pmb{\omega^Tx}}}</script><p>假设我们已经训练好了一组权值 $\omega^T$。只要把我们需要预测的 $x$ 代入到上面的方程，输出的y值就是这个标签为A的概率，我们就能够判断输入数据是属于哪个类别。</p><p>接下来就来详细介绍，如何利用一组采集到的真实样本，训练出参数 $\pmb{\omega}$ 的值。</p><h3 id="四、逻辑回归的损失函数（Loss-Function）"><a href="#四、逻辑回归的损失函数（Loss-Function）" class="headerlink" title="四、逻辑回归的损失函数（Loss Function）"></a>四、逻辑回归的损失函数（Loss Function）</h3><p>一个人工训练出来的模型是无法达到100%准确率的。因此我们需要一个东西来衡量模型训练的好坏。<strong>损失函数就是用来衡量模型的输出与真实输出的差别。</strong></p><p>下面就是逻辑回归的损失函数推导过程。</p><p>假设只有两个标签1和0，$y_n\in\{0,1\}$。我们把采集到的任何一组样本看做一个事件的话，那么这个事件发生的概率假设为p。我们的模型y的值等于标签为1的概率也就是p，即：</p><script type="math/tex; mode=display">P_{y=1}=\frac{1}{1+e^{-\omega^Tx}}=p</script><p>因为标签不是1就是0，因此标签为0的概率就是:</p><script type="math/tex; mode=display">P_{y=0}=1-p</script><p>我们把单个样本看做一个事件，那么这个事件发生的概率就是：</p><script type="math/tex; mode=display">P(y\ |\ x)=\begin{cases}p,&y=1 \cr 1-p,&y=0\end{cases}</script><p>这个函数不方便计算，它等价于:</p><script type="math/tex; mode=display">P(y_i\ |\ x_i)=p^{y_i}(1-p)^{1-y_i}</script><p>解释下这个函数的含义，我们采集到了一个样本 $(x_i,y_i)$ 。对这个样本，它的标签是 $y_i$ 的概率是 $p^{y_i}(1-p)^{1-{y_i}}$ 。（当y=1，结果是p；当y=0，结果是1-p）。</p><p>如果我们采集到了一组数据一共N个， $(x_1,y_1),(x_2,y_2),(x_3,y_3) \ldots (x_N,y_N)$ ，这个合成在一起的合事件发生的总概率怎么求呢？其实就是将每一个样本发生的概率相乘就可以了，即采集到这组样本的概率：</p><script type="math/tex; mode=display">P_总=P(y_1|x_1)P(y_2|x_2)\cdots P(y_n|x_n)=\prod_{n=1}^{N}p^{y_n}(1-p)^{(1-y_n)}</script><p><strong>注意 $P_总$ 是一个函数，并且未知的量只有 $\omega$（在p里面）。</strong></p><p>由于连乘很复杂，我们通过两边取对数来把连乘变成连加的形式，即：</p><script type="math/tex; mode=display">F(\omega)=ln(P_总)=ln(\prod_{n=1}^{N}p^{y_n}(1-p)^{(1-y_n)})</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad\quad=\sum_{n=1}^Nln(p^{y_n}(1-p)^{(1-y_n)})</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad=\sum_{n=1}^N(y_nln(p)+(1-y_n)ln(1-p))</script><p>其中，$p=\frac{1}{1+e^{-\omega^Tx}}$</p><p>这个函数 $F(\omega)$ 就叫做它的<strong>损失函数</strong>。损失函数可以理解成衡量我们当前的模型的输出结果，跟实际的输出结果之间的差距的一种函数。这里的损失函数的值等于事件发生的总概率，我们希望它越大越好。但是跟损失的含义有点儿违背，因此也可以在前面取个负号，<strong>最终的表达式</strong>如下所示（1/m表示均值化）：</p><script type="math/tex; mode=display">F(\omega)=-\frac{1}{m}\sum_{n=1}^m(y_nln(p)+(1-y_n)ln(1-p))</script><h3 id="五、极大似然估计MLE-Maximum-Likelihood-Estimation"><a href="#五、极大似然估计MLE-Maximum-Likelihood-Estimation" class="headerlink" title="五、极大似然估计MLE(Maximum Likelihood Estimation)"></a>五、极大似然估计MLE(Maximum Likelihood Estimation)</h3><p>我们在真实世界中并不能直接看到概率是多少，我们只能观测到事件是否发生。也就是说，我们只能知道一个样本它实际的标签是1还是0。那么我们如何估计参数 $\omega$ 跟 $b$ 的值呢？</p><p><strong>极大似然估计MLE</strong>(Maximum Likelihood Estimation)，就是一种估计参数 $\omega$ 的方法。在这里如何使用MLE来估计 $\omega$ 呢？</p><p>我们知道损失函数 $F(\omega)$ 是正比于总概率 $P_总$ 的，而 $F(\omega)$ 又只有一个变量 $\omega$ 。也就是说，通过改变  $\omega$ 的值，就能得到不同的总概率值 $P_总$ 。那么当我们选取的某个 $\omega^{*}$ 刚好使得总概率 $P_总$ 取得最大值的时候。我们就认为这个 $\omega^{*}$ 就是我们要求得的 $\omega$ 的值，这就是极大似然估计的思想。</p><p><strong>现在我们的问题变成了，找到一个 $\omega^*$ ，使得我们的总事件发生的概率，即损失函数 $F(\omega)$ 取得最大值</strong>，这句话用数学语言表达就是：</p><script type="math/tex; mode=display">\omega^*=arg\mathop{max}\limits_{\omega}F(\omega)=-arg\mathop{min}\limits_{\omega}F(\omega)</script><h3 id="六、梯度下降法"><a href="#六、梯度下降法" class="headerlink" title="六、梯度下降法"></a>六、梯度下降法</h3><p>由于极大似然函数无法直接求解，所以在机器学习算法中，在最小化损失函数时，可以通过<strong>梯度下降法</strong>来一步步的迭代求解，得到最小化的损失函数和模型参数值。</p><h4 id="6-1-梯度"><a href="#6-1-梯度" class="headerlink" title="6.1 梯度"></a>6.1 梯度</h4><p><strong>在微积分里面，对多元函数的参数求 $\delta$ 偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。</strong> 比如函数 $f(x,y)$ , 分别对 $x,y$ 求偏导数，求得的梯度向量就是 $(\delta f/\delta x,\delta f/\delta y)^T$，简称 $grad f(x,y)$ 或者 $\nabla f(x,y)$。对于在点 $x_0,y_0$ 的具体梯度向量就是 $(\delta f/\delta x_0,\delta f/\delta y_0)^T$ 或者 $\nabla f(x_0,y_0)$。</p><p>那么这个梯度向量求出来有什么意义呢？<strong>从几何意义上讲，就是函数变化增加最快的地方</strong>。具体来说，对于函数 $f(x,y)$ 在点  $x_0,y_0$  沿着梯度方向的向量就是 $f(x,y)$ 增加最快的地方。或者说沿着梯度向量的方向，更加容易找到函数的最大值；反过来说，沿着梯度向量相反的方向，也就是 $-(\delta f/\delta x_0,\delta f/\delta y_0)^T$ 的方向，梯度减少的最快，也就更容易找到函数的最小值。</p><h4 id="6-2-梯度下降的直观解释"><a href="#6-2-梯度下降的直观解释" class="headerlink" title="6.2 梯度下降的直观解释"></a>6.2 梯度下降的直观解释</h4><p>首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。</p><p>从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p><p><img src="https://s2.ax1x.com/2019/04/22/EkLNb4.png" alt=""></p><h4 id="6-3-梯度下降法描述"><a href="#6-3-梯度下降法描述" class="headerlink" title="6.3 梯度下降法描述"></a>6.3 梯度下降法描述</h4><h5 id="6-3-1-先决条件"><a href="#6-3-1-先决条件" class="headerlink" title="6.3.1 先决条件"></a>6.3.1 先决条件</h5><p>确认优化模型的假设函数和损失函数。</p><h5 id="6-3-2-算法相关参数初始化"><a href="#6-3-2-算法相关参数初始化" class="headerlink" title="6.3.2 算法相关参数初始化"></a>6.3.2 算法相关参数初始化</h5><p>主要是初始化 $\omega_0,\omega_1\cdots,\omega_n$，算法终止距离 $\varepsilon$ 和步长 $\alpha$。在没有任何先验知识的时候，我们比较倾向于将所有的 $\omega_i$ 初始化为0，将步长初始化为1，在调优的时候再进行优化。</p><h5 id="6-3-3-算法过程"><a href="#6-3-3-算法过程" class="headerlink" title="6.3.3 算法过程"></a>6.3.3 算法过程</h5><p>(1) 确定当前位置的损失函数的梯度，对于 $\omega_i$ ,其梯度表达式如下：</p><script type="math/tex; mode=display">\frac{\delta}{\delta\omega_i}J(\omega_0,\omega_1,\cdots,\omega_n)</script><p>(2) 用步长乘以损失函数的梯度，得到当前位置下降的距离，即 $\alpha\frac{\delta}{\delta\omega_i}J(\omega_0,\omega_1,\cdots,\omega_n)$,对应于前面登山过程中的某一步。<br>(3) 确定是否所有的 $\omega_i$ 梯度下降的距离都小于 $\varepsilon$，如果小于 $\varepsilon$ 则算法终止，当前所有的 $\omega_i$ 即为最终结果，否则进入步骤4。<br>(4) 更新所有的 $\omega_i$，对于 $\omega_i$，其更新表达式如下，更新完毕后继续转入步骤1。</p><script type="math/tex; mode=display">\omega_i=\omega_i-\alpha\frac{\delta}{\delta\omega_i}J(\omega_0,\omega_1,\cdots,\omega_n)</script><h3 id="七、求-F-omega-的梯度-nabla-F-omega"><a href="#七、求-F-omega-的梯度-nabla-F-omega" class="headerlink" title="七、求 $F(\omega)$ 的梯度 $\nabla F(\omega)$"></a>七、求 $F(\omega)$ 的梯度 $\nabla F(\omega)$</h3><p>先回顾一下p的公式：</p><script type="math/tex; mode=display">p=\frac{1}{1+e^{-\omega^Tx}}</script><p>再回顾一下 $F(\omega)$ 的公式：</p><script type="math/tex; mode=display">F(\omega)=-\frac{1}{m}\sum_{n=1}^m(y_nln(p)+(1-y_n)ln(1-p))</script><p>$p$ 是一个关于变量 $\omega$ 的函数，我们对 $p$ 求导，通过链式求导法则，慢慢展开可以得：</p><script type="math/tex; mode=display">p^{'}=(\frac{1}{1+e^{-\omega^Tx}})^{'}</script><script type="math/tex; mode=display">\qquad\qquad\quad\quad\qquad =-\frac{1}{(1+e^{-\omega^Tx})^{2}}\cdot(1+e^{-\omega^Tx})^{'}</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad=-\frac{1}{(1+e^{-\omega^Tx})^{2}}\cdot e^{-\omega^Tx}\cdot (-\omega^Tx)^{'}</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad\quad\quad=-\frac{1}{(1+e^{-\omega^Tx})^{2}}\cdot e^{-\omega^Tx}\cdot (-x)</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad=\frac{1}{1+e^{-\omega^Tx}}\cdot \frac{e^{-\omega^Tx}}{1+e^{-\omega^Tx}}\cdot x</script><script type="math/tex; mode=display">=p(1-p)x</script><p>上面都是我们做的准备工作，总之我们得记住：</p><script type="math/tex; mode=display">p^{'}=p(1-p)x</script><script type="math/tex; mode=display">(1-p)^{'}=-p(1-p)x</script><p>下面我们正式开始对 $F(\omega)$ 求导，求导的时候请始终记住，我们的变量只有 $\omega$，其他的什么 $y_n,x_n$ 都是已知的，可以看做常数。</p><script type="math/tex; mode=display">\nabla F(\omega)=-\frac{1}{m}\nabla(\sum_{n=1}^m(y_nln(p)+(1-y_n)ln(1-p)))</script><script type="math/tex; mode=display">\quad\quad=-\frac{1}{m}\sum_{n=1}^m(y_nln^{'}(p)+(1-y_n)ln^{'}(1-p))</script><script type="math/tex; mode=display">\quad\quad\quad\quad=-\frac{1}{m}\sum_{n=1}^m((y_n\frac{1}{p}p^{'})+(1-y_n)\frac{1}{1-p}(1-p)^{'})</script><script type="math/tex; mode=display">\quad=-\frac{1}{m}\sum_{n=1}^m(y_n(1-p)x_n-(1-y_n)px_n)</script><script type="math/tex; mode=display">=-\frac{1}{m}\sum_{n=1}^m(y_n-p)x_n</script><p>终于，我们求出了梯度 $\nabla F(\omega)$ 的表达式了，现在我们再来看看它长什么样子：</p><script type="math/tex; mode=display">\nabla F(\omega)=-\frac{1}{m}\sum_{n=1}^N(y_n-p)x_n</script><p>它是如此简洁优雅，这就是我们选取sigmoid函数的原因之一。当然我们也能够把 $p$ 再展开，即：</p><script type="math/tex; mode=display">\nabla F(\omega)=-\frac{1}{m}\sum_{n=1}^N(y_n-\frac{1}{1+e^{-\omega^Tx_n}})x_n</script><h3 id="八、更新系数-omega-i"><a href="#八、更新系数-omega-i" class="headerlink" title="八、更新系数 $\omega_i$"></a>八、更新系数 $\omega_i$</h3><p>梯度下降法共分为<strong>批量梯度下降（Batch Gradient Descent）、随机梯度下降（Stochastic Gradient Descent）和小批量梯度下降（Mini-Batch Gradient Descent）</strong>。</p><p>具体知识请参考我的另一篇博客：</p><blockquote><p><a href="http://qzmvc1.top/2019/04/23/%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-BGD-%E3%80%81%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-SGD-%E3%80%81%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-MBGD/">批量梯度下降(BGD)、随机梯度下降(SGD)、小批量梯度下降(MBGD)</a></p></blockquote><p>这里给出<strong>基于BGD梯度下降的公式</strong>：</p><script type="math/tex; mode=display">\omega_{i+1}=\omega_{i}-\alpha\nabla F(\omega)</script><script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad=\omega_{i}+\alpha\frac{1}{m}\sum_{n=1}^m(y_n-\frac{1}{1+e^{-\omega^Tx_n}})x_n</script><h3 id="九、逻辑回归与正则化"><a href="#九、逻辑回归与正则化" class="headerlink" title="九、逻辑回归与正则化"></a>九、逻辑回归与正则化</h3><p>有关L1正则化和L2正则化可以参考我的另一篇博客：</p><blockquote><p><a href="http://qzmvc1.top/2019/04/23/%E6%B5%85%E8%B0%88L1%E6%AD%A3%E5%88%99%E5%8C%96%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96/">浅谈L1正则化与L2正则化</a></p></blockquote><p>这里给出<strong>基于L2正则化的公式</strong>：</p><script type="math/tex; mode=display">F(\omega)=-\frac{1}{m}\sum_{n=1}^m(y_nln(p)+(1-y_n)ln(1-p))+\frac{\lambda}{2m}\sum_{j=1}^{k}\omega_j^2</script><h5 id="剩下的就是具体的敲代码了！"><a href="#剩下的就是具体的敲代码了！" class="headerlink" title="剩下的就是具体的敲代码了！"></a>剩下的就是具体的敲代码了！</h5><hr><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h5><blockquote><p><a href="https://zhuanlan.zhihu.com/p/44591359">逻辑回归 logistics regression 公式推导</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络常见激活函数简介</title>
      <link href="/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B.html"/>
      <url>/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先强烈推荐《Python神经网络编程》这本书！！通俗易懂而且两天左右就能看完！！</p><p>—————————————— 分割线 ——————————————</p><p><strong>激活函数是用来加入非线性因素的，提高神经网络对模型的表达能力，解决线性模型所不能解决的问题。</strong><br><span id="more"></span></p><hr><h3 id="一、常见的激活函数简介"><a href="#一、常见的激活函数简介" class="headerlink" title="一、常见的激活函数简介"></a>一、常见的激活函数简介</h3><h4 id="1-1-sigmod函数"><a href="#1-1-sigmod函数" class="headerlink" title="1.1 sigmod函数"></a>1.1 sigmod函数</h4><ul><li>函数表达式：</li></ul><script type="math/tex; mode=display">\sigma(x) = \frac{1}{1+e^{-x}}</script><ul><li>函数图像：<center><img src=https://s2.ax1x.com/2019/04/16/AvYowR.png /></center></li></ul><p>在sigmod函数中我们可以看到，其输出是在(0,1)这个开区间内，这点很有意思，可以联想到概率，但是严格意义上讲，不要当成概率。sigmod函数曾经是比较流行的，它可以想象成一个神经元的放电率，在中间斜率比较大的地方是神经元的敏感区，在两边斜率很平缓的地方是神经元的抑制区。</p><p>当然，流行也是曾经流行，这说明函数本身是有一定的缺陷的。</p><ul><li><p>当输入稍微远离了坐标原点，函数的梯度就变得很小了，几乎为零。在神经网络反向传播的过程中，我们都是通过微分的链式法则来计算各个权重W的微分的。当反向传播经过了sigmod函数，这个链条上的微分就很小很小了，况且还可能经过很多个sigmod函数，最后会导致权重W对损失函数几乎没影响，这样不利于权重的优化，这个问题叫做梯度饱和，也可以叫梯度弥散。</p></li><li><p>函数输出不是以0为中心的，这样会使权重更新效率降低。</p></li><li><p>sigmod函数要进行指数运算，这个对于计算机来说是比较慢的。</p></li></ul><h4 id="1-2-tanh函数"><a href="#1-2-tanh函数" class="headerlink" title="1.2 tanh函数"></a>1.2 tanh函数</h4><ul><li>函数表达式：</li></ul><script type="math/tex; mode=display">tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}</script><ul><li>函数图像：<center><img src=https://s2.ax1x.com/2019/04/16/AvYIm9.png /></center></li></ul><p>tanh是双曲正切函数，tanh函数和sigmod函数的曲线是比较相近的，我们来比较一下看看。首先相同的是，这两个函数在输入很大或是很小的时候，输出都几乎平滑，梯度很小，不利于权重更新；不同的是输出区间，tanh的输出区间是在(-1,1)之间，而且整个函数是以0为中心的，这个特点比sigmod的好。</p><p>一般二分类问题中，隐藏层用tanh函数，输出层用sigmod函数。不过这些也都不是一成不变的，具体使用什么激活函数，还是要根据具体的问题来具体分析，还是要靠调试的。</p><h4 id="1-3-ReLU函数"><a href="#1-3-ReLU函数" class="headerlink" title="1.3 ReLU函数"></a>1.3 ReLU函数</h4><ul><li><p>函数表达式：</p><script type="math/tex; mode=display">ReLU=max(0,x)</script></li><li><p>函数图像：</p><center><img src=https://s2.ax1x.com/2019/04/16/AvY4OJ.png /></center></li></ul><p>ReLU(Rectified Linear Unit)函数是目前比较火的一个激活函数，相比于sigmod函数和tanh函数，它有以下几个优点：</p><ul><li><p>在输入为正数的时候，不存在梯度饱和问题。</p></li><li><p>计算速度要快很多。ReLU函数只有线性关系，不管是前向传播还是反向传播，都比sigmod和tanh要快很多。</p></li></ul><p>当然，缺点也是有的：</p><ul><li><p>当输入是负数的时候，ReLU是完全不被激活的，这就表明一旦输入到了负数，ReLU就会死掉。这样在前向传播过程中，还不算什么问题，有的区域是敏感的，有的是不敏感的。但是到了反向传播过程中，输入负数，梯度就会完全到0，这个和sigmod函数、tanh函数有一样的问题。</p></li><li><p>我们发现ReLU函数的输出要么是0，要么是正数，这也就是说，ReLU函数也不是以0为中心的函数。</p></li></ul><h4 id="1-4-ELU函数"><a href="#1-4-ELU函数" class="headerlink" title="1.4 ELU函数"></a>1.4 ELU函数</h4><ul><li><p>函数表达式：</p><script type="math/tex; mode=display">ELU(x)=\begin{cases}x &x>0 \cr a(e^x-1) &x \leq 0\end{cases}</script></li><li><p>函数图像：</p><center><img src=https://s2.ax1x.com/2019/04/16/AvYhy4.png /></center></li></ul><p>ELU函数是针对ReLU函数的一个改进型，相比于ReLU函数，在输入为负数的情况下，是有一定的输出的，而且这部分输出还具有一定的抗干扰能力。这样可以消除ReLU死掉的问题，不过还是有梯度饱和和指数运算的问题。</p><h4 id="1-5-PReLU函数"><a href="#1-5-PReLU函数" class="headerlink" title="1.5 PReLU函数"></a>1.5 PReLU函数</h4><ul><li><p>函数表达式：</p><script type="math/tex; mode=display">PReLU(x)=max(ax,x)</script></li><li><p>函数图像：</p><center><img src=https://s2.ax1x.com/2019/04/16/AvYTT1.png /></center></li></ul><p>PReLU也是针对ReLU的一个改进型，在负数区域内，PReLU有一个很小的斜率，这样也可以避免ReLU死掉的问题。相比于ELU，PReLU在负数区域内是线性运算，斜率虽然小，但是不会趋于0，这算是一定的优势吧。</p><p>再看PReLU的公式，里面的参数 $\alpha$ 一般是取0~1之间的数，而且一般还是比较小的，如零点零几。当 $\alpha=0.01$ 时，我们叫PReLU为Leaky ReLU，算是PReLU的一种特殊情况吧。</p><p><strong>总体来看，这些激活函数都有自己的优点和缺点，没有一条说法表明哪些就是不行，哪些激活函数就是好的，所有的好坏都要自己去实验中得到。</strong></p><hr><p>参考链接：<a href="https://blog.csdn.net/kangyi411/article/details/78969642">https://blog.csdn.net/kangyi411/article/details/78969642</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>face_recognition实现摄像头实时人脸识别</title>
      <link href="/face-recognition%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.html"/>
      <url>/face-recognition%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><a href="https://face-recognition.readthedocs.io/en/latest/face_recognition.html#module-face_recognition.api">face_recognition document</a></p></blockquote><p>本篇博客使用 <code>OpenCV + face_recognition</code> 实现摄像头的实时人脸识别。有关环境配置请参考我的上一篇博客：<a href="http://qzmvc1.top/2019/04/15/Python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97face-recognition%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">Python人脸识别模块face_recognition之环境配置</a></p><h4 id="face-recognition简介"><a href="#face-recognition简介" class="headerlink" title="face_recognition简介"></a>face_recognition简介</h4><p>face_recognition是世界上最简单的人脸识别库了。你可以通过Python引用或者命令行的形式使用它，来管理和识别人脸。该软件包使用dlib中最先进的人脸识别深度学习算法，使得识别<strong>准确率在《Labled Faces in the world》测试基准下达到了99.38%</strong>。它同时提供了一个叫face_recognition的命令行工具，以便你可以用命令行对一个文件夹中的图片进行识别操作。</p><hr><span id="more"></span><h3 id="一、face-recognition详解"><a href="#一、face-recognition详解" class="headerlink" title="一、face_recognition详解"></a>一、face_recognition详解</h3><p><strong>（以下内容翻译自官方文档）</strong></p><h5 id="1-1-face-recognition-load-image-file（file，mode-’RGB’-）"><a href="#1-1-face-recognition-load-image-file（file，mode-’RGB’-）" class="headerlink" title="1.1 face_recognition.load_image_file（file，mode =’RGB’ ）"></a>1.1 face_recognition.load_image_file（file，mode =’RGB’ ）</h5><blockquote><p>解释:</p><ul><li>将图像文件（.jpg，.png等）加载到numpy数组中</li></ul><p>参数：</p><ul><li><p>file - 要加载的图像文件名或文件对象</p></li><li><p>mode - 将图像转换为的格式。仅支持“RGB”（8位RGB，3个通道）和“L”（黑色和白色）。</p></li></ul><p>返回：</p><ul><li>图像内容为numpy数组</li></ul></blockquote><h5 id="1-2-face-recognition-face-locations（img，number-of-times-to-upsample-1，model-’hog’-）"><a href="#1-2-face-recognition-face-locations（img，number-of-times-to-upsample-1，model-’hog’-）" class="headerlink" title="1.2 face_recognition.face_locations（img，number_of_times_to_upsample = 1，model =’hog’ ）"></a>1.2 face_recognition.face_locations（img，number_of_times_to_upsample = 1，model =’hog’ ）</h5><blockquote><p>解释：</p><ul><li>返回图像中人脸边界框的数组</li></ul><p>参数：</p><ul><li>img - 一个图像（作为一个numpy数组）</li><li>number_of_times_to_upsample - 对图像进行上采样以查找面部的次数。数字越大，面部越小。</li><li>model - 使用哪种人脸检测模型。“hog”不太准确，但在CPU上更快。“cnn”是一种更准确的深度学习模型，它是GPU / CUDA加速（如果可用）。默认为“hog”。</li></ul><p>返回：</p><ul><li>css（顶部，右侧，底部，左侧）顺序中找到的面部位置的元组列表</li></ul></blockquote><h5 id="1-3-face-recognition-face-landmarks（face-image，face-locations-None，model-’large’-）"><a href="#1-3-face-recognition-face-landmarks（face-image，face-locations-None，model-’large’-）" class="headerlink" title="1.3 face_recognition.face_landmarks（face_image，face_locations = None，model =’large’ ）"></a>1.3 face_recognition.face_landmarks（face_image，face_locations = None，model =’large’ ）</h5><blockquote><p>解释:</p><ul><li>给定图像，返回图像中每个面部的面部特征位置（眼睛，鼻子等）的字典</li></ul><p>参数：</p><ul><li>face_image - 要搜索的图像</li><li>face_locations - 可选择提供要检查的面部位置列表。</li><li>model - 可选 - 要使用的模型。“大”（默认）或 “小”（速度更快）。</li></ul><p>返回：</p><ul><li>面部特征位置（眼睛，鼻子等）的序列表</li></ul></blockquote><h5 id="1-4-face-recognition-face-encodings（face-image，known-face-locations-None，num-jitters-1-）"><a href="#1-4-face-recognition-face-encodings（face-image，known-face-locations-None，num-jitters-1-）" class="headerlink" title="1.4 face_recognition.face_encodings（face_image，known_face_locations = None，num_jitters = 1 ）"></a>1.4 face_recognition.face_encodings（face_image，known_face_locations = None，num_jitters = 1 ）</h5><blockquote><p>解释：</p><ul><li>给定图像，返回图像中每个面的128维面部编码。</li></ul><p>参数：</p><ul><li>face_image - 包含一个或多个面的图像</li><li>known_face_locations - 可选 - 如果您已经知道它们，则每个面的边界框。</li><li>num_jitters - 计算编码时重新采样面的次数。更高更准确，但更慢（即100慢100倍）</li></ul><p>返回：</p><ul><li>128维面部编码列表（图像中每个面部一个）</li></ul></blockquote><h5 id="1-5-face-recognition-api-face-distance（face-encodings，face-to-compare-）"><a href="#1-5-face-recognition-api-face-distance（face-encodings，face-to-compare-）" class="headerlink" title="1.5 face_recognition.api.face_distance（face_encodings，face_to_compare ）"></a>1.5 face_recognition.api.face_distance（face_encodings，face_to_compare ）</h5><blockquote><p>解释：</p><ul><li>给定面部编码列表，将它们与已知面部编码进行比较，并获得每个比较面部的欧氏距离。距离告诉您脸部的相似程度。</li></ul><p>参数：</p><ul><li>faces - 要比较的面部编码列表</li><li>face_to_compare - 要与之进行比较的面部编码</li></ul><p>返回：</p><ul><li>一个numpy ndarray，每个面的距离与’faces’数组的顺序相同</li></ul></blockquote><h5 id="1-6-face-recognition-api-compare-faces（known-face-encodings，face-encoding-to-check，tolerance-0-6-）"><a href="#1-6-face-recognition-api-compare-faces（known-face-encodings，face-encoding-to-check，tolerance-0-6-）" class="headerlink" title="1.6 face_recognition.api.compare_faces（known_face_encodings，face_encoding_to_check，tolerance = 0.6 ）"></a>1.6 face_recognition.api.compare_faces（known_face_encodings，face_encoding_to_check，tolerance = 0.6 ）</h5><blockquote><p>解释：</p><ul><li>将面部编码列表与候选编码进行比较，看它们是否匹配。</li></ul><p>参数：</p><ul><li>known_face_encodings - 已知面部编码的列表</li><li>face_encoding_to_check - 用于与列表进行比较的单面编码</li><li>tolerance - 面部之间的距离，将其视为匹配。越低越严格。0.6是典型的最佳性能。</li></ul><p>返回：</p><ul><li>True / False值的列表，指示哪个known_face_encodings与要检查的面部编码匹配</li></ul></blockquote><hr><h3 id="二、face-recognition代码阐述"><a href="#二、face-recognition代码阐述" class="headerlink" title="二、face_recognition代码阐述"></a>二、face_recognition代码阐述</h3><h4 id="2-1-在图片中识别人脸"><a href="#2-1-在图片中识别人脸" class="headerlink" title="2.1 在图片中识别人脸"></a>2.1 在图片中识别人脸</h4><p><img src="https://s2.ax1x.com/2019/04/15/Aj3h0P.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line">image=face_recognition.load_image_file(<span class="string">&quot;your_file.jpg&quot;</span>)</span><br><span class="line">face_locations=face_recognition.face_locations(image)</span><br></pre></td></tr></table></figure><h4 id="2-2-找到并操作图片中的脸部特征"><a href="#2-2-找到并操作图片中的脸部特征" class="headerlink" title="2.2 找到并操作图片中的脸部特征"></a>2.2 找到并操作图片中的脸部特征</h4><p>获得图片中人类眼睛、鼻子、嘴、下巴的位置和轮廓：</p><p><img src="https://s2.ax1x.com/2019/04/15/Aj34Tf.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line">image = face_recognition.load_image_file(<span class="string">&quot;your_file.jpg&quot;</span>)</span><br><span class="line">face_landmarks_list = face_recognition.face_landmarks(image)</span><br></pre></td></tr></table></figure><p>找到脸部特征有很多超级有用的应用场景，当然你也可以把它用在最显而易见的功能上：美颜功能，就像美图秀秀那样。</p><h4 id="2-3-鉴定图片中的脸"><a href="#2-3-鉴定图片中的脸" class="headerlink" title="2.3 鉴定图片中的脸"></a>2.3 鉴定图片中的脸</h4><p><img src="https://s2.ax1x.com/2019/04/15/Aj3fmt.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line">known_image=face_recognition.load_image_file(<span class="string">&quot;biden.jpg&quot;</span>)</span><br><span class="line">unknown_image=face_recognition.load_image_file(<span class="string">&quot;unknown.jpg&quot;</span>)</span><br><span class="line">biden_encoding=face_recognition.face_encodings(known_image)[<span class="number">0</span></span><br><span class="line">]unknown_encoding=face_recognition.face_encodings(unknown_image)[<span class="number">0</span>]</span><br><span class="line">results=face_recognition.compare_faces([biden_encoding],unknown_encoding)</span><br></pre></td></tr></table></figure><hr><h3 id="三、OpenCV-face-recognition-摄像头实时人脸识别"><a href="#三、OpenCV-face-recognition-摄像头实时人脸识别" class="headerlink" title="三、OpenCV+face_recognition 摄像头实时人脸识别"></a>三、OpenCV+face_recognition 摄像头实时人脸识别</h3><blockquote><p>设计思路：</p><ul><li>读入目标图片并对已知人脸进行编码</li><li>读取摄像头</li><li>定位摄像头每一帧拍摄中的人脸位置坐标</li><li>对摄像头每一帧进行编码并与已知图片的编码进行比较</li><li>达到相似度的阈值则进行边框标记</li><li>识别成功</li></ul></blockquote><p><strong>注：过程中的函数的作用及参数的设置不懂的可以参考百度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读入相关库</span></span><br><span class="line"><span class="comment"># cv2即 OpenCV(cv和cv2 有点类似 py2和py3)，用来读取摄像头</span></span><br><span class="line"><span class="comment"># face_recognition 进行人脸识别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> face_recognition <span class="keyword">as</span> fr</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存在本地的待比较图片</span></span><br><span class="line"><span class="comment"># image是numpy三维数组</span></span><br><span class="line">image = fr.load_image_file(<span class="string">r&#x27;C:\SecurityMonitor\FaceRecognition\img\face.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 对已知图片进行编码，由于face_encodings是元组列表，并且我们已知的图片中只有一个人，所以获取索引0即目标编码</span></span><br><span class="line">Admin_encoding = fr.face_encodings(image)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用OpenCV获取摄像头，VideoCapture(0)是后置摄像头，VideoCapture(1)是前置摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让摄像头一直进行拍摄</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 由于摄像头中会出现很多人脸，设置index为编码列表中识别成功的元素下标值</span></span><br><span class="line">    index = -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 进行摄像头的拍摄，read()是按帧拍摄</span></span><br><span class="line">    <span class="comment"># 返回值1：ret是bool值，拍摄成功与否</span></span><br><span class="line">    <span class="comment"># 返回值2：frame是该帧的numpy数组</span></span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    <span class="comment"># 对图像进行resize()缩小，提高速度</span></span><br><span class="line">    smallFrame = cv2.resize(frame,(<span class="number">0</span>,<span class="number">0</span>),fx=<span class="number">0.25</span>,fy=<span class="number">0.25</span>)</span><br><span class="line">    <span class="comment"># 定位摄像头该帧中的人脸，face_locations(top，right，bottom，left)是元组列表，可能有多个人脸</span></span><br><span class="line">    face_locations = fr.face_locations(smallFrame)</span><br><span class="line">    <span class="comment"># 在该帧图像中定位人脸位置，并进行人脸编码</span></span><br><span class="line">    face_encodings = fr.face_encodings(smallFrame,face_locations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每一个编码进行与已知编码进行比较，识别成功则记录下标并退出</span></span><br><span class="line">    <span class="keyword">for</span> i,face_encoding <span class="keyword">in</span> <span class="built_in">enumerate</span>(face_encodings):</span><br><span class="line">        result = fr.compare_faces([Admin_encoding],face_encoding)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 识别成功则进行矩形框标记，需要将该帧图像恢复原图，因为上面的比例因子为0.25，所以这里扩大四倍</span></span><br><span class="line">    <span class="keyword">if</span> index != -<span class="number">1</span>:</span><br><span class="line">        face_location = face_locations[index]</span><br><span class="line">        top = face_location[<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">        right = face_location[<span class="number">1</span>] * <span class="number">4</span></span><br><span class="line">        bottom = face_location[<span class="number">2</span>] * <span class="number">4</span></span><br><span class="line">        left = face_location[<span class="number">3</span>] * <span class="number">4</span></span><br><span class="line">        <span class="comment"># 矩形框标记</span></span><br><span class="line">        cv2.rectangle(frame,(left,top),(right,bottom),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示摄像头图像</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Identification&#x27;</span>,frame)</span><br><span class="line">    <span class="comment"># 按 q 退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放资源</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> face_recognition </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python人脸识别模块face_recognition之环境配置</title>
      <link href="/Python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97face-recognition%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
      <url>/Python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97face-recognition%E4%B9%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一时之间对人脸识别提起了兴趣，调研了一番，发现Python有个<strong>基于CNN的face_recognition库</strong>，不过安装这个库需要dlib库，而安装dlib还有很多需要的前置环境…反正就是各种深坑，辗转配了三天(emmm??)。网上的博客、论坛很少有能解决问题的，<strong>安装失败的原因主要是各环境版本的匹配问题</strong>。遂开此博客，记录环境安装流程。</p><blockquote><p><strong>Python3.7 + Cmake 3.14.0 + boost 1.68 + dlib 19.14 + face_recognition</strong></p></blockquote><span id="more"></span><hr><h3 id="一、安装Visual-Studio-2017"><a href="#一、安装Visual-Studio-2017" class="headerlink" title="一、安装Visual Studio 2017"></a>一、安装Visual Studio 2017</h3><p>我们需要用到VS2017中的cl.exe, 好像是这么个东西。</p><p><img src="https://s2.ax1x.com/2019/04/15/AjepM8.png" alt=""></p><h4 id="1-1-安装VS2017"><a href="#1-1-安装VS2017" class="headerlink" title="1.1 安装VS2017"></a>1.1 安装VS2017</h4><blockquote><p>VS2017下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p></blockquote><p>安装时需要选上<code>使用C++的桌面开发</code>、<code>Python开发</code>，最后别忘了设置安装位置。等待一段时间即可。</p><p><img src="https://s2.ax1x.com/2019/04/15/AjZOIA.png" alt=""></p><h4 id="1-2-配置cl环境变量"><a href="#1-2-配置cl环境变量" class="headerlink" title="1.2 配置cl环境变量"></a>1.2 配置cl环境变量</h4><p>VS2017安装好C++开发环境后，要将<code>cl.exe</code>的路径加入到环境变量，见到如下截图说明cl配置正常了:</p><p><img src="https://s2.ax1x.com/2019/04/15/Aje9sS.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/04/15/AjeCqg.png" alt=""></p><hr><h3 id="二、Python3-7安装"><a href="#二、Python3-7安装" class="headerlink" title="二、Python3.7安装"></a>二、Python3.7安装</h3><blockquote><p>Python官网：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p></blockquote><p>安装流程略</p><hr><h3 id="三、安装Cmake-3-14-0"><a href="#三、安装Cmake-3-14-0" class="headerlink" title="三、安装Cmake 3.14.0"></a>三、安装Cmake 3.14.0</h3><p>这里不用pip。我写这篇博客的时候pip最高只能安装3.13.3的版本。所以我们选择在官网下载。</p><blockquote><p>Cmake官网：<a href="https://cmake.org/files/v3.14/">https://cmake.org/files/v3.14/</a></p></blockquote><p>下载对应系统下的 <code>.msi</code> 或者 <code>.zip</code> 文件。这里拿Windows举例,32位电脑选择上面的，64位电脑选择下面的。</p><p><img src="https://s2.ax1x.com/2019/04/15/AjeXmF.png" alt=""></p><p>下载完成之后将Cmake的bin目录添加到环境变量：</p><p><img src="https://s2.ax1x.com/2019/04/15/AjmSYR.png" alt=""></p><hr><h3 id="四、安装boost1-68-0"><a href="#四、安装boost1-68-0" class="headerlink" title="四、安装boost1.68.0"></a>四、安装boost1.68.0</h3><blockquote><p>boost官网：<a href="https://www.boost.org/">https://www.boost.org/</a></p></blockquote><h6 id="4-1-将下载的boost解压，然后运行-bootstrap-bat-执行文件，会生成b2-exe、bjam-exe以及project-config-jam。（推荐在命令行cd到当前目录执行bootstrap-bat）"><a href="#4-1-将下载的boost解压，然后运行-bootstrap-bat-执行文件，会生成b2-exe、bjam-exe以及project-config-jam。（推荐在命令行cd到当前目录执行bootstrap-bat）" class="headerlink" title="4.1 将下载的boost解压，然后运行 bootstrap.bat 执行文件，会生成b2.exe、bjam.exe以及project-config.jam。（推荐在命令行cd到当前目录执行bootstrap.bat）"></a>4.1 将下载的boost解压，然后运行 <code>bootstrap.bat</code> 执行文件，会生成<code>b2.exe</code>、<code>bjam.exe</code>以及<code>project-config.jam</code>。（推荐在命令行cd到当前目录执行bootstrap.bat）</h6><p><img src="https://s2.ax1x.com/2019/04/15/AjmVTH.png" alt=""></p><p><strong>注意：如果在cmd中提示Failed，尝试切换到vs2017中的终端下进行操作，路径为 <code>ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2017\Visual Studio Tools\VC</code></strong></p><p><img src="https://s2.ax1x.com/2019/04/15/Ajm6AJ.png" alt=""></p><h6 id="4-2-在当前目录命令行中执行命令-b2-install-这个过程有点长，大概两个多小时左右，耐心等就好了。"><a href="#4-2-在当前目录命令行中执行命令-b2-install-这个过程有点长，大概两个多小时左右，耐心等就好了。" class="headerlink" title="4.2 在当前目录命令行中执行命令 b2 install ,这个过程有点长，大概两个多小时左右，耐心等就好了。"></a>4.2 在当前目录命令行中执行命令 <code>b2 install</code> ,这个过程有点长，大概两个多小时左右，耐心等就好了。</h6><h6 id="4-3-在当前目录命令行中执行命令-b2-a-—with-python-address-model-64-toolset-msvc-runtime-link-static。"><a href="#4-3-在当前目录命令行中执行命令-b2-a-—with-python-address-model-64-toolset-msvc-runtime-link-static。" class="headerlink" title="4.3 在当前目录命令行中执行命令 b2 -a —with-python address-model=64 toolset=msvc runtime-link=static。"></a>4.3 在当前目录命令行中执行命令 <code>b2 -a —with-python address-model=64 toolset=msvc runtime-link=static</code>。</h6><h6 id="4-4-将安装已完成后的boost路径添加到环境变量："><a href="#4-4-将安装已完成后的boost路径添加到环境变量：" class="headerlink" title="4.4 将安装已完成后的boost路径添加到环境变量："></a>4.4 将安装已完成后的boost路径添加到环境变量：</h6><p><img src="https://s2.ax1x.com/2019/04/15/Ajmfc6.png" alt=""></p><p><strong>到这里前置环境已经全部安装完成了，只差最后一步！！！</strong></p><hr><h3 id="五、安装dlib-19-14-0"><a href="#五、安装dlib-19-14-0" class="headerlink" title="五、安装dlib 19.14.0"></a>五、安装dlib 19.14.0</h3><p>这里推荐使用pip安装.</p><blockquote><p>pip install dlib==19.14</p></blockquote><p>耐心等待就好！！</p><hr><h3 id="六、安装face-recognition"><a href="#六、安装face-recognition" class="headerlink" title="六、安装face_recognition"></a>六、安装face_recognition</h3><blockquote><p>pip install face_recognition</p></blockquote><p>这边在推荐几个有关的库，一个计算机视觉库，一个深度学习框架：</p><blockquote><p>pip install opencv-python</p><p>pip install tensorflow</p></blockquote><hr><h4 id="完结，撒花-！！"><a href="#完结，撒花-！！" class="headerlink" title="完结，撒花~~！！"></a>完结，撒花~~！！</h4>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> Modules </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(九):使用scrapyd部署爬虫</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%B9%9D-%E4%BD%BF%E7%94%A8scrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%B9%9D-%E4%BD%BF%E7%94%A8scrapyd%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Scrapyd简介"><a href="#一、Scrapyd简介" class="headerlink" title="一、Scrapyd简介"></a>一、Scrapyd简介</h3><p>Scrapyd是一个用来部署和运行Scrapy项目的应用，由Scrapy的开发者开发。其可以通过一个简单的Json API来部署（上传）或者控制你的项目。<br>Scrapyd可以用来管理多个项目，并且每个项目还可以上传多个版本，不过只有最新的版本会被使用。<br>在安装并开启Scrapyd之后，它将会挂起一个服务来监听运行爬虫的请求，并且根据请求为每一个爬虫启用一个进程来运行。Scrapyd同样支持同时运行多个进程，进程的数量由max_proc和max_proc_per_cpu选项来限制。</p><hr><span id="more"></span><h3 id="二、Scrapyd安装"><a href="#二、Scrapyd安装" class="headerlink" title="二、Scrapyd安装"></a>二、Scrapyd安装</h3><blockquote><p>安装命令: pip install scrapyd</p></blockquote><p><strong>等待下载完成，下载完成后，启动scrapyd,命令即：scrapyd，启动后，有一句会显示你的端口号，如图所示:</strong></p><p><img src="https://s2.ax1x.com/2019/03/31/ArKCex.png" alt=""></p><p><strong>然后在网页中输入你的本地ip加上端口号，即：127.0.0.1:6800。访问这个网页出现下面的页面即scrapyd的页面：</strong></p><p><img src="https://s2.ax1x.com/2019/03/31/ArNb0e.png" alt=""></p><p><strong>上一步中如果连接启动成功后先关闭服务，在一个地方创建一个文件夹，文件夹名字自定义，但是要见名知意。然后进入文件夹，按住shift键不松手，并右击该文件夹随意空白处，然后点击“在此处打开命令窗口”，即进入的是cmd，然后在cmd里重新启动scrapyd,即输入scrapyd。执行后文件里会多出一个空的文件夹dbs，这个文件夹是用来存放爬虫文件数据的。</strong></p><p><img src="https://s2.ax1x.com/2019/03/31/ArUkkj.png" alt=""></p><p><strong>接下来我们需要把我们的项目打包上传到scrapyd服务里，那么我们要下载一个包：scrapyd-client。</strong></p><hr><h3 id="三、Scrapyd-client"><a href="#三、Scrapyd-client" class="headerlink" title="三、Scrapyd-client"></a>三、Scrapyd-client</h3><p>将Scrapy项目部署到远程服务器，首先第一步要做的就是把项目打包成<code>egg</code>文件，然后上传到目标服务器，这个操作使用<code>setup-tools</code>也是可以完成的，但比较麻烦。</p><p>所以我们可以使用一个第三方库<code>Scrapyd-Client</code>来帮我们一步完成这些操作。</p><p><code>scrapyd-client</code>的功能主要有两个：</p><ul><li><p>将项目打包成<code>egg</code>文件</p></li><li><p>将egg文件通过Scrapyd的<code>addversion.json</code>接口上传到目标服务器。</p></li></ul><h4 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h4><blockquote><p>pip install scrapyd-client</p></blockquote><p>下载完毕后，你的Python环境中的<code>Scripts</code>文件里会出现一个<code>scrapyd-deploy</code>，这个文件是启动文件，但是在windows下不能运行，只能在linux运行，所以我们要自己编写一个bat执行文件。</p><p><img src="https://s2.ax1x.com/2019/03/31/ArURu8.png" alt=""></p><p>创建名字为<code>scrapy.bat</code> 和 <code>scrapyd-deploy.bat</code>的文件，里面写入下面的配置:</p><p><img src="https://s2.ax1x.com/2019/03/31/ArUgjf.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.scrapy.bat</span><br><span class="line">@echo off</span><br><span class="line">C:\Users\QzmVc1\AppData\Local\Programs\Python\Python37\python.exe C:\Users\QzmVc1\AppData\Local\Programs\Python\Python37\Scripts\scrapy %*</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">2.scrapyd-deploy.bat</span><br><span class="line">@echo off</span><br><span class="line">C:\Users\QzmVc1\AppData\Local\Programs\Python\Python37\python.exe C:\Users\QzmVc1\AppData\Local\Programs\Python\Python37\Scripts\scrapyd-deploy %*</span><br></pre></td></tr></table></figure><p><strong>第一个是python.exe路径，第二个是Scripts中对应文件的路径。</strong></p><p>然后我们来测试一下<code>scrapyd-deploy</code>是否可以使用:</p><p><img src="https://s2.ax1x.com/2019/03/31/AraVVe.png" alt=""></p><h4 id="3-2-部署"><a href="#3-2-部署" class="headerlink" title="3.2 部署"></a>3.2 部署</h4><p>在安装<code>scrapyd-client</code>完毕之后，主要可以使用<code>scrapyd-deploy</code>命令完成项目的部署，以下是具体使用方式：</p><p>要部署你的项目，首先先通过cd命令进入你项目的根目录，然后输入以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapyd-deploy &lt;target&gt; -p &lt;project&gt;</span><br></pre></td></tr></table></figure><p>这个命令会将你的项目打包成一个<code>egg</code>文件，然后上传到你指定的<code>target</code>，如果你的项目中有一个<code>setup.py</code>文件，那么其将会被使用，如果没有那么将会自动创建一个。如果这行代码运行成功的话，那么将会返回以下结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deploying myproject-1287453519 to http://localhost:6800/addversion.json</span><br><span class="line">Server response (200):</span><br><span class="line">&#123;&quot;status&quot;: &quot;ok&quot;, &quot;spiders&quot;: [&quot;spider1&quot;, &quot;spider2&quot;]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-版本"><a href="#3-3-版本" class="headerlink" title="3.3 版本"></a>3.3 版本</h4><p>在使用以上命令部署<code>Scrapy</code>项目时，项目的版本号默认会设置为当前的时间戳，我们也可以使用<code>—version</code>参数来指定版本号。</p><blockquote><p>scrapyd-deploy <target> -p <project> —version <version></p></blockquote><p>需要注意的是，版本号只能为纯数字。在默认的情况下，<code>scrapyd</code>会使用版本号最大的版本。</p><hr><h3 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h3><p>Scrapyd将会在以下地址搜索配置文件，在解析的过程中更高的配置文件拥有更高的优先级：</p><ul><li><p><code>/etc/scrapyd/scrapyd.conf</code> (Unix)</p></li><li><p><code>c:/scrapyd/scrapyd.conf</code> (Windows)</p></li><li><p><code>/etc/scrapyd/conf.d/*</code> (in alphabetical order, Unix)</p></li><li><p><code>scrapyd.conf</code></p></li><li><p><code>~/.scrapyd.conf</code> (users home directory)</p></li></ul><p>配置文件中支持配置以下选项：</p><ul><li><p><code>http_port</code><br>Scrapyd的API监听的端口，默认为6800。</p></li><li><p><code>bind_address</code><br>网页和Json服务监听的IP地址，默认为127.0.0.1。</p></li><li><p><code>max_proc</code><br>同时启动的最大Scrapy进程数，如果没有设置或者设置为0，那么将会使用当前cpu可用的核数乘以max_proc_per_cpu的值。默认为0。</p></li><li><p><code>max_proc_per_cpu</code><br>每个cpu能同时启动的最大Scrapy进程数。默认为4。</p></li><li><p><code>debug</code><br>是否开启debug模式，默认为off。开启之后，如果在调用Scrapy的Json API的时候出错，则会返回详细的traceback信息。</p></li><li><p><code>eggs_dir</code><br>项目的eggs文件存储的目录。</p></li><li><p><code>dbs_dir</code><br>项目存储数据库的目录，也包括爬虫队列。</p></li><li><p><code>logs_dir</code><br>存储Scrapy日志的目录。</p></li><li><p><code>items_dir</code><br>存储items的目录，一般来说不需要设置这个选项，因为抓取下来的数据都会存到数据库中。如果设置这个选项，那么将会覆盖Scrapy的FEED_URL设置，将抓取下来的items保存到指定目录。</p></li><li><p><code>jobs_to_keep</code><br>每个spider保留多少个完成的job，默认为5。这更多指的是item和log。</p></li><li><p><code>finished_to_keep</code><br>启动器中保留的已完成进程的数量，默认为100。</p></li><li><p><code>poll_interval</code><br>轮询队列的间隔，以秒为单位，默认值为5，可以为浮点数。</p></li><li><p><code>runner</code><br>用来启动子进程的启动器，可以自定义启动的模块。</p></li><li><p><code>node_name</code><br>每个节点的节点名称，默认为${socket.gethostname()}。</p></li></ul><p><strong>以下是一个默认的配置文件的例子：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[scrapyd]</span><br><span class="line">eggs_dir    = eggs</span><br><span class="line">logs_dir    = logs</span><br><span class="line">items_dir   =</span><br><span class="line">jobs_to_keep = <span class="number">5</span></span><br><span class="line">dbs_dir     = dbs</span><br><span class="line">max_proc    = <span class="number">0</span></span><br><span class="line">max_proc_per_cpu = <span class="number">4</span></span><br><span class="line">finished_to_keep = <span class="number">100</span></span><br><span class="line">poll_interval = <span class="number">5.0</span></span><br><span class="line">bind_address = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">http_port   = <span class="number">6800</span></span><br><span class="line">debug       = off</span><br><span class="line">runner      = scrapyd.runner</span><br><span class="line">application = scrapyd.app.application</span><br><span class="line">launcher    = scrapyd.launcher.Launcher</span><br><span class="line">webroot     = scrapyd.website.Root</span><br><span class="line"></span><br><span class="line">[services]</span><br><span class="line">schedule.json     = scrapyd.webservice.Schedule</span><br><span class="line">cancel.json       = scrapyd.webservice.Cancel</span><br><span class="line">addversion.json   = scrapyd.webservice.AddVersion</span><br><span class="line">listprojects.json = scrapyd.webservice.ListProjects</span><br><span class="line">listversions.json = scrapyd.webservice.ListVersions</span><br><span class="line">listspiders.json  = scrapyd.webservice.ListSpiders</span><br><span class="line">delproject.json   = scrapyd.webservice.DeleteProject</span><br><span class="line">delversion.json   = scrapyd.webservice.DeleteVersion</span><br><span class="line">listjobs.json     = scrapyd.webservice.ListJobs</span><br><span class="line">daemonstatus.json = scrapyd.webservice.DaemonStatus</span><br></pre></td></tr></table></figure></p><hr><h3 id="五、API"><a href="#五、API" class="headerlink" title="五、API"></a>五、API</h3><p>在开启了<code>scrapyd</code>服务之后，就可以通过<code>Scrapyd</code>提供的<code>API</code>接口来操作你的<code>Scrapy</code>项目了。</p><h4 id="5-1-daemonstatus-json"><a href="#5-1-daemonstatus-json" class="headerlink" title="5.1 daemonstatus.json"></a>5.1 daemonstatus.json</h4><p>用来检查服务器的负载状态。支持的请求方法：<code>GET</code>。</p><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/daemonstatus.json</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;running&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;pending&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;finished&quot;</span>: <span class="string">&quot;0&quot;</span>, <span class="string">&quot;node_name&quot;</span>: <span class="string">&quot;node-name&quot;</span> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-2-addversion-json"><a href="#5-2-addversion-json" class="headerlink" title="5.2 addversion.json"></a>5.2 addversion.json</h4><p>给项目增加一个版本，如果项目不存在的话那么就创建一个项目。这个接口主要被用来上传项目或者更新项目版本。支持的请求方法：<code>POST</code>。</p><p>参数：</p><ul><li><p><code>project</code> (string, required) - 项目的名称</p></li><li><p><code>version</code> (string, required) - 项目的版本</p></li><li><p><code>egg</code> (file, required) - 一个包含项目代码的egg文件</p></li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/addversion.json -F project=myproject -F version=r23 -F egg=@myproject.egg</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;spiders&quot;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-3-schedule-json"><a href="#5-3-schedule-json" class="headerlink" title="5.3 schedule.json"></a>5.3 schedule.json</h4><p>调度运行一个爬虫（也成为job），并返回一个<code>jobid</code>。支持的请求方法：<code>POST</code>。</p><p>参数：</p><ul><li><p><code>project</code> (string, required) - 项目的名称</p></li><li><p><code>spider</code> (string, required) - 爬虫的名称</p></li><li><p><code>setting</code> (string, optional) - 爬虫运行时要用到的Scrapy设置</p></li><li><p><code>jobid</code> (string, optional) - 用来作为标识的jobid，会覆盖掉默认生成的UUID</p></li><li><p><code>_version</code> (string, optional) - 使用的项目版本<br>任何其他的参数将会传递作为爬虫的参数</p></li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/schedule.json -d project=myproject -d spider=somespider</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;jobid&quot;</span>: <span class="string">&quot;6487ec79947edab326d6db28a2d86511e8247444&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>以下是传递spider参数和setting参数的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/schedule.json -d project=myproject -d spider=somespider -d setting=DOWNLOAD_DELAY=<span class="number">2</span> -d arg1=val1</span><br></pre></td></tr></table></figure></p><h4 id="5-4-cancel-json"><a href="#5-4-cancel-json" class="headerlink" title="5.4 cancel.json"></a>5.4 cancel.json</h4><p>取消一个<code>job</code>的运行，如果这个<code>job</code>处于等待的状态，那么将会被移除，如果这个<code>job</code>正在运行，那么它将会被终止。支持的请求方法：<code>POST</code>。</p><p>参数：</p><ul><li><p><code>project</code> (string, required) - 项目的名称</p></li><li><p><code>job</code> (string, required) - job的id</p></li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/cancel.json -d project=myproject -d job=6487ec79947edab326d6db28a2d86511e8247444</span><br></pre></td></tr></table></figure></p><p>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;prevstate&quot;</span>: <span class="string">&quot;running&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-5-listprojects-json"><a href="#5-5-listprojects-json" class="headerlink" title="5.5 listprojects.json"></a>5.5 listprojects.json</h4><p>获取上传到服务器的项目列表。支持请求方法：<code>GET</code>，无参数。</p><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/listprojects.json</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;projects&quot;</span>: [<span class="string">&quot;myproject&quot;</span>, <span class="string">&quot;otherproject&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-6-listversions-json"><a href="#5-6-listversions-json" class="headerlink" title="5.6 listversions.json"></a>5.6 listversions.json</h4><p>获取某个或某些项目的版本列表。返回的版本将会按顺序排列，最后的那个版本是当前正在使用的版本。支持请求参数：<code>GET</code>。</p><p>参数：<br><code>project</code> (string, required) - 项目名称</p><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/listversions.json?project=myproject</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;versions&quot;</span>: [<span class="string">&quot;r99&quot;</span>, <span class="string">&quot;r156&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-7-listspiders-json"><a href="#5-7-listspiders-json" class="headerlink" title="5.7 listspiders.json"></a>5.7 listspiders.json</h4><p>默认获取某个项目最新版本中的<code>spider</code>列表。支持的请求方法：<code>GET</code>。</p><p>参数：</p><ul><li><p><code>project</code> (string, required) - 项目的名称</p></li><li><p><code>_version</code> (string, optional) - 检查的项目版本</p></li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/listspiders.json?project=myproject</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;spiders&quot;</span>: [<span class="string">&quot;spider1&quot;</span>, <span class="string">&quot;spider2&quot;</span>, <span class="string">&quot;spider3&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-8-listjobs-json"><a href="#5-8-listjobs-json" class="headerlink" title="5.8 listjobs.json"></a>5.8 listjobs.json</h4><p>获取某个项目正在等待、运行或者运行完毕的job列表。支持的请求类型：<code>GET</code>。</p><p>参数：</p><ul><li><code>project</code> (string, required) - 项目名称</li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/listjobs.json?project=myproject</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"> <span class="string">&quot;pending&quot;</span>: [&#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;78391cc0fcaf11e1b0090800272a6d06&quot;</span>, <span class="string">&quot;spider&quot;</span>: <span class="string">&quot;spider1&quot;</span>&#125;],</span><br><span class="line"> <span class="string">&quot;running&quot;</span>: [&#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;422e608f9f28cef127b3d5ef93fe9399&quot;</span>, <span class="string">&quot;spider&quot;</span>: <span class="string">&quot;spider2&quot;</span>, <span class="string">&quot;start_time&quot;</span>: <span class="string">&quot;2012-09-12 10:14:03.594664&quot;</span>&#125;],</span><br><span class="line"> <span class="string">&quot;finished&quot;</span>: [&#123;<span class="string">&quot;id&quot;</span>: <span class="string">&quot;2f16646cfcaf11e1b0090800272a6d06&quot;</span>, <span class="string">&quot;spider&quot;</span>: <span class="string">&quot;spider3&quot;</span>, <span class="string">&quot;start_time&quot;</span>: <span class="string">&quot;2012-09-12 10:14:03.594664&quot;</span>, <span class="string">&quot;end_time&quot;</span>: <span class="string">&quot;2012-09-12 10:24:03.594664&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-9-delversion-json"><a href="#5-9-delversion-json" class="headerlink" title="5.9 delversion.json"></a>5.9 delversion.json</h4><p>删除某个项目的某个版本，如果这个项目不再有能用的版本，那么项目也会被删除。支持的请求方法：<code>POST</code>。</p><p>参数：</p><ul><li><p><code>project</code> (string, required) - 项目名称</p></li><li><p><code>version</code> (string, required) - 要删除的项目版本</p></li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/delversion.json -d project=myproject -d version=r99</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-10-delproject-json"><a href="#5-10-delproject-json" class="headerlink" title="5.10 delproject.json"></a>5.10 delproject.json</h4><p>删除指定项目。支持请求方法：<code>POST</code>。</p><p>参数：</p><ul><li><code>project</code> (string, required) - 项目名称</li></ul><p>request例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:<span class="number">6800</span>/delproject.json -d project=myproject</span><br></pre></td></tr></table></figure><br>response例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><hr><p>参考链接:</p><ul><li><p><a href="https://www.jianshu.com/p/2a189127901a">https://www.jianshu.com/p/2a189127901a</a></p></li><li><p><a href="https://scrapyd.readthedocs.io/en/latest/api.html">https://scrapyd.readthedocs.io/en/latest/api.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Working with MongoDB and Pymongo</title>
      <link href="/Working-with-MongoDB-and-Pymongo.html"/>
      <url>/Working-with-MongoDB-and-Pymongo.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>MongoDB的学习详见 <a href="https://docs.mongodb.com/manual/crud/">官方文档</a> 或者 <a href="http://qzmvc1.top/2019/03/07/NoSQL-MongDB%E7%AE%80%E4%BB%8B/">我的博客</a></p></blockquote><p>运行环境：</p><ul><li>Pymongo 3.7.2</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户端对象，连接数据库</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接数据库</span></span><br><span class="line">db = client.dbname</span><br><span class="line">db = client[<span class="string">&#x27;dbname&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据库中的集合</span></span><br><span class="line">collection = db.collectionname</span><br><span class="line">collection = db[<span class="string">&#x27;collectionname&#x27;</span>]</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="一、添加记录Create"><a href="#一、添加记录Create" class="headerlink" title="一、添加记录Create"></a>一、添加记录Create</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法同 MongoDB</span></span><br><span class="line"><span class="comment"># insert_one()</span></span><br><span class="line"><span class="comment"># insert_many()</span></span><br><span class="line"><span class="comment"># insert()  官方已不推荐使用，但可以用</span></span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line"> <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20170101&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jordan&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>,</span><br><span class="line"> <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">student2 = &#123;</span><br><span class="line"> <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20170202&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>,</span><br><span class="line"> <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_one(student1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># &lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result.inserted_id)</span><br><span class="line"><span class="comment"># 5932ab0f15c2606f0c1cf6c5</span></span><br><span class="line"></span><br><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># &lt;pymongo.results.InsertManyResult object at 0x101dea558&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result.inserted_ids)</span><br><span class="line"><span class="comment">#[ObjectId(&#x27;5932abf415c2607083d3b2ac&#x27;),ObjectId(&#x27;5932abf415c2607083d3b2ad&#x27;)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、查找记录Find"><a href="#二、查找记录Find" class="headerlink" title="二、查找记录Find"></a>二、查找记录Find</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法同 MongoDB</span></span><br><span class="line"><span class="comment"># find_one()</span></span><br><span class="line"><span class="comment"># find()</span></span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="comment">#&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#&#123;&#x27;_id&#x27;: ObjectId(&#x27;5932a80115c2606a59e8a049&#x27;), &#x27;id&#x27;: &#x27;20170202&#x27;, &#x27;name&#x27;: &#x27;Mike&#x27;, &#x27;age&#x27;: 21, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">results = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"><span class="comment"># &lt;pymongo.cursor.Cursor object at 0x1032d5128&gt;</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&#x27;_id&#x27;: ObjectId(&#x27;593278c115c2602667ec6bae&#x27;), &#x27;id&#x27;: &#x27;20170101&#x27;, &#x27;name&#x27;: &#x27;Jordan&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;_id&#x27;: ObjectId(&#x27;593278c815c2602678bb2b8d&#x27;), &#x27;id&#x27;: &#x27;20170102&#x27;, &#x27;name&#x27;: &#x27;Kevin&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;_id&#x27;: ObjectId(&#x27;593278d815c260269d7645a8&#x27;), &#x27;id&#x27;: &#x27;20170103&#x27;, &#x27;name&#x27;: &#x27;Harden&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 返回结果是Cursor类型，相当于一个生成器，我们需要遍历取到所有的结果，每一个结果都是字典类型。</span></span><br></pre></td></tr></table></figure><h4 id="还有一些其他函数如下"><a href="#还有一些其他函数如下" class="headerlink" title="还有一些其他函数如下"></a>还有一些其他函数如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计数</span></span><br><span class="line">count = collection.find().count()</span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>,pymongo.ASCENDING)</span><br><span class="line"><span class="comment"># 偏移</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>,pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 限制个数</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>,pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="三、更新记录Update"><a href="#三、更新记录Update" class="headerlink" title="三、更新记录Update"></a>三、更新记录Update</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法同 MongoDB</span></span><br><span class="line"><span class="comment"># update_one()</span></span><br><span class="line"><span class="comment"># update_many()</span></span><br><span class="line"><span class="comment"># update()  官方已不推荐使用，但可以用</span></span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># &lt;pymongo.results.UpdateResult object at 0x10c6384c8&gt;</span></span><br><span class="line"><span class="built_in">print</span>(result.matched_count, result.modified_count)</span><br><span class="line"><span class="comment"># 3 3</span></span><br></pre></td></tr></table></figure><h3 id="四、删除记录Remove"><a href="#四、删除记录Remove" class="headerlink" title="四、删除记录Remove"></a>四、删除记录Remove</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法同 MongoDB</span></span><br><span class="line"><span class="comment"># delete_one()</span></span><br><span class="line"><span class="comment"># delete_many()</span></span><br><span class="line"><span class="comment"># remove()</span></span><br></pre></td></tr></table></figure><hr><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><ul><li><a href="https://www.jb51.net/article/119823.htm">https://www.jb51.net/article/119823.htm</a></li><li><a href="http://api.mongodb.com/python/current/api/pymongo/collection.html">http://api.mongodb.com/python/current/api/pymongo/collection.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Pymongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见反爬虫机制与应对方法</title>
      <link href="/%E5%B8%B8%E8%A7%81%E5%8F%8D%E7%88%AC%E8%99%AB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95.html"/>
      <url>/%E5%B8%B8%E8%A7%81%E5%8F%8D%E7%88%AC%E8%99%AB%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>爬虫的目的就是大规模地、长时间地获取数据，跟我们正常浏览器获取数据相比，虽然机理相差不大，但总是一个IP去爬网站，大规模集中对服务器访问，时间一长就有可能被拒绝。当下，各网站的反爬机制也变得无处不在。只要是个网站，基本都有针对爬虫的手段。然而攻永远比防要容易，所谓道高一尺，魔高一丈。<br><span id="more"></span></p><h3 id="一、设置下载等待时间-下载频率"><a href="#一、设置下载等待时间-下载频率" class="headerlink" title="一、设置下载等待时间/下载频率"></a>一、设置下载等待时间/下载频率</h3><p>大多数情况下，我们遇到的是访问频率限制。如果你访问太快了，网站就会认为你不是一个人。这种情况下需要设定好频率的阈值，否则有可能误伤。</p><p>遇到这种网页，最直接的办法是限制访问时间。例如每隔5秒钟访问一次页面。但是如果遇到聪明一点的网站，它检测到你的访问时间，这个人访问了几十个页面，但是每次访问都刚好5秒钟，人怎么可能做到这么准确的时间间隔？肯定是爬虫，被封也是理所当然的！所以访问时间间隔你可以设定为一个随机值，例如0到10之间的随机秒数。</p><ul><li>如果是requests进行爬虫，那么我们可以在请求页面之前设置等待时间<code>time.sleep(random.randint(0,10))</code></li><li>如果是scrapy进行爬虫，专门有参数可以设置下载等待时间，这个参数可以设置在<code>setting.py-&gt;download_delay</code>里，也可以设置在spider里。</li></ul><h3 id="二、修改User-Agent"><a href="#二、修改User-Agent" class="headerlink" title="二、修改User-Agent"></a>二、修改User-Agent</h3><p>当我们使用浏览器访问网站的时候，浏览器会发送一小段信息给网站，我们称为Request Headers,在这个头部信息里面包含了本次访问的一些信息，例如编码方式，当前地址，将要访问的地址等等。这些信息一般来说是不必要的，但是现在很多网站会把这些信息利用起来。其中最常被用到的一个信息，叫做“User-Agent”。网站可以通过User-Agent来判断用户是使用什么浏览器访问。不同浏览器的User-Agent是不一样的，但都有遵循一定的规则。</p><p>例如，我们在Windows上面的Chrome浏览器，它的User-Agent是：</p><blockquote><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36</p></blockquote><p>但是如果我们使用Python的Requests直接访问网站，那么除了网址不提供其他的任何信息，网站收到的User-Agent是空。这个时候网站就知道我们不是使用浏览器访问的，于是它就可以拒绝我们的访问。</p><p>最常用的方法就是伪装浏览器，修改User-Agent（用户代理）。 具体方法为把User-Agent的值改为浏览器，甚至可以设置一个User-Agent池（list，数组，字典都可以），存放多个“浏览器”，每次爬取的时候随机取一个来设置User-Agent，这样User-Agent会一直在变化。</p><p>常用User-Agent如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">User-Agent = [</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><ul><li>进行requests爬虫时，可以将User-Agent放在requests.get()中的headers参数里，具体用法为<code>requests.get(url,headers=&#123;‘User-Agent’:’xxx’&#125;)</code></li><li>进行scrapy爬虫时，可以通过下载中间件middlewares.py进行设置。</li></ul><h3 id="三、设置代理IP"><a href="#三、设置代理IP" class="headerlink" title="三、设置代理IP"></a>三、设置代理IP</h3><p>如果对页的爬虫的效率有要求，那就不能通过设定访问时间间隔的方法来绕过频率检查了。</p><p>代理IP访问可以解决这个问题。如果用100个代理IP访问100个页面，可以给网站造成一种有100个人，每个人访问了1页的错觉。这样自然而然就不会限制你的访问了。</p><p>代理IP经常会出现不稳定的情况。你随便搜一个“免费代理”，会出现很多网站，每个网站也会给你很多的代理IP，但实际上，真正可用的代理IP并不多。你需要维护一个可用的代理IP池，但是一个免费的代理IP，也许在你测试的时候是可以使用的，但是几分钟以后就失效了。使用免费代理IP是已经费时费力，而且很考验你运气的事情。</p><ul><li>进行requests爬虫时，可以在requests.get()中的proxies参数里设置代理ip，具体方法如下:<code>requests.get(url,proxies=&#123;“http”:”ip:port”&#125;)</code></li><li>进行scrapy爬虫时，可以通过下载中间件middlewares.py进行设置代理ip。</li></ul><p>下面是我爬取<a href="https://www.kuaidaili.com/free/inha/">快代理</a>免费的代理IP脚本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtainProxy</span>(<span class="params">UA</span>):</span></span><br><span class="line">httpList = []</span><br><span class="line">url = <span class="string">&#x27;https://www.kuaidaili.com/free/inha/&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r = requests.get(url+<span class="built_in">str</span>(i),headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:random.choice(UA)&#125;)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">logger = logging.basicConfig(level=logging.INFO, <span class="built_in">format</span> =<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;Url cannot be requested normally.&#x27;</span>)</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">bsp = BeautifulSoup(r.text,<span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">proxyList = bsp.find(<span class="string">&quot;table&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;table table-bordered table-striped&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> proxyList != <span class="literal">None</span>:</span><br><span class="line">proxyList = proxyList.findAll(<span class="string">&quot;tr&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> proxy <span class="keyword">in</span> proxyList:</span><br><span class="line">form = <span class="string">&quot;%s://%s:%s&quot;</span></span><br><span class="line">tdList = proxy.findAll(<span class="string">&quot;td&quot;</span>)</span><br><span class="line">httpList.append(form % (tdList[<span class="number">3</span>].string.lower(),tdList[<span class="number">0</span>].string,tdList[<span class="number">1</span>].string))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> httpList</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkProxy</span>(<span class="params">UA</span>):</span></span><br><span class="line">validHttpList = obtainProxy(UA)</span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"><span class="keyword">for</span> http <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(validHttpList)):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">r = requests.get(url,headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:random.choice(UA)&#125;,proxies=&#123;<span class="string">&quot;http&quot;</span>:validHttpList[http]&#125;,timeout=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> r.status_code != <span class="number">200</span>:</span><br><span class="line"><span class="keyword">del</span> validHttpList[http]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> validHttpList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">UserAgent = [</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&quot;</span>,</span><br><span class="line">]</span><br><span class="line">httpList = checkProxy(UserAgent)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;http:\n&quot;</span>+<span class="string">&#x27;*&#x27;</span>*<span class="number">40</span>)</span><br><span class="line"><span class="keyword">for</span> proxy <span class="keyword">in</span> httpList:</span><br><span class="line"><span class="built_in">print</span>(proxy)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">http:</span><br><span class="line">****************************************</span><br><span class="line">http://<span class="number">111.77</span><span class="number">.197</span><span class="number">.22</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">113.128</span><span class="number">.8</span><span class="number">.62</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">123.55</span><span class="number">.114</span><span class="number">.160</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">58.55</span><span class="number">.202</span><span class="number">.93</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">125.123</span><span class="number">.142</span><span class="number">.195</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">117.42</span><span class="number">.200</span><span class="number">.143</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">183.158</span><span class="number">.206</span><span class="number">.127</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">114.235</span><span class="number">.23</span><span class="number">.78</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">120.83</span><span class="number">.103</span><span class="number">.145</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">116.209</span><span class="number">.55</span><span class="number">.248</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">60.188</span><span class="number">.60</span><span class="number">.29</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">113.121</span><span class="number">.147</span><span class="number">.9</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">144.255</span><span class="number">.14</span><span class="number">.7</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">121.233</span><span class="number">.251</span><span class="number">.147</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">117.41</span><span class="number">.38</span><span class="number">.19</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">163.125</span><span class="number">.28</span><span class="number">.220</span>:<span class="number">8118</span></span><br><span class="line">http://<span class="number">117.42</span><span class="number">.202</span><span class="number">.17</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">1.192</span><span class="number">.242</span><span class="number">.164</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">117.90</span><span class="number">.252</span><span class="number">.85</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">117.42</span><span class="number">.200</span><span class="number">.158</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">163.204</span><span class="number">.245</span><span class="number">.130</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">49.81</span><span class="number">.125</span><span class="number">.105</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">60.184</span><span class="number">.194</span><span class="number">.157</span>:<span class="number">3128</span></span><br><span class="line">http://<span class="number">113.121</span><span class="number">.145</span><span class="number">.218</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">47.107</span><span class="number">.190</span><span class="number">.212</span>:<span class="number">8118</span></span><br><span class="line">http://<span class="number">111.177</span><span class="number">.163</span><span class="number">.12</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">180.118</span><span class="number">.86</span><span class="number">.142</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">115.193</span><span class="number">.97</span><span class="number">.67</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">60.182</span><span class="number">.21</span><span class="number">.88</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">60.191</span><span class="number">.57</span><span class="number">.79</span>:<span class="number">10010</span></span><br><span class="line">http://<span class="number">115.223</span><span class="number">.253</span><span class="number">.196</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">121.225</span><span class="number">.26</span><span class="number">.246</span>:<span class="number">3128</span></span><br><span class="line">http://<span class="number">121.232</span><span class="number">.199</span><span class="number">.222</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">120.77</span><span class="number">.247</span><span class="number">.147</span>:<span class="number">80</span></span><br><span class="line">http://<span class="number">116.209</span><span class="number">.62</span><span class="number">.21</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">117.87</span><span class="number">.177</span><span class="number">.207</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">123.163</span><span class="number">.118</span><span class="number">.236</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">121.233</span><span class="number">.251</span><span class="number">.206</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">163.204</span><span class="number">.241</span><span class="number">.70</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">182.111</span><span class="number">.64</span><span class="number">.7</span>:<span class="number">36323</span></span><br><span class="line">http://<span class="number">123.115</span><span class="number">.131</span><span class="number">.159</span>:<span class="number">8060</span></span><br><span class="line">http://<span class="number">114.234</span><span class="number">.80</span><span class="number">.97</span>:<span class="number">9000</span></span><br><span class="line">http://<span class="number">124.94</span><span class="number">.195</span><span class="number">.223</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">49.70</span><span class="number">.33</span><span class="number">.206</span>:<span class="number">9999</span></span><br><span class="line">http://<span class="number">117.42</span><span class="number">.201</span><span class="number">.96</span>:<span class="number">9999</span></span><br><span class="line">****************************************</span><br></pre></td></tr></table></figure></p><h3 id="四、设置cookies"><a href="#四、设置cookies" class="headerlink" title="四、设置cookies"></a>四、设置cookies</h3><p>cookie其实是储存在用户终端的一些被加密的数据，有些网站通过cookies来识别用户身份，如果某个访问总是高频率地发请求，很可能会被网站注意到，被嫌疑为爬虫，这时网站就可以通过cookie找到这个访问的用户而拒绝其访问。<br>可以自定义设置cookie策略（防止cookie rejected问题：拒绝写入cookie）或者禁止cookies。</p><h6 id="1-自定义设置cookies策略（防止cookierejected问题，拒绝写入cookie）"><a href="#1-自定义设置cookies策略（防止cookierejected问题，拒绝写入cookie）" class="headerlink" title="1.自定义设置cookies策略（防止cookierejected问题，拒绝写入cookie）"></a>1.自定义设置cookies策略（防止cookierejected问题，拒绝写入cookie）</h6><p>详见官方文档: <a href="http://hc.apache.org/httpcomponents-client-4.3.x/tutorial/html/statemgmt.html#d5e553">http://hc.apache.org/httpcomponents-client-4.3.x/tutorial/html/statemgmt.html#d5e553</a></p><h6 id="2-禁止cookies"><a href="#2-禁止cookies" class="headerlink" title="2.禁止cookies"></a>2.禁止cookies</h6><p>通过禁止cookie，这是客户端主动阻止服务器写入。禁止cookie可以防止可能使用cookies识别爬虫的网站来ban掉我们。<br>在scrapy爬虫中可以设置<code>COOKIES_ENABLES= FALSE</code>，即不启用cookies middleware，不向web server发送cookies。</p><p>参考链接: <a href="https://blog.csdn.net/wbcg111/article/details/53572644">https://blog.csdn.net/wbcg111/article/details/53572644</a></p><h3 id="五、分布式爬取"><a href="#五、分布式爬取" class="headerlink" title="五、分布式爬取"></a>五、分布式爬取</h3><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL-MongDB简介</title>
      <link href="/NoSQL-MongDB%E7%AE%80%E4%BB%8B.html"/>
      <url>/NoSQL-MongDB%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/07/kx792j.png" alt=""></p><h3 id="一、关系型数据库和非关系型数据库"><a href="#一、关系型数据库和非关系型数据库" class="headerlink" title="一、关系型数据库和非关系型数据库"></a>一、关系型数据库和非关系型数据库</h3><h4 id="1-1-关系型数据库RDBMS-Relational-DataBase-Management-System"><a href="#1-1-关系型数据库RDBMS-Relational-DataBase-Management-System" class="headerlink" title="1.1 关系型数据库RDBMS(Relational DataBase Management System)"></a>1.1 关系型数据库RDBMS(Relational DataBase Management System)</h4><ul><li><p>关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p></li><li><p>关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。</p></li><li><p>当前主流的关系型数据库有Oracle、MySQL、Microsoft SQL Server、PostgreSQL、DB2等。</p></li></ul><span id="more"></span><h4 id="1-2-非关系型数据库NoSQL-Not-Only-SQL"><a href="#1-2-非关系型数据库NoSQL-Not-Only-SQL" class="headerlink" title="1.2 非关系型数据库NoSQL(Not Only SQL)"></a>1.2 非关系型数据库NoSQL(Not Only SQL)</h4><p><img src="https://s2.ax1x.com/2019/03/08/kxzifx.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/03/08/kz9REQ.png" alt=""></p><ul><li><p>NoSQL最早出现于1998 年，是由Carlo Storzzi最早开发的个轻量、开源、不兼容SQL 功能的关系型数据库，2009 年，在一次分布式开源数据库的讨论会上，再次提出了NoSQL 的概念，此时NoSQL主要是指非关系型、分布式、不提供ACID (数据库事务处理的四个基本要素)的数据库设计模式。同年，在亚特兰大举行的“NoSQL(east)”讨论会上，对NoSQL 最普遍的定义是“非关联型的”，强调Key-Value 存储和文档数据库的优点，而不是单纯地反对RDBMS，至此，NoSQL 开始正式出现在世人面前。</p></li><li><p>非关系型数据库：指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统。</p></li><li><p>非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</p></li></ul><h4 id="1-3-关系型与非关系型数据库的比较"><a href="#1-3-关系型与非关系型数据库的比较" class="headerlink" title="1.3 关系型与非关系型数据库的比较"></a>1.3 关系型与非关系型数据库的比较</h4><p><img src="https://s2.ax1x.com/2019/03/08/kzC35j.png" alt=""></p><h3 id="二、MongoDB简介"><a href="#二、MongoDB简介" class="headerlink" title="二、MongoDB简介"></a>二、MongoDB简介</h3><blockquote><p><a href="https://www.mongodb.com/">MongoDB官网</a></p></blockquote><h4 id="2-1-MongoDB简单介绍"><a href="#2-1-MongoDB简单介绍" class="headerlink" title="2.1 MongoDB简单介绍"></a>2.1 MongoDB简单介绍</h4><ul><li><p>MongoDB是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。MongoDB是<strong>基于文档</strong>而存储的，是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似Json的<strong>Bson</strong>格式，因此可以存储比较复杂的数据类型。</p></li><li><p>MongoDB没有结构化语言。模式自由(schema-free)，意味着对于存储在MongoDB数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p></li><li><p>Mongo主要解决的是海量数据的访问效率问题。因为Mongo主要是支持海量数据存储的，所以Mongo还自带了一个出色的分布式文件系统GridFS，可以支持海量的数据存储。由于Mongo可以支持复杂的数据结构，而且带有强大的数据查询功能，因此非常受到欢迎。</p></li></ul><h4 id="2-2-MongoDB的特点"><a href="#2-2-MongoDB的特点" class="headerlink" title="2.2 MongoDB的特点"></a>2.2 MongoDB的特点</h4><ul><li><p>文档数据类型<br>MongoDB是一个面向文档的数据库，它并不是关系型数据库，直接存取Bson，这意味着MongoDB更加灵活，因为可以在文档中直接插入数组之类的复杂数据类型，并且文档的key和value不是固定的数据类型和大小，所以开发者在使用MongoDB时无须预定义关系型数据库中的“表”等数据库对象，设计数据库将变得非常方便，可以大大地提升开发进度。</p></li><li><p>扩展性<br>在扩展性方面，假设应用数据增长非常迅猛的话，通过不断地添加磁盘容量和内存容量往往是不现实的，而手工的分库分表又会带来非常繁重的工作量和技术复杂度。在扩展性上，MongoDB有非常有效的，现成的解决方案。通过自带的Mongos集群，只需要在适当的时候继续添加Mongo分片，就可以实现程序段自动水平扩展和路由，一方面缓解单个节点的读写压力，另外一方面可有效地均衡磁盘容量的使用情况。整个mongos集群对应用层完全透明，并可完美地做到各个Mongos集群组件的高可用性。</p></li><li><p>数据压缩<br>自从MongoDB 3.0推出以后，MongoDB引入了一个高性能的存储引擎WiredTiger，并且它在数据压缩性能上得到了极大的提升，跟之前的MMAP引擎相比，压缩比至少可增加5倍以上，可以极大地改善磁盘空间使用率。</p></li><li><p><strong>…</strong></p></li></ul><h4 id="2-3-什么时候使用MongoDB"><a href="#2-3-什么时候使用MongoDB" class="headerlink" title="2.3 什么时候使用MongoDB?"></a>2.3 什么时候使用MongoDB?</h4><ul><li>我的数据量是有亿万级或者需要不断扩容</li><li>需要2000-3000以上的读写每秒</li><li>新应用，需求会变，数据模型无法确定</li><li>我需要整合多个外部数据源</li><li>我的系统需要99.999%高可用</li><li>我的系统需要大量的地理位置查循</li><li>我的系统需要提供最小的延迟时间</li><li>我要管理的主要数据对象&lt;10</li></ul><h4 id="2-4-安装MongoDB"><a href="#2-4-安装MongoDB" class="headerlink" title="2.4 安装MongoDB"></a>2.4 安装MongoDB</h4><blockquote><p><a href="https://www.mongodb.com/download-center/community">MongoDB下载地址</a></p><p><img src="https://s2.ax1x.com/2019/03/08/kxzPt1.png" alt=""></p></blockquote><ul><li>下载对应版本和操作系统的MSI文件或ZIP文件</li><li>配置环境变量<br>在环境变量的path中添加MongoDB的bin文件路径，如D:\MongoDB\bin</li><li>打开cmd<br>-- 输入<code>mongod</code>启动MongoDB数据库的服务端<br>-- 输入<code>mongo</code>启动MongoDB数据库的客户端</li><li>出现<code&gt;></code>则配置成功！</li></ul><h4 id="2-5-MongoDB基本概念"><a href="#2-5-MongoDB基本概念" class="headerlink" title="2.5 MongoDB基本概念"></a>2.5 MongoDB基本概念</h4><p><img src="https://s2.ax1x.com/2019/03/08/kxz6uF.png" alt=""></p><ul><li>数据库(database)<br>一个集合的物理容器。一个单一的MongoDB服务器通常有多个数据库。</li><li>集合(collection)<br>集合就是一组文档。如果说MongoDB中的文档类似于关系型数据库中的行，那么集合就如同表。</li><li>文档(document)<br>文档是MongoDB的核心概念。多个键及其关联的值有序的放置在一起便是文档。</li></ul><h4 id="2-6-MongoDB基本命令"><a href="#2-6-MongoDB基本命令" class="headerlink" title="2.6 MongoDB基本命令"></a>2.6 MongoDB基本命令</h4><ul><li><p>show dbs   /   show databases<br>显示所有的数据库</p></li><li><p>use database_name<br>进入指定的数据库</p></li><li><p>show collections<br>显示数据库中的所有集合</p></li><li><p>db<br>显示当前所在的数据库</p></li></ul><h3 id="三、MongoDB-CRUD-Operations"><a href="#三、MongoDB-CRUD-Operations" class="headerlink" title="三、MongoDB CRUD Operations"></a>三、MongoDB CRUD Operations</h3><p><a href="https://docs.mongodb.com/manual/crud/">MongoDB官方文档</a></p><h4 id="3-1-Create-Operations"><a href="#3-1-Create-Operations" class="headerlink" title="3.1 Create Operations"></a>3.1 Create Operations</h4><p><img src="https://s2.ax1x.com/2019/03/08/kzbRmR.png" alt=""></p><h6 id="3-1-1-db-collection-insertOne"><a href="#3-1-1-db-collection-insertOne" class="headerlink" title="3.1.1 db.collection.insertOne()"></a>3.1.1 db.collection.insertOne()</h6><p><strong>---函数说明：</strong></p><p><img src="https://s2.ax1x.com/2019/03/08/kzbgX9.png" alt=""><br><img src="https://s2.ax1x.com/2019/03/08/kzbTpD.png" alt=""></p><p><strong>---示例:</strong></p><p><img src="https://s2.ax1x.com/2019/03/08/kzbc6J.png" alt=""></p><blockquote><p>执行语句:  db.products.insertOne( &#123; item: “card”, qty: 15 &#125; )</p><p>存储结果：&#123; “_id” : ObjectId(“5063114bd386d8fadbd6b004”), “item” : “card”, “qty” : 15 &#125;</p></blockquote><h6 id="3-1-2-db-collection-insertMany"><a href="#3-1-2-db-collection-insertMany" class="headerlink" title="3.1.2 db.collection.insertMany()"></a>3.1.2 db.collection.insertMany()</h6><p><strong>---函数说明：</strong><br><img src="https://s2.ax1x.com/2019/03/08/kzqhuj.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/03/08/kzq4Ds.png" alt=""></p><p><strong>---示例:</strong><br><img src="https://s2.ax1x.com/2019/03/08/kzq5bn.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/03/08/kzqWvQ.png" alt=""></p><h6 id="3-1-3-db-collection-insert"><a href="#3-1-3-db-collection-insert" class="headerlink" title="3.1.3 db.collection.insert()"></a>3.1.3 db.collection.insert()</h6><ul><li><code>insert()</code>是<code>insertOne()</code>和<code>insertMany()</code>的综合。</li></ul><h4 id="3-2-Read-Operations"><a href="#3-2-Read-Operations" class="headerlink" title="3.2 Read Operations"></a>3.2 Read Operations</h4><h6 id="3-2-1-db-collection-findOne"><a href="#3-2-1-db-collection-findOne" class="headerlink" title="3.2.1 db.collection.findOne()"></a>3.2.1 db.collection.findOne()</h6><blockquote><p>查询一条数据</p></blockquote><p><strong>---示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询第一条名字是aaa的数据</span></span><br><span class="line">db.collection.findOne(&#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询第一条名字是aaa并且年龄是20岁的数据</span></span><br><span class="line">db.collection.findOne(&#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询年龄小于20岁的第一条数据</span></span><br><span class="line">db.collection.findOne(&#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询年龄小于20岁或者年龄大于30岁的数据</span></span><br><span class="line">db.collection.findOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$or</span>:[</span><br><span class="line">      &#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">30</span>&#125;&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h6 id="3-2-2-db-collection-find"><a href="#3-2-2-db-collection-find" class="headerlink" title="3.2.2 db.collection.find()"></a>3.2.2 db.collection.find()</h6><blockquote><p>查询所有符合条件的数据</p></blockquote><p><strong>---示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有数据</span></span><br><span class="line">db.collection.find()</span><br><span class="line">db.collection.find(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有数据并返回数据量</span></span><br><span class="line">db.collection.find().count()</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询名字是aaa的所有数据</span></span><br><span class="line">db.collection.find(&#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询名字是aaa并且年龄是20岁的所有数据</span></span><br><span class="line">db.collection.find(&#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询年龄小于20岁的所有数据</span></span><br><span class="line">db.collection.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询年龄小于20岁或者年龄大于30岁的所有数据</span></span><br><span class="line">db.collection.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$or</span>:[</span><br><span class="line">      &#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">30</span>&#125;&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据集中的前10条数据</span></span><br><span class="line">db.collection.find().limit(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据集中的10-20条数据</span></span><br><span class="line">db.collection.find().skip(<span class="number">10</span>).limit(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询班级号为1的所有数据并对他们进行升序排列</span></span><br><span class="line">db.collection.find(&#123;<span class="attr">grade</span>:<span class="number">1</span>&#125;).sort(&#123;<span class="attr">score</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询班级号为1的所有数据并对他们进行降序排列</span></span><br><span class="line">db.collection.find(&#123;<span class="attr">grade</span>:<span class="number">1</span>&#125;).sort(&#123;<span class="attr">score</span>:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>条件运算符</th><th>含义</th></tr></thead><tbody><tr><td>$gt</td><td>&gt;</td></tr><tr><td>$gte</td><td>&gt;=</td></tr><tr><td>$lt</td><td>&lt;</td></tr><tr><td>$lte</td><td>&lt;=</td></tr><tr><td>$ne</td><td>!=</td></tr><tr><td>$eq</td><td>==</td></tr></tbody></table></div><h4 id="3-3-Update-Operations"><a href="#3-3-Update-Operations" class="headerlink" title="3.3 Update Operations"></a>3.3 Update Operations</h4><h6 id="3-3-1-db-collection-update"><a href="#3-3-1-db-collection-update" class="headerlink" title="3.3.1 db.collection.update()"></a>3.3.1 db.collection.update()</h6><p>---默认只更改第一个查询到的数据，若要更改所有查询到的数据，需将<code>multi</code>设置为<code>true</code>。函数说明如下：</p><p><img src="https://s2.ax1x.com/2019/03/08/kzObX4.png" alt=""></p><p><strong>---示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将名为aaa的第一条数据中的gender属性改为Male</span></span><br><span class="line"><span class="comment">// $set 表示 更改/设置属性</span></span><br><span class="line"><span class="comment">// upsert 表示若没有查询到该数据，则向数据库中插入&#123;name:&quot;aaa&quot;,gender:&quot;Male&quot;&#125;的一条数据</span></span><br><span class="line">db.collection.update(</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$set</span>:&#123;<span class="attr">gender</span>:<span class="string">&quot;Male&quot;</span>&#125;，</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">upsert</span>:<span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $unset 表示 删除属性，属性后面可以接任何值，一般为 1</span></span><br><span class="line">db.collection.update(&#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>&#125;,&#123;<span class="attr">$unset</span>:&#123;<span class="attr">gender</span>:<span class="number">1</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改所有gender为Male的数据的age属性，将age全部加2</span></span><br><span class="line"><span class="comment">// $inc 表示 自增</span></span><br><span class="line">db.collection.update(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">gender</span>:<span class="string">&quot;Male&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$inc</span>:&#123;<span class="attr">age</span>:<span class="number">2</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">multi</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h6 id="3-3-2-db-collection-updateOne"><a href="#3-3-2-db-collection-updateOne" class="headerlink" title="3.3.2 db.collection.updateOne()"></a>3.3.2 db.collection.updateOne()</h6><p>语义为更改第一个查询到的数据，语法同update()</p><h6 id="3-3-3-db-collection-updateMany"><a href="#3-3-3-db-collection-updateMany" class="headerlink" title="3.3.3 db.collection.updateMany()"></a>3.3.3 db.collection.updateMany()</h6><p>语义为更改查询到的所有符合条件的数据，语法同update()</p><h4 id="3-4-Delete-Operations"><a href="#3-4-Delete-Operations" class="headerlink" title="3.4 Delete Operations"></a>3.4 Delete Operations</h4><h6 id="3-4-1-db-collection-deleteOne-filter"><a href="#3-4-1-db-collection-deleteOne-filter" class="headerlink" title="3.4.1 db.collection.deleteOne({filter})"></a>3.4.1 db.collection.deleteOne({filter})</h6><ul><li>删除符合条件的第一条数据</li></ul><h6 id="3-4-2-db-collection-deleteMany-filter"><a href="#3-4-2-db-collection-deleteMany-filter" class="headerlink" title="3.4.2 db.collection.deleteMany({filter})"></a>3.4.2 db.collection.deleteMany({filter})</h6><ul><li>删除符合条件的所有数据</li></ul><h6 id="3-4-3-db-collection-remove"><a href="#3-4-3-db-collection-remove" class="headerlink" title="3.4.3 db.collection.remove()"></a>3.4.3 db.collection.remove()</h6><p><strong>---示例：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除所有数据，&#123;&#125;是必须的</span></span><br><span class="line">db.collection.remove(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有name为aaa的数据</span></span><br><span class="line">db.collection.remove(</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除name为aaa的第一条数据</span></span><br><span class="line">db.collection.remove(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">justOne</span>:<span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h6 id="3-4-4-db-collection-drop"><a href="#3-4-4-db-collection-drop" class="headerlink" title="3.4.4 db.collection.drop()"></a>3.4.4 db.collection.drop()</h6><ul><li>删除集合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架入门笔记(五):Django高级应用</title>
      <link href="/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%BA%94-Django%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8.html"/>
      <url>/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%BA%94-Django%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/03/kLThy8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架入门笔记(四):模板Templates</title>
      <link href="/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E6%A8%A1%E6%9D%BFTemplates.html"/>
      <url>/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E6%A8%A1%E6%9D%BFTemplates.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/03/kLT4OS.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架入门笔记(三):视图Views</title>
      <link href="/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%B8%89-%E8%A7%86%E5%9B%BEViews.html"/>
      <url>/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%B8%89-%E8%A7%86%E5%9B%BEViews.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/03/03/kLTfQf.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架入门笔记(二):模型Models</title>
      <link href="/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E6%A8%A1%E5%9E%8BModels.html"/>
      <url>/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E6%A8%A1%E5%9E%8BModels.html</url>
      
        <content type="html"><![CDATA[<h3 id="模型Models"><a href="#模型Models" class="headerlink" title="模型Models"></a>模型Models</h3><p><img src="https://s2.ax1x.com/2019/03/03/kLOGdO.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架入门笔记(一):基础总结</title>
      <link href="/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.html"/>
      <url>/Django%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Web框架概述"><a href="#一、Web框架概述" class="headerlink" title="一、Web框架概述"></a>一、Web框架概述</h3><p>Web框架(web framework)或者叫做Web应用框架(web application framework)，是用于进行Web开发的一套软件架构。大多数的Web框架提供了一套开发和部署网站的方式。为Web的行为提供了一套支持支持的方法。使用Web框架，很多的业务逻辑外的功能不需要自己再去完善，而是使用框架已有的功能就可以。</p><p>Web框架使得在进行Web应用开发的时候，减少了工作量。Web框架主要用于动态网络开发，动态网络主要是指现在的主要的页面，可以实现数据的交互和业务功能的完善。使用Web框架进行Web开发的时候，在进行数据缓存、数据库访问、数据安全校验等方面，不需要自己再重新实现，而是将业务逻辑相关的代码写入框架就可以。也就是说，通过对Web框架进行主观上的“缝缝补补”，就可以实现自己进行Web开发的需求了。</p><h3 id="二、MVC与MTV模型"><a href="#二、MVC与MTV模型" class="headerlink" title="二、MVC与MTV模型"></a>二、MVC与MTV模型</h3><p>MVC(Model View Controller)：是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p>MTV: 有些WEB框架觉得MVC的字面意思很别扭，就给它改了一下。view不再是HTML相关，而是主业务逻辑了，相当于控制器。html被放在Templates中，称作模板，于是MVC就变成了MTV。这其实就是一个文字游戏，和MVC本质上是一样的，换了个名字和叫法而已，换汤不换药。<br><span id="more"></span></p><h4 id="2-1-MVC"><a href="#2-1-MVC" class="headerlink" title="2.1 MVC"></a>2.1 MVC</h4><ul><li>Web服务器开发领域里著名的MVC模式，将web应用分为以下三层：<ul><li>模型(Model)</li><li>视图(View)</li><li>控制器(Controller)</li></ul></li><li>以上三层之间以一种插件式的、松耦合的方式连接在一起：<ul><li>模型负责业务对象与数据库的映射(ORM)</li><li>视图负责与用户的交互(页面)</li><li>控制器接受用户的输入调用模型和视图完成用户的请求。</li></ul></li><li>其示意图如下所示：</li></ul><p><img src="https://s2.ax1x.com/2019/03/03/kLIHBQ.png" alt=""></p><h4 id="2-2-MTV"><a href="#2-2-MTV" class="headerlink" title="2.2 MTV"></a>2.2 MTV</h4><p>Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是指：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。</span><br><span class="line">T 代表模板 (Template)：负责如何把页面展示给用户(html)。</span><br><span class="line">V 代表视图（View）：   负责业务逻辑，并在适当时候调用Model和Template。</span><br></pre></td></tr></table></figure><br>除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：</p><p><img src="https://s2.ax1x.com/2019/03/03/kLIb7j.png" alt=""></p><p>用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数，，视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中，最后返回网页给用户。</p><ul><li>Django 的MTV模型组织</li></ul><p><img src="https://s2.ax1x.com/2019/03/03/kLI7ng.jpg" alt=""></p><hr><h3 id="三、Django基础"><a href="#三、Django基础" class="headerlink" title="三、Django基础"></a>三、Django基础</h3><p><img src="https://s2.ax1x.com/2019/03/03/kLOJoD.png" alt=""></p><hr><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/fengbo1113/p/8547302.html">https://www.cnblogs.com/fengbo1113/p/8547302.html</a></li><li><a href="https://www.bilibili.com/video/av17879644?from=search&amp;seid=3050711219062248607">Django基础到实战讲解（精华版）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3-Selenium开启自动化测试</title>
      <link href="/Python3-Selenium%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"/>
      <url>/Python3-Selenium%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Selenium简介"><a href="#一、Selenium简介" class="headerlink" title="一、Selenium简介"></a>一、Selenium简介</h3><p>Selenium是一款适用于Web应用程序的便携式软件测试框架。 Selenium为编写测试提供了一个回放工具，无需学习测试脚本语言。它还提供了一种测试领域特定的语言，用于编写包括C＃，Groovy，Java，Perl，PHP，Python，Ruby和Scala等多种流行编程语言的测试。</p><p><a href="https://www.seleniumhq.org/">Selenium官网地址</a></p><h5 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h5><blockquote><p>系统：windows10<br>浏览器：Chrome 70.0.3538.110<br>Python: 3.7.0<br>Selenium: 3.141.0</p></blockquote><span id="more"></span><hr><h3 id="二、Selenium的安装与测试"><a href="#二、Selenium的安装与测试" class="headerlink" title="二、Selenium的安装与测试"></a>二、Selenium的安装与测试</h3><h4 id="2-1-Selenium安装"><a href="#2-1-Selenium安装" class="headerlink" title="2.1 Selenium安装"></a>2.1 Selenium安装</h4><p>使用Python可直接利用pip进行安装selenium</p><blockquote><p>pip install selenium</p></blockquote><h4 id="2-2-浏览器驱动driver安装"><a href="#2-2-浏览器驱动driver安装" class="headerlink" title="2.2 浏览器驱动driver安装"></a>2.2 浏览器驱动driver安装</h4><h5 id="2-2-1-浏览器驱动driver的下载"><a href="#2-2-1-浏览器驱动driver的下载" class="headerlink" title="2.2.1 浏览器驱动driver的下载"></a>2.2.1 浏览器驱动driver的下载</h5><ul><li>下载地址：<a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">Google Chrome driver</a></li></ul><p>注意：driver的下载需要注意对应浏览器的版本</p><h5 id="2-2-2-浏览器驱动driver的安装"><a href="#2-2-2-浏览器驱动driver的安装" class="headerlink" title="2.2.2 浏览器驱动driver的安装"></a>2.2.2 浏览器驱动driver的安装</h5><p>下载下来的zip文件解压至python安装目录中，可以放在： <code>C:\Users\Administrator\AppData\Local\Programs\Python\Python37</code>中，但是推荐放置在scripts目录中：<code>C:\Users\Administrator\AppData\Local\Programs\Python\Python37\Scripts</code></p><p>完成以上工作，我们就可以进行测试使用selenium驱动浏览器了。</p><h4 id="2-3-测试驱动浏览器"><a href="#2-3-测试驱动浏览器" class="headerlink" title="2.3 测试驱动浏览器"></a>2.3 测试驱动浏览器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">driver.quit() <span class="comment"># 使用quit()关闭了chrome并结束了此次测试，如果是close()只是关闭chrome，后台仍在进行。</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/03/03/kLwAfI.png" alt=""></p><p>看起来正常驱动浏览器并打开了网页，这样我们就完成了selenium自动化测试的准备工作~!</p><p>完成环境的安装并测试之后，我们对Selenium有了一定的了解，接下来我们继续驱动浏览器做一些基本操作。</p><hr><h3 id="三、窗口尺寸设置、网页截图、刷新、前进和后退"><a href="#三、窗口尺寸设置、网页截图、刷新、前进和后退" class="headerlink" title="三、窗口尺寸设置、网页截图、刷新、前进和后退"></a>三、窗口尺寸设置、网页截图、刷新、前进和后退</h3><h4 id="3-1-窗口尺寸设置"><a href="#3-1-窗口尺寸设置" class="headerlink" title="3.1 窗口尺寸设置"></a>3.1 窗口尺寸设置</h4><p>在测试过程中，我们可能会要求打开浏览器的窗口处于最大化或者设置为某一特定尺寸的大小，所以我们使用selenium驱动浏览器时设定窗口大小.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">size = driver.get_window_size()    <span class="comment"># 获取窗口尺寸</span></span><br><span class="line"></span><br><span class="line">driver.set_window_size(<span class="number">800</span>,<span class="number">600</span>)    <span class="comment"># 设置窗口尺寸</span></span><br><span class="line"></span><br><span class="line">driver.minimize_window()           <span class="comment"># 最小化窗口</span></span><br><span class="line"></span><br><span class="line">driver.maximize_window()           <span class="comment"># 最大化窗口</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-网页截图"><a href="#3-2-网页截图" class="headerlink" title="3.2 网页截图"></a>3.2 网页截图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get_screenshot_as_file(<span class="string">u&#x27;D:\\xxx.png&#x27;</span>)  <span class="comment"># 前缀u解决编码问题</span></span><br></pre></td></tr></table></figure><h4 id="3-3-刷新、前进和后退"><a href="#3-3-刷新、前进和后退" class="headerlink" title="3.3 刷新、前进和后退"></a>3.3 刷新、前进和后退</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.get(<span class="string">&quot;https://www.google.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行后退、前进操作</span></span><br><span class="line">driver.back()    <span class="comment"># 后退</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.forward() <span class="comment"># 前进</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.refresh() <span class="comment"># 对网页进行刷新</span></span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><hr><h4 id="四、定位元素"><a href="#四、定位元素" class="headerlink" title="四、定位元素"></a>四、定位元素</h4><p>selenium提供了多种方式进行定位元素：<code>find_element_by_* </code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br></pre></td></tr></table></figure><br>当然也可以一次定位多个元素：<code>find_elements_by_* </code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><br>因为id是唯一的，所以一次定位多个元素是没有办法通过id进行定位的。</p><hr><h3 id="五、对定位到的元素进行操作"><a href="#五、对定位到的元素进行操作" class="headerlink" title="五、对定位到的元素进行操作"></a>五、对定位到的元素进行操作</h3><p>我们通过<code>find_element_by_xpath</code>等一系列定位元素的方法获取到网页元素(文本框、按钮等)后，我们可以通过一些函数来对元素进行操作。</p><h4 id="5-1-输入和点击"><a href="#5-1-输入和点击" class="headerlink" title="5.1 输入和点击"></a>5.1 输入和点击</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;&#x27;</span>).clear() <span class="comment"># 清空文本框内容</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;&#x27;</span>).send_keys() <span class="comment"># 向文本框中输入内容</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;&#x27;</span>).click() <span class="comment"># 鼠标单击操作</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;&#x27;</span>).submit() <span class="comment"># 对信息进行提交，相当于回车</span></span><br><span class="line"><span class="comment"># submit()要求提交对象是一个表单，click()更强调事件的独立性</span></span><br></pre></td></tr></table></figure><h4 id="5-2-获取元素属性"><a href="#5-2-获取元素属性" class="headerlink" title="5.2 获取元素属性"></a>5.2 获取元素属性</h4><p>通过定位元素位置后，就可以获得元素的诸多属性信息，当然是源代码中元素属性存在的情况下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;http://qzmvc1.top/&quot;</span>)</span><br><span class="line"></span><br><span class="line">a1 = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;post-进击数据挖掘十大算法-四-C4-5决策树&quot;]/div/header/h1/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a1)</span><br><span class="line"><span class="built_in">print</span>(a1.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(a1.text)</span><br><span class="line"><span class="built_in">print</span>(a1.tag_name)</span><br><span class="line"><span class="built_in">print</span>(a1.size)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/03/03/kLys9H.png" alt=""><br>在上述代码中，依次通过 <code>.get_attribute(‘href’)</code>、 <code>element.text</code>、<code>element.tag_name</code>、 <code>element.size</code>获得了属性值href、元素文本内容、元素标签名、元素尺寸这些常用的方法。</p><hr><h3 id="六、键盘和鼠标模拟"><a href="#六、键盘和鼠标模拟" class="headerlink" title="六、键盘和鼠标模拟"></a>六、键盘和鼠标模拟</h3><h4 id="6-1-键盘事件"><a href="#6-1-键盘事件" class="headerlink" title="6.1 键盘事件"></a>6.1 键盘事件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;xxx&#x27;</span>).send_keys(Keys.BACK_SPACE)  <span class="comment"># 利用backspace键删除字符串最后一位</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">send_keys(Keys.BACK_SPACE) 删除键（BackSpace）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.SPACE) 空格键(Space)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.TAB) 制表键(Tab)</span><br><span class="line"></span><br><span class="line">send_keys(Keys.ESCAPE) 回退键（Esc）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.ENTER) 回车键（Enter）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.CONTROL, <span class="string">&#x27;a&#x27;</span>) 全选（Ctrl+A）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.CONTROL, <span class="string">&#x27;c&#x27;</span>) 复制（Ctrl+C）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.CONTROL, <span class="string">&#x27;x&#x27;</span>) 剪切（Ctrl+X）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.CONTROL, <span class="string">&#x27;v&#x27;</span>) 粘贴（Ctrl+V）</span><br><span class="line"></span><br><span class="line">send_keys(Keys.F1) 键盘 F1</span><br><span class="line">...</span><br><span class="line">send_keys(Keys.F12) 键盘 F12</span><br></pre></td></tr></table></figure><h4 id="6-2-鼠标事件"><a href="#6-2-鼠标事件" class="headerlink" title="6.2 鼠标事件"></a>6.2 鼠标事件</h4><p>ActionChains是一种自动执行低级别交互的方法，例如鼠标移动，鼠标按钮操作，按键和上下文菜单交互。这对于执行更复杂的操作非常有用，例如悬停和拖放。</p><ul><li>在ActionChains对象上调用操作方法时，操作将存储在ActionChains对象的队列中。</li><li><p>当调用perform()时，事件将按它们排队的<strong>顺序触发</strong>。</p><p>ActionChains可以用于<strong>链式</strong>或者可以将操作逐个排队，然后执行。</p></li></ul><p>无论哪种方式，动作都按照它们被调用的顺序执行，一个在另一个之后执行。</p><p>这里还是以代码展示部分功能吧：</p><h6 id="方法一：可以写一长串"><a href="#方法一：可以写一长串" class="headerlink" title="方法一：可以写一长串"></a>方法一：可以写一长串</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">menu = driver.find_element_by_css_selector(<span class="string">&quot;.nav&quot;</span>)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(<span class="string">&quot;.nav #submenu1&quot;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform()</span><br></pre></td></tr></table></figure><h6 id="方法二：可以分几步写"><a href="#方法二：可以分几步写" class="headerlink" title="方法二：可以分几步写"></a>方法二：可以分几步写</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(<span class="string">&quot;.nav&quot;</span>)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(<span class="string">&quot;.nav #submenu1&quot;</span>)</span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.move_to_element(menu)</span><br><span class="line">actions.click(hidden_submenu)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p>其他操作如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">click(on_element=<span class="literal">None</span>) ——单击鼠标左键</span><br><span class="line"></span><br><span class="line">click_and_hold(on_element=<span class="literal">None</span>) ——点击鼠标左键，不松开</span><br><span class="line"></span><br><span class="line">context_click(on_element=<span class="literal">None</span>) ——点击鼠标右键</span><br><span class="line"></span><br><span class="line">double_click(on_element=<span class="literal">None</span>) ——双击鼠标左键</span><br><span class="line"></span><br><span class="line">drag_and_drop(source, target) ——拖拽到某个元素然后松开</span><br><span class="line"></span><br><span class="line">drag_and_drop_by_offset(source, xoffset, yoffset) ——拖拽到某个坐标然后松开</span><br><span class="line"></span><br><span class="line">key_down(value, element=<span class="literal">None</span>) ——按下某个键盘上的键</span><br><span class="line"></span><br><span class="line">key_up(value, element=<span class="literal">None</span>) ——松开某个键</span><br><span class="line"></span><br><span class="line">move_by_offset(xoffset, yoffset) ——鼠标从当前位置移动到某个坐标</span><br><span class="line"></span><br><span class="line">move_to_element(to_element) ——鼠标移动到某个元素</span><br><span class="line"></span><br><span class="line">move_to_element_with_offset(to_element, xoffset, yoffset) ——移动到距某个元素（左上角坐标）多少距离的位置</span><br><span class="line"></span><br><span class="line">perform() ——执行链中的所有动作</span><br><span class="line"></span><br><span class="line">release(on_element=<span class="literal">None</span>) ——在某个元素位置松开鼠标左键</span><br><span class="line"></span><br><span class="line">send_keys(*keys_to_send) ——发送某个键到当前焦点的元素</span><br><span class="line"></span><br><span class="line">send_keys_to_element(element, *keys_to_send) ——发送某个键到指定元素</span><br></pre></td></tr></table></figure></p><hr><h3 id="七、下拉框和弹窗"><a href="#七、下拉框和弹窗" class="headerlink" title="七、下拉框和弹窗"></a>七、下拉框和弹窗</h3><h4 id="7-1-下拉框"><a href="#7-1-下拉框" class="headerlink" title="7.1 下拉框"></a>7.1 下拉框</h4><h5 id="7-1-1-首先导入Select模块："><a href="#7-1-1-首先导入Select模块：" class="headerlink" title="7.1.1 首先导入Select模块："></a>7.1.1 首先导入Select模块：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br></pre></td></tr></table></figure><h5 id="7-1-2-Select提供了三种选择某一项的方法"><a href="#7-1-2-Select提供了三种选择某一项的方法" class="headerlink" title="7.1.2 Select提供了三种选择某一项的方法"></a>7.1.2 Select提供了三种选择某一项的方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> select_by_index          <span class="comment"># 通过索引定位</span></span><br><span class="line"><span class="number">2</span> select_by_value          <span class="comment"># 通过value值定位</span></span><br><span class="line"><span class="number">3</span> select_by_visible_text   <span class="comment"># 通过文本值定位</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>index索引是从“0”开始；</p><p>value是option标签的一个属性值，并不是显示在下拉框中的值；</p><p>visible_text是在option标签中间的值，是显示在下拉框的值；</p></blockquote><h5 id="7-1-3-Select提供了三种返回options信息的方法"><a href="#7-1-3-Select提供了三种返回options信息的方法" class="headerlink" title="7.1.3 Select提供了三种返回options信息的方法"></a>7.1.3 Select提供了三种返回options信息的方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> options                  <span class="comment"># 返回select元素所有的options</span></span><br><span class="line"><span class="number">2</span> all_selected_options     <span class="comment"># 返回select元素中所有已选中的选项</span></span><br><span class="line"><span class="number">3</span> first_selected_options   <span class="comment"># 返回select元素中选中的第一个选项</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>这三种方法的作用是查看已选中的元素是否是自己希望选择的：</p><p>options：提供所有选项的元素列表；</p><p>all_selected_options：提供所有被选中选项的元素列表；</p><p>first_selected_option：提供第一个被选中的选项元素；</p></blockquote><h5 id="7-1-4-Select提供了四种取消选中项的方法"><a href="#7-1-4-Select提供了四种取消选中项的方法" class="headerlink" title="7.1.4 Select提供了四种取消选中项的方法"></a>7.1.4 Select提供了四种取消选中项的方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> deselect_all             <span class="comment"># 取消全部的已选择项</span></span><br><span class="line"><span class="number">2</span> deselect_by_index        <span class="comment"># 取消已选中的索引项</span></span><br><span class="line"><span class="number">3</span> deselect_by_value        <span class="comment"># 取消已选中的value值</span></span><br><span class="line"><span class="number">4</span> deselect_by_visible_text <span class="comment"># 取消已选中的文本值</span></span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>在日常的web测试中，会经常遇到某些下拉框选项已经被默认选中，这种时候就需要用到这里所说的四种方法</p></blockquote><h5 id="7-1-5-代码示例"><a href="#7-1-5-代码示例" class="headerlink" title="7.1.5 代码示例"></a>7.1.5 代码示例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引选择</span></span><br><span class="line">Select(driver.find_element_by_name(<span class="string">&quot;xxx&quot;</span>)).select_by_index(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="comment"># 根据value值选择</span></span><br><span class="line">Select(driver.find_element_by_name(<span class="string">&quot;xxx&quot;</span>)).select_by_value(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="comment"># 根据文本值选择</span></span><br><span class="line">Select(driver.find_element_by_name(<span class="string">&quot;xxx&quot;</span>)).select_by_visible_text(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="7-2-弹窗"><a href="#7-2-弹窗" class="headerlink" title="7.2 弹窗"></a>7.2 弹窗</h4><p>在完成某些操作时会弹出对话框来提示，主要分为”警告消息框”,”确认消息框”,”提示消息对话”三种类型的对话框。</p><p>1.警告消息框（alert）<br>　　警告消息框提供了一个”确定”按钮让用户关闭该消息框，并且该消息框是模式对话框，也就是说用户必须先关闭该消息框然后才能继续进行操作。</p><p>2.确认消息框（confirm）<br>　　确认消息框向用户提示一个”是与否”问题，用户可以根据选择”确定”按钮和”取消”按钮。</p><p>3.提示消息对话（prompt）<br>　　提示消息框提供了一个文本字段，用户可以在此字段输入一个答案来响应您的提示。该消息框有一个”确定”按钮和一个”取消”按钮。选择”确认”会响应对应的提示信息，选择”取消”会关闭对话框。</p><p>selenium 提供switch_to.alert()方法定位到 alert/confirm/prompt对话框。使用 text/accept/dismiss/send_keys 进行操作，这里注意的是send_keys只能对prompt进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch_to.alert() 　　<span class="comment">#定位弹出对话</span></span><br><span class="line">text 　　             <span class="comment">#获取对话框文本值</span></span><br><span class="line">accept()              <span class="comment">#相当于点击&quot;确认&quot;</span></span><br><span class="line">dismiss()            <span class="comment">#相当于点击&quot;取消&quot;</span></span><br><span class="line">send_keys()          <span class="comment"># 输入值，只能对prompt使用。</span></span><br><span class="line"></span><br><span class="line">alert = driver.switch_to.alert()</span><br><span class="line">alert.text</span><br><span class="line">alert.accept()</span><br><span class="line">alert.dismiss()</span><br></pre></td></tr></table></figure><h3 id="八、等待方式"><a href="#八、等待方式" class="headerlink" title="八、等待方式"></a>八、等待方式</h3><p>在webdriver只有两种类型等待方式，显式等待和隐式等待，之前是在程序运行过程中使用time模块中的sleep进行代码的休眠进行强制等待，是显式等待中的一种极端情况。</p><h4 id="8-1-显式等待"><a href="#8-1-显式等待" class="headerlink" title="8.1 显式等待"></a>8.1 显式等待</h4><p>显式等待是你在代码中定义等待一定条件发生后再进一步执行你的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(ctime())</span><br><span class="line">    element = WebDriverWait(dr, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">&quot;kw&quot;</span>))</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># WebDriverWait(driver=self.driver, timeout=300, poll_frequency=0.5,  ignored_exceptions=None)</span></span><br><span class="line">    <span class="comment"># driver：浏览器驱动</span></span><br><span class="line">    <span class="comment"># timeout：最长超时等待时间</span></span><br><span class="line">    <span class="comment"># poll_frequency：检测的时间间隔，默认为500ms</span></span><br><span class="line">    <span class="comment"># ignore_exception：超时后抛出的异常信息，默认情况下抛出 NoSuchElementException 异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我已找到&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(ctime())</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><br>以上代码执行后就发现，整段代码执行速度非常快，即使我在WebDriverWait中设置10秒，也不会等待10秒的情况，因为在不到一秒内，已经完成了加载并定位id为“kw”的元素。</p><p>通过WebDriverWait 和 ExpectedCondition 组合使用，让我们的代码执行只需要等待需要的时长，而不是固定的时长，这样最大限度的节省时间。</p><p> 此外ExpectedCondition类中提供了很多预期条件判断方法，省去了再创建包的功夫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">title_is：判断当前页面的title是否等于预期</span><br><span class="line">title_contains：判断当前页面的title是否包含预期字符串</span><br><span class="line">presence_of_element_located：判断某个元素是否被加到了dom树里，并不代表该元素一定可见</span><br><span class="line">visibility_of_element_located：判断某个元素是否可见. 可见代表元素非隐藏，并且元素的宽和高都不等于0</span><br><span class="line">visibility_of：跟上面的方法做一样的事情，只是上面的方法要传入locator，这个方法直接传定位到的element就好了</span><br><span class="line">presence_of_all_elements_located：判断是否至少有1个元素存在于dom树中。举个例子，如果页面上有n个元素的class都是&#x27;column-md-3&#x27;，那么只要有1个元素存在，这个方法就返回True</span><br><span class="line">text_to_be_present_in_element：判断某个元素中的text是否 包含 了预期的字符串</span><br><span class="line">text_to_be_present_in_element_value：判断某个元素中的value属性是否包含了预期的字符串</span><br><span class="line">frame_to_be_available_and_switch_to_it：判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False</span><br><span class="line">invisibility_of_element_located：判断某个元素中是否不存在于dom树或不可见</span><br><span class="line">element_to_be_clickable - it is Displayed and Enabled：判断某个元素中是否可见并且是enable的，这样的话才叫clickable</span><br><span class="line">staleness_of：等某个元素从dom树中移除，注意，这个方法也是返回True或False</span><br><span class="line">element_to_be_selected：判断某个元素是否被选中了,一般用在下拉列表</span><br><span class="line">element_located_to_be_selected</span><br><span class="line">element_selection_state_to_be：判断某个元素的选中状态是否符合预期</span><br><span class="line">element_located_selection_state_to_be：跟上面的方法作用一样，只是上面的方法传入定位到的element，而这个方法传入locator</span><br><span class="line">alert_is_present：判断页面上是否存在alert</span><br></pre></td></tr></table></figure><h4 id="8-2-隐式等待"><a href="#8-2-隐式等待" class="headerlink" title="8.2 隐式等待"></a>8.2 隐式等待</h4><p>隐式等待，就是在创建driver时，为浏览器对象创建一个等待时间，这个方法是得不到某个元素就等待一段时间，直到拿到某个元素位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicity_wait(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br>implicity_wait()默认参数的单位为妙，本例中设置等待时长为10秒，首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位是，如果元素可以定位，则继续执行，如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第六秒定位到了元素则继续执行，若直到超出设置的时长10秒还没有定位到元素，则抛出异常。</p><hr><h3 id="九、iframe切换"><a href="#九、iframe切换" class="headerlink" title="九、iframe切换"></a>九、iframe切换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="string">&#x27;&#x27;</span>)                  <span class="comment"># 选择iframe</span></span><br><span class="line">driver.switch_to.default_content()        <span class="comment"># 回到主页面</span></span><br></pre></td></tr></table></figure><p>说明：<strong>switch_to_frame接受的参数是iframe的id或者name属性</strong>，如果没有，则可以通过find_element_by_tag_name(‘iframe’)找到iframe，然后作为参数定位。</p><hr><p>参考链接：<a href="https://www.cnblogs.com/lvzb86/">https://www.cnblogs.com/lvzb86/</a></p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Selenium </tag>
            
            <tag> Modules </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy、Scipy、Pandas函数用法及问题汇总(长期更新)</title>
      <link href="/Numpy_Scipy_Pandas%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0.html"/>
      <url>/Numpy_Scipy_Pandas%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、-Pandas"><a href="#一、-Pandas" class="headerlink" title="一、 Pandas"></a>一、 Pandas</h3><h4 id="1-1-describe"><a href="#1-1-describe" class="headerlink" title="1.1 describe()"></a>1.1 describe()</h4><p><img src="https://s2.ax1x.com/2019/02/21/kW3t4f.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/02/21/kW3YUP.png" alt=""><br><span id="more"></span></p><h4 id="1-2-cut"><a href="#1-2-cut" class="headerlink" title="1.2 cut()"></a>1.2 cut()</h4><p><a href="https://www.jianshu.com/p/da693c438316">pandas的分段函数cut()</a></p><h4 id="1-3-rolling"><a href="#1-3-rolling" class="headerlink" title="1.3 rolling()"></a>1.3 rolling()</h4><p><a href="https://blog.csdn.net/maymay_/article/details/80241627">pandas —移动窗口rolling的概念</a></p><hr><h3 id="二、-Matplotlib"><a href="#二、-Matplotlib" class="headerlink" title="二、 Matplotlib"></a>二、 Matplotlib</h3><h4 id="2-1-rcParams"><a href="#2-1-rcParams" class="headerlink" title="2.1 rcParams"></a>2.1 rcParams</h4><p>plt.rcParams[‘font.sans-serif’] = [‘SimHei’] # 用来正常显示中文标签<br>plt.rcParams[‘axes.unicode_minus’] = False # 用来正常显示负号</p><hr><h3 id="三、-Numpy"><a href="#三、-Numpy" class="headerlink" title="三、 Numpy"></a>三、 Numpy</h3><hr><h3 id="四、Scipy"><a href="#四、Scipy" class="headerlink" title="四、Scipy"></a>四、Scipy</h3>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(四):C4.5决策树</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%9B%9B-C4-5%E5%86%B3%E7%AD%96%E6%A0%91.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E5%9B%9B-C4-5%E5%86%B3%E7%AD%96%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、从分类问题开始"><a href="#一、从分类问题开始" class="headerlink" title="一、从分类问题开始"></a>一、从分类问题开始</h3><p><strong>分类（Classification）任务就是确定对象属于哪个预定义的目标类。</strong> 分类问题不仅是一个普遍存在的问题，而且是其他更加复杂的决策问题的基础，更是机器学习和数据挖掘技术中最庞大的一类算法家族。我们前面介绍过的朴素贝叶斯就可以用来解决分类问题。作为本文的开始，我们首先来简单回顾一下什么是分类。</p><p>分类问题的本质就是当给定这样一个数据集后，要求我们训练出（或建立）一个模型$f$。当出现一组新的特征向量时，要求我们预测（或判断）拥有这样一组特征向量的对象应当属于哪个类别。</p><p>分类问题的类别数目可以是两类也可以是多类。二分类问题是最简单的分类问题，而多分类问题模型可以在二分类模型的基础上进行构建。我们在前面文章中一直使用的鸢尾花数据集就是一个典型的多分类问题，问题的最终目标是判断给定一朵花，它应该属于setosa、versicolor和virginica中的哪一类。<br><span id="more"></span></p><hr><h3 id="二、决策树基础"><a href="#二、决策树基础" class="headerlink" title="二、决策树基础"></a>二、决策树基础</h3><h4 id="2-1-什么是决策树"><a href="#2-1-什么是决策树" class="headerlink" title="2.1 什么是决策树"></a>2.1 什么是决策树</h4><p>决策树是一种用于对实例进行分类的树形结构。决策树由节点（node）和有向边（directed edge）组成。节点的类型有两种：内部节点和叶子节点。其中，内部节点表示一个特征或属性的测试条件（用于分开具有不同特性的记录），叶子节点表示一个分类。</p><p>一旦我们构造了一个决策树模型，以它为基础来进行分类将是非常容易的。具体做法是，从根节点开始，对实例的某一特征进行测试，根据测试结构将实例分配到其子节点（也就是选择适当的分支）；沿着该分支可能达到叶子节点或者到达另一个内部节点。如果到达内部节点，那么就使用新的测试条件递归执行下去，直到抵达一个叶子节点。当到达叶子节点时，我们便得到了最终的分类结果。</p><p>下图是一个决策树的示例（注意我们仅用了两个feature就对数据集中的5个记录实现了准确的分类）：</p><p><img src="https://s2.ax1x.com/2019/02/17/kyJdAO.png" alt=""></p><p>我们可以把决策树看作是一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：</p><ul><li>由决策树的根节点到叶节点的每一条路径构建一条规则</li><li>路径上中间节点的特征对应着规则的条件，叶节点的类标签对应着规则的结论</li></ul><p>决策树的路径或者其对应的if-then规则集合有一个重要的性质：<strong>互斥并且完备</strong>。也就是说，每一个实例都被<strong>有且仅有一条</strong>路径或者规则所覆盖。这里的覆盖是指实例的特征与路径上的特征一致，或实例满足规则的条件。</p><h4 id="2-2-决策树的构建准备工作"><a href="#2-2-决策树的构建准备工作" class="headerlink" title="2.2 决策树的构建准备工作"></a>2.2 决策树的构建准备工作</h4><p>使用决策树做分类的每一个步骤都很重要，首先我们要收集足够多的数据，如果数据收集不到位，将会导致没有足够的特征去构建错误率低的决策树。数据特征充足，但是不知道用哪些特征好，也会导致最终无法构建出分类效果好的决策树。从算法方面来看的话，决策树的构建就是我们的核心内容。<br>决策树如何构建呢？通常，这一过程可以概括为3个步骤：特征选择、决策树的生成和决策树的剪枝。</p><h5 id="2-2-1-特征选择"><a href="#2-2-1-特征选择" class="headerlink" title="2.2.1 特征选择"></a>2.2.1 特征选择</h5><p>特征选择就是决定用哪个特征来划分特征空间，其目的在于选取对训练数据具有分类能力的特征。这样可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大的差别，则称这个特征是没有分类能力的，经验上扔掉这些特征对决策树学习的精度影响不会很大。<br>那如何来选择最优的特征来划分呢？一般而言，随着划分过程不断进行，我们希望决策树的分支节点所包含的样本尽可能属于同一类别，也就是节点的纯度（purity）越来越高。</p><p>在实际使用中，我们衡量的常常是不纯度。度量不纯度的指标有很多种，比如：熵、增益率、基尼值数。这里我们使用的是熵，也叫作香农熵，这个名字来源于信息论之父：克劳德·香农。</p><h6 id="1-香浓熵"><a href="#1-香浓熵" class="headerlink" title="(1) 香浓熵"></a>(1) 香浓熵</h6><p>熵定义为信息的期望值。在信息论与概率统计中，熵是表示随机变量不确定性的度量。<br>假定当前样本集合D中一共有n类样本，第i类样本为$x_i$，那么$x_i$的信息定义为：</p><script type="math/tex; mode=display">l(x_i)=-log_2{p(x_i)}</script><p>其中 $p(x_i)$ 是选择该分类的概率。</p><p>通过上式，我们可以得到所有类别的信息。为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值(数学期望)，通过下面的公式得到：</p><script type="math/tex; mode=display">Ent(D)=-\sum_{i=1}^{n}p(x_i)log_2p(x_i)</script><p>$Ent(D)$ 的值越小，则D的不纯度就越低。</p><h6 id="2-信息增益"><a href="#2-信息增益" class="headerlink" title="(2) 信息增益"></a>(2) 信息增益</h6><p><strong>信息增益（Information Gain）的计算公式其实就是父节点的信息熵与其下所有子节点总信息熵之差</strong>。但这里要注意的是，此时计算子节点的总信息熵不能简单求和，而要求在求和汇总之前进行修正。</p><p>假设离散属性A有V个可能的取值 $\{A^1,A^2,\ldots,A^V\}$，若使用A对样本数据集D进行划分，则会产生V个分支节点，其中第v个分支节点包含了D中所有在属性A上取值为$A^v$的样本，记为$D^v$.我们可根据信息熵的计算公式计算出$D^v$的信息熵，再考虑到不同的分支节点所包含的样本数不同，给分支节点赋予权重 $|D^v|/D$ ，这就是所谓的的修正。</p><p>所以信息增益的计算公式为：</p><script type="math/tex; mode=display">Gain(D,A)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)</script><h6 id="3-信息增益率"><a href="#3-信息增益率" class="headerlink" title="(3) 信息增益率"></a>(3) 信息增益率</h6><p>信息增益率 = 惩罚参数 * 信息增益<br>公式：</p><script type="math/tex; mode=display">IGR(D,A)=\frac{Gain(D,A)}{H_A(D)}</script><script type="math/tex; mode=display">H_A(D)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}</script><p><strong>信息增益率本质： 是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。</strong></p><p>使用信息增益率：并不是直接选择信息增益率最大的特征，而是先在候选特征中找出信息增益高于平均水平的特征，然后在这些特征中再选择信息增益率最高的特征。</p><hr><h3 id="三、C4-5决策树基本思想"><a href="#三、C4-5决策树基本思想" class="headerlink" title="三、C4.5决策树基本思想"></a>三、C4.5决策树基本思想</h3><p>下面以一个例子来详细说明C4.5的基本思想</p><p><img src="https://s2.ax1x.com/2019/02/18/k66Ar8.png" alt=""></p><p>上述数据集有四个属性，属性集合A={天气，温度，湿度，风速}， 类别标签有两个，类别集合L={进行，取消}。</p><h4 id="3-1-计算类别信息熵"><a href="#3-1-计算类别信息熵" class="headerlink" title="3.1 计算类别信息熵"></a>3.1 计算类别信息熵</h4><p>类别信息熵表示的是所有样本中各种类别出现的不确定性之和。根据熵的概念，熵越大，不确定性就越大，把事情搞清楚所需要的信息量就越多。</p><p><code>Ent(D) = -9/14 * log2(9/14)-5/14 * log2(5/14) = 0.940</code></p><h4 id="3-2-计算每个属性的信息熵"><a href="#3-2-计算每个属性的信息熵" class="headerlink" title="3.2 计算每个属性的信息熵"></a>3.2 计算每个属性的信息熵</h4><p>每个属性的信息熵相当于一种条件熵。他表示的是在某种属性的条件下，各种类别出现的不确定性之和。属性的信息熵越大，表示这个属性中拥有的样本类别越不“纯”。</p><p><code>Ent(天气) = 5/14 * [-2/5 * log2(2/5) - 3/5 * log2(3/5)] + 4/14 * [-4/4 * log2(4/4)] + 5/14 * [-3/5 * log2(3/5) - 2/5 * log2(2/5)] = 0.694</code></p><p><code>Ent(温度) = 4/14 * [-2/4 * log2(2/4) - 2/4 * log2(2/4)] + 6/14 * [-4/6 * log2(4/6) - 2/6 * log2(2/6)] + 4/14 * [-3/4 * log2(3/4) - 1/4 * log2(1/4)] = 0.911</code></p><p><code>Ent(湿度) = 7/14 * [-3/7 * log2(3/7) - 4/7 * log2(4/7)] + 7/14 * [-6/7 * log2(6/7) - 1/7 * log2(1/7)] = 0.789</code></p><p><code>Ent(风速) = 6/14 * [-3/6 * log2(3/6) - 3/6 * log2(3/6)] + 8/14 * [-6/8 * log2(6/8) - 2/8 * log2(2/8)] = 0.892</code></p><h4 id="3-3-计算信息增益"><a href="#3-3-计算信息增益" class="headerlink" title="3.3 计算信息增益"></a>3.3 计算信息增益</h4><p>信息增益 = 熵 - 条件熵，在这里就是 类别信息熵 - 属性信息熵，它表示的是信息不确定性减少的程度。如果一个属性的信息增益越大，就表示用这个属性进行样本划分可以更好的减少划分后样本的不确定性，当然，选择该属性就可以更快更好地完成我们的分类目标。</p><p><strong>信息增益就是ID3算法的特征选择指标。</strong></p><p><code>Gain(天气) = Ent(D) - Ent(天气) = 0.940 - 0.694 = 0.246</code><br><code>Gain(温度) = Ent(D) - Ent(温度) = 0.940 - 0.911 = 0.029</code><br><code>Gain(湿度) = Ent(D) - Ent(湿度) = 0.940 - 0.789 = 0.150</code><br><code>Gain(天气) = Ent(D) - Ent(风速) = 0.940 - 0.892 = 0.048</code></p><p>但是我们假设这样的情况，每个属性中每种类别都只有一个样本，那这样属性信息熵就等于零，根据信息增益就无法选择出有效分类特征。所以，C4.5选择使用信息增益率对ID3进行改进。</p><h4 id="3-4-计算属性分裂信息度量"><a href="#3-4-计算属性分裂信息度量" class="headerlink" title="3.4 计算属性分裂信息度量"></a>3.4 计算属性分裂信息度量</h4><p>用分裂信息度量来考虑某种属性进行分裂时分支的数量信息和尺寸信息，我们把这些信息称为属性的内在信息（instrisic information）。信息增益率用信息增益 / 内在信息，会导致属性的重要性随着内在信息的增大而减小（也就是说，如果这个属性本身不确定性就很大，那我就越不倾向于选取它），这样算是对单纯用信息增益有所补偿。</p><p><code>H(天气) = -5/14 * log2(5/14) - 5/14 * log2(5/14) - 4/14 * log2(4/14) = 1.577</code><br><code>H(温度) = -4/14 * log2(4/14) - 6/14 * log2(6/14) - 4/14 * log2(4/14) = 1.556</code><br><code>H(湿度) = -7/14 * log2(7/14) - 7/14 * log2(7/14) = 1.0</code><br><code>H(风速) = -6/14 * log2(6/14) - 8/14 * log2(8/14) = 0.985</code></p><h4 id="3-5-计算信息增益率"><a href="#3-5-计算信息增益率" class="headerlink" title="3.5 计算信息增益率"></a>3.5 计算信息增益率</h4><p><code>IGR(天气) = Gain(天气) / H(天气) = 0.246/1.577 = 0.155</code><br><code>IGR(温度) = Gain(温度) / H(温度) = 0.029/1.556 = 0.0186</code><br><code>IGR(湿度) = Gain(湿度) / H(湿度) = 0.151/1.000 = 0.151</code><br><code>IGR(风速) = Gain(风速) / H(风速) = 0.048/0.985 = 0.048</code></p><p>天气的信息增益率最高，选择天气为分裂属性。发现分裂了之后，天气是“阴”的条件下，类别是”纯“的，所以把它定义为叶子节点，选择不“纯”的结点继续分裂。</p><p><img src="https://s2.ax1x.com/2019/02/18/k66kKf.png" alt=""></p><p><strong>在子结点当中重复过程1~5。</strong><br>至此，这个数据集上C4.5的计算过程就算完成了，一棵树也构建出来了。</p><h4 id="3-6-算法流程"><a href="#3-6-算法流程" class="headerlink" title="3.6 算法流程"></a>3.6 算法流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (当前节点”不纯“)</span><br><span class="line">(1)计算当前节点的类别信息熵Ent(D) （以类别取值计算）</span><br><span class="line">(2)计算当前节点各个属性的信息熵Ent(Ai) （以属性取值下的类别取值计算）</span><br><span class="line">(3)计算各个属性的信息增益Gain(Ai)=Ent(D)-Ent(Ai)</span><br><span class="line">(4)计算各个属性的分类信息度量H(Ai) （以属性取值计算）</span><br><span class="line">(5)计算各个属性的信息增益率IGR(Ai)=Gain(Ai)/H(Ai)</span><br><span class="line">end while</span><br><span class="line">当前节点设置为叶子节点</span><br></pre></td></tr></table></figure><hr><h3 id="四、Python代码"><a href="#四、Python代码" class="headerlink" title="四、Python代码"></a>四、Python代码</h3><p>完整源码: <a href="https://github.com/QzmVc1/Data-Mining/tree/master/C4.5%E5%86%B3%E7%AD%96%E6%A0%91">QzmVc1/Data-Mining/C4.5决策树/</a></p><p>这个程序还是有些瑕疵的，比如什么<code>RuntimeWarning: invalid value encountered in double_scalars</code>，看了很久也没发现程序哪里错了，也没找到相应的解决方法…暂且先鸽着吧…但还是可以跑起来的emmm…</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://s2.ax1x.com/2019/02/18/kcwLOe.png" alt=""></p><hr><h3 id="五、优点与缺点"><a href="#五、优点与缺点" class="headerlink" title="五、优点与缺点"></a>五、优点与缺点</h3><p>优点：产生的分类规则易于理解，准确率较高。<br>缺点：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。</p><hr><p>参考链接：<br><a href="https://blog.csdn.net/fuqiuai/article/details/79456971">数据挖掘领域十大经典算法之—C4.5算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(三):朴素贝叶斯</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%89-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%89-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>贝叶斯分类算法是统计学的一种概率分类方法，朴素贝叶斯分类是贝叶斯分类中最简单的一种。其分类原理就是利用贝叶斯公式根据某特征的先验概率计算出其后验概率，然后选择具有最大后验概率的类作为该特征所属的类。之所以称之为 <strong>”朴素”</strong> ，是因为贝叶斯分类只做<strong>最原始、最简单</strong>的假设：<strong>所有的特征之间是统计独立的</strong>。</p><p>假设某样本X有 $\alpha_1,\alpha_2,\ldots,\alpha_n$ 个属性,那么有</p><script type="math/tex; mode=display">P(x) = P(\alpha_1,\alpha_2,\ldots,\alpha_n) = P(\alpha_1) * P(\alpha_2) * \cdots * P(\alpha_n)</script><p>满足这样的公式就说明特征统计独立。</p><span id="more"></span><h4 id="1-1-条件概率公式"><a href="#1-1-条件概率公式" class="headerlink" title="1.1 条件概率公式"></a>1.1 条件概率公式</h4><p>条件概率(Condittional probability)，就是指在事件B发生的情况下，事件A发生的概率，用 P(A|B) 来表示。</p><center><img src = https://s2.ax1x.com/2019/02/06/kYqbb4.jpg /></center><p>根据文氏图可知：在事件B发生的情况下，事件A发生的概率就是P(A∩B)除以P(B)。</p><script type="math/tex; mode=display">P(A|B) = \frac{P(A\bigcap B)}{P(B)}</script><script type="math/tex; mode=display">\Rightarrow P(A\cap B) = P(A|B) * P(B)</script><p>同理可得：</p><script type="math/tex; mode=display">P(A\cap B) = P(B|A) * P(A)</script><p>所以，</p><script type="math/tex; mode=display">P(A|B) * P(B) = P(B|A) * P(A)</script><script type="math/tex; mode=display">\Rightarrow P(A|B) = \frac{P(B|A) * P(A)}{P(B)}</script><p>接着看<strong>全概率公式</strong>，如果事件$A_1,A_2,A_3,\ldots,A_n$构成一个完备事件且都有正概率，那么对于任意一个事件B则有：</p><script type="math/tex; mode=display">P(B) = P(BA_1)+P(BA_2)+\cdots+P(BA_n)</script><script type="math/tex; mode=display">=P(BA_1)P(A_1)+P(BA_2)P(A_2)+\ldots+P(BA_n)P(A_n)</script><p>&lt;/br&gt;</p><script type="math/tex; mode=display">P(B) = \sum_{i=1}^{n}P(A_i)P(B|A_i)</script><h4 id="1-2-贝叶斯推断"><a href="#1-2-贝叶斯推断" class="headerlink" title="1.2 贝叶斯推断"></a>1.2 贝叶斯推断</h4><p>根据条件概率和全概率公式，可以得到贝叶斯公式如下：</p><script type="math/tex; mode=display">P(A|B) = P(A)\frac{P(B|A)}{P(B)}</script><script type="math/tex; mode=display">P(A_i|B) = P(A_i)\frac{P(B|A_i)}{\sum_{i=1}^{n}P(A_i)P(B|A_i)}</script><p><strong>P(A)称为”先验概率”（Prior probability）</strong>，即在B事件发生之前，我们对A事件概率的一个判断。<br><strong>P(A|B)称为”后验概率”（Posterior probability）</strong>，即在B事件发生之后，我们对A事件概率的重新评估。<br> <strong>P(B|A)/P(B)称为”可能性函数”（Likely hood）</strong>，这是一个<strong>调整因子</strong>，使得预估概率更接近真实概率。<br> 所以条件概率可以理解为：<strong>后验概率 = 先验概率 * 调整因子</strong><br>如果”可能性函数”&gt;1，意味着”先验概率”被增强，事件A的发生的可能性变大；<br>如果”可能性函数”=1，意味着B事件无助于判断事件A的可能性;<br>如果”可能性函数”&lt;1，意味着”先验概率”被削弱，事件A的可能性变小。</p><h4 id="1-3-嫁？还是不嫁？这是一个问题……"><a href="#1-3-嫁？还是不嫁？这是一个问题……" class="headerlink" title="1.3 嫁？还是不嫁？这是一个问题……"></a>1.3 嫁？还是不嫁？这是一个问题……</h4><p>为了加深对朴素贝叶斯的理解，我们举个栗子！</p><p><img src="https://s2.ax1x.com/2019/02/06/kYLqQf.png" alt=""></p><p>假如某男（帅，性格不好，不上进）向女生求婚，该女生嫁还是不嫁？<br>根据贝叶斯公式：</p><script type="math/tex; mode=display">P(A|B) = P(A)\frac{P(B|A)}{P(B)}</script><p>转换成分类任务的表达式：</p><script type="math/tex; mode=display">P(类别|特征) = P(类别)\frac{P(特征|类别)}{P(特征)}</script><p>我们这个例子，按照朴素贝叶斯的求解，可以转换为计算$P(嫁|帅　性格不好　不上进)和P(不嫁|帅　性格不好　不上进)$，最终选择嫁与不嫁的答案。</p><p>根据贝叶斯公式可知：</p><script type="math/tex; mode=display">P(嫁|帅　性格不好　不上进)=P(嫁)\frac{P(帅|嫁)P(性格不好|嫁)P(不上进|嫁)}{P(帅　性格不好　不上进)}</script><script type="math/tex; mode=display">P(不嫁|帅　性格不好　不上进)=P(不嫁)\frac{P(帅|不嫁)P(性格不好|不嫁)P(不上进|不嫁)}{P(帅　性格不好　不上进)}</script><p>分母的计算用到的是全概率公式:</p><script type="math/tex; mode=display">P(B) = \sum_{i=1}^{n}P(A_i)P(B|A_i)</script><p>所以</p><script type="math/tex; mode=display">P(帅　性格不好　不上进)=P(嫁)P(帅|嫁)P(性格不好|嫁)P(不上进|嫁)</script><script type="math/tex; mode=display">+P(不嫁)P(帅|不嫁)P(性格不好|不嫁)P(不上进|不嫁)</script><p>由上表可以得出：</p><p>P(嫁)= 5/10 = 1/2</p><p>P(不嫁)= 5/10 = 1/2</p><p>P(帅|嫁) * P(性格不好|嫁) * P(不上进|嫁)= 4/5 * 1/5 * 1/5</p><p>P(帅|不嫁) * P(性格不好|不嫁) * P(不上进|不嫁) = 1/5 * 3/5 * 2/5</p><p>对于类别“嫁”的贝叶斯分子为：<br>P(嫁) * P(帅|嫁) * P(性格不好|嫁) * P(不上进|嫁) = 1/2 * 4/5 * 1/5 * 1/5 = 2/125<br>对于类别“不嫁”的贝叶斯分子为：<br>P(不嫁) * P(帅|不嫁) * P(性格不好|不嫁) * P(不上进|不嫁) = 1/2 * 1/5 * 3/5 * 2/5 = 3/125</p><p>所以最终结果为：<br>P(嫁|帅  性格不好 不上进) = (2/125) / (2/125 + 3/125) = 40%<br>P(不嫁|帅 性格不好 不上进) = (3/125) / (2/125 + 3/125) = 60%<br>60% &gt; 40%，该女生选择不嫁。</p><hr><h3 id="二、朴素贝叶斯种类"><a href="#二、朴素贝叶斯种类" class="headerlink" title="二、朴素贝叶斯种类"></a>二、朴素贝叶斯种类</h3><p>在scikit-learn中，一共有3个朴素贝叶斯的分类算法。分别是GaussianNB，MultinomialNB和BernoulliNB。</p><h4 id="2-1-GaussianNB"><a href="#2-1-GaussianNB" class="headerlink" title="2.1 GaussianNB"></a>2.1 GaussianNB</h4><p>GaussianNB就是先验为高斯分布（正态分布）的朴素贝叶斯，假设每个标签的数据都服从简单的正态分布。</p><script type="math/tex; mode=display">P(X_j=x_j|Y=C_k)=\frac{1}{\sqrt{2\pi\delta_k^2}}exp(-\frac{(x_j-\mu_k)^2}{2\delta_k^2})</script><p>其中$C_k$为Y的第k类类别。$\mu_k$和 $\delta_k^2$为需要从训练集估计的值。</p><h4 id="2-2-MultinomialNB"><a href="#2-2-MultinomialNB" class="headerlink" title="2.2 MultinomialNB"></a>2.2 MultinomialNB</h4><p>MultinomialNB就是先验为多项式分布的朴素贝叶斯。它假设特征是由一个简单多项式分布生成的。多项分布可以描述各种类型样本出现次数的概率，因此多项式朴素贝叶斯非常适合用于描述出现次数或者出现次数比例的特征。该模型常用于文本分类，特征表示的是次数，例如某个词语的出现次数。<br>多项式分布公式如下：</p><script type="math/tex; mode=display">P(X_j=x_{jl}|Y=C_k)=\frac{x_{jl}+\lambda}{m_k+n\lambda}</script><p>其中，$P(X_j=x_{jl}|Y=C_k)$ 是第k个类别的第j维特征的第l个取值条件概率。$m_k$是训练集中输出为第k类的样本个数。$\lambda$为一个大于0的常数，常常取为1，即拉普拉斯平滑。也可以取其他值。</p><h4 id="2-3-BernoulliNB"><a href="#2-3-BernoulliNB" class="headerlink" title="2.3 BernoulliNB"></a>2.3 BernoulliNB</h4><p>BernoulliNB就是先验为伯努利分布的朴素贝叶斯。假设特征的先验概率为二元伯努利分布，即如下式：</p><script type="math/tex; mode=display">P(X_j=x_{jl}|Y=C_k)=P(j|Y=C_k)x_{jl}+(1-P(j|Y=C_k))(1-x_{jl})</script><p>此时$l$只有两种取值。$x_{jl}$只能取值0或者1。在伯努利模型中，每个特征的取值是布尔型的，即true和false，或者1和0。在文本分类中，就是一个特征有没有在一个文档中出现。</p><h4 id="2-4总结"><a href="#2-4总结" class="headerlink" title="2.4总结"></a>2.4总结</h4><ul><li>一般来说，如果样本特征的分布大部分是连续值，使用GaussianNB会比较好。</li><li>如果如果样本特征的分布大部分是多元离散值，使用MultinomialNB比较合适。</li><li>而如果样本特征是二元离散值或者很稀疏的多元离散值，应该使用BernoulliNB。</li></ul><h3 id="三、使用朴素贝叶斯进行文档分类"><a href="#三、使用朴素贝叶斯进行文档分类" class="headerlink" title="三、使用朴素贝叶斯进行文档分类"></a>三、使用朴素贝叶斯进行文档分类</h3><p>朴素贝叶斯一个很重要的应用就是文本分类，所以我们以在线社区留言为例。为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的语言，那么就将该留言标志为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类型：侮辱类和非侮辱类，使用1和0分别表示。我们把文本看成单词向量或者词条向量，也就是说将句子转换为向量。考虑出现所有文档中的单词，再决定将哪些单词纳入词汇表或者说所要的词汇集合，然后必须要将每一篇文档转换为词汇表上的向量。简单起见，我们先假设已经将本文切分完毕，存放到列表中，并对词汇向量进行分类标注。</p><h4 id="3-1-构建词向量"><a href="#3-1-构建词向量" class="headerlink" title="3.1 构建词向量"></a>3.1 构建词向量</h4><p>留言文本已经被切分好，并且人为标注好类别，用于训练模型。类别有两类，侮辱性（1）和非侮辱性（0）。</p><p>此案例所有的函数：</p><ul><li>loadDataSet：创建实验数据集</li><li>createVocabList：生成词汇表</li><li>setOfWords2Vec：生成词向量</li><li>get_trainMat：所有词条向量列表</li><li>trainNB：朴素贝叶斯分类器训练函数</li><li>classifyNB：朴素贝叶斯分类器分类函数</li><li>testingNB：朴素贝叶斯测试函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数功能：创建实验数据集</span></span><br><span class="line"><span class="string">参数说明：无参数</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    postingList：切分好的样本词条</span></span><br><span class="line"><span class="string">    classVec：类标签向量</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span>():</span></span><br><span class="line">    dataSet=[[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>,<span class="string">&#x27;help&#x27;</span>,<span class="string">&#x27;please&#x27;</span>],</span><br><span class="line">             [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">             [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">             [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">             [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">             [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]] <span class="comment"># 切分好的词条</span></span><br><span class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]  <span class="comment"># 类别标签向量，1代表侮辱性词汇，0代表非侮辱性词汇</span></span><br><span class="line">    <span class="keyword">return</span> dataSet,classVec</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataSet,classVec=loadDataSet()</span><br></pre></td></tr></table></figure><p>生成词汇表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数功能：将切分的样本词条整理成词汇表（不重复）</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    dataSet：切分好的样本词条</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    vocabList：不重复的词汇表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    vocabSet = <span class="built_in">set</span>()                    <span class="comment"># 创建一个空的集合</span></span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> dataSet:                 <span class="comment"># 遍历dataSet中的每一条言论</span></span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(doc)  <span class="comment"># 取并集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vocabList = createVocabList(dataSet)</span><br></pre></td></tr></table></figure><br>生成词向量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数功能：</span></span><br><span class="line"><span class="string">根据vocabList词汇表，将inputSet向量化，向量的每个元素为 1或 0</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    vocabList：词汇表</span></span><br><span class="line"><span class="string">    inputSet：切分好的词条列表中的一条</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    returnVec：文档向量,词集模型</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>):</span></span><br><span class="line">    returnVec = [<span class="number">0</span>] * <span class="built_in">len</span>(vocabList)                <span class="comment"># 创建一个其中所含元素都为0的向量</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:                           <span class="comment"># 遍历每个词条</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:                       <span class="comment"># 如果词条存在于词汇表中，则变为1</span></span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; %s is not in my Vocabulary!&quot;</span> % word )</span><br><span class="line">    <span class="keyword">return</span> returnVec                                <span class="comment"># 返回文档向量</span></span><br></pre></td></tr></table></figure><br>所有词条向量列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数功能：生成训练集向量列表</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    dataSet：切分好的样本词条</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    trainMat：所有的词条向量组成的列表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_trainMat</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    trainMat = []                                          <span class="comment"># 初始化向量列表</span></span><br><span class="line">    vocabList = createVocabList(dataSet)                   <span class="comment"># 生成词汇表</span></span><br><span class="line">    <span class="keyword">for</span> inputSet <span class="keyword">in</span> dataSet:                               <span class="comment"># 遍历样本词条中的每一条样本</span></span><br><span class="line">        returnVec = setOfWords2Vec(vocabList, inputSet)    <span class="comment"># 将当前词条向量化</span></span><br><span class="line">        trainMat.append(returnVec)                         <span class="comment"># 追加到向量列表中</span></span><br><span class="line">    <span class="keyword">return</span> trainMat</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainMat = get_trainMat(dataSet)</span><br></pre></td></tr></table></figure></p><h4 id="3-2-朴素贝叶斯分类器训练函数"><a href="#3-2-朴素贝叶斯分类器训练函数" class="headerlink" title="3.2 朴素贝叶斯分类器训练函数"></a>3.2 朴素贝叶斯分类器训练函数</h4><p>词向量构建好之后，我们就可以来构建朴素贝叶斯分类器的训练函数了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 函数功能：朴素贝叶斯分类器训练函数</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    trainMat：训练文档矩阵</span></span><br><span class="line"><span class="string">    classVec：训练类别标签向量</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    p0V：非侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">    p1V：侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">    pAb：文档属于侮辱类的概率</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB</span>(<span class="params">trainMat,classVec</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(trainMat)                          <span class="comment"># 计算训练的文档数目</span></span><br><span class="line">    m = <span class="built_in">len</span>(trainMat[<span class="number">0</span>])                       <span class="comment"># 计算每篇文档的词条数</span></span><br><span class="line">    pAb = <span class="built_in">sum</span>(classVec)/n                      <span class="comment"># 文档属于侮辱类的概率</span></span><br><span class="line">    p0Num = np.zeros(m); p1Num = np.zeros(m)   <span class="comment"># 词条出现数初始化为0</span></span><br><span class="line">    p0Denom = <span class="number">0</span>; p1Denom = <span class="number">0</span>                   <span class="comment"># 分母初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                         <span class="comment"># 遍历每一个文档</span></span><br><span class="line">        <span class="keyword">if</span> classVec[i] == <span class="number">1</span>:                   <span class="comment"># 统计属于侮辱类的条件概率所需的数据</span></span><br><span class="line">            p1Num += trainMat[i]</span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMat[i])</span><br><span class="line">        <span class="keyword">else</span>:                                  <span class="comment"># 统计属于非侮辱类的条件概率所需的数据</span></span><br><span class="line">            p0Num += trainMat[i]</span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMat[i])</span><br><span class="line">    p1V = p1Num / p1Denom</span><br><span class="line">    p0V = p0Num / p0Denom</span><br><span class="line">    <span class="keyword">return</span> p0V,p1V,pAb                         <span class="comment"># 返回属于非侮辱类,侮辱类和文档属于侮辱类的概率</span></span><br></pre></td></tr></table></figure><br>测试函数，查看结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p0V,p1V,pAb = trainNB(trainMat, classVec)</span><br></pre></td></tr></table></figure><br><img src="https://s2.ax1x.com/2019/02/06/kYjasf.png" alt=""></p><h4 id="3-3-测试朴素贝叶斯分类器"><a href="#3-3-测试朴素贝叶斯分类器" class="headerlink" title="3.3 测试朴素贝叶斯分类器"></a>3.3 测试朴素贝叶斯分类器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数功能：朴素贝叶斯分类器分类函数</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    vec2Classify：待分类的词条数组</span></span><br><span class="line"><span class="string">    p0V：非侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">    p1V：侮辱类的条件概率数组</span></span><br><span class="line"><span class="string">    pAb：文档属于侮辱类的概率</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    0：属于非侮辱类</span></span><br><span class="line"><span class="string">    1：属于侮辱类</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span>(<span class="params">vec2Classify, p0V, p1V, pAb</span>):</span></span><br><span class="line">    p1 = reduce(<span class="keyword">lambda</span> x,y:x*y, vec2Classify * p1V) * pAb   <span class="comment"># 对应元素相乘</span></span><br><span class="line">    p0 = reduce(<span class="keyword">lambda</span> x,y:x*y, vec2Classify * p0V) * (<span class="number">1</span> - pAb)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;p0:&#x27;</span>,p0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;p1:&#x27;</span>,p1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 函数功能：朴素贝叶斯测试函数</span></span><br><span class="line"><span class="string">参数说明：</span></span><br><span class="line"><span class="string">    testVec：测试样本</span></span><br><span class="line"><span class="string">返回：</span></span><br><span class="line"><span class="string">    测试样本的类别</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span>(<span class="params">testVec</span>):</span></span><br><span class="line">    dataSet,classVec = loadDataSet()</span><br><span class="line">    vocabList = createVocabList(dataSet)</span><br><span class="line">    trainMat= get_trainMat(dataSet)</span><br><span class="line">    p0V,p1V,pAb = trainNB(trainMat,classVec)</span><br><span class="line">    thisone = setOfWords2Vec(vocabList, testVec)</span><br><span class="line">    <span class="keyword">if</span> classifyNB(thisone,p0V,p1V,pAb):</span><br><span class="line">        <span class="built_in">print</span>(testVec,<span class="string">&#x27;属于侮辱类&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(testVec,<span class="string">&#x27;属于非侮辱类&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试样本1</span></span><br><span class="line">testVec1 = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">testingNB(testVec1)</span><br><span class="line"><span class="comment">#测试样本2</span></span><br><span class="line">testVec2 = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">testingNB(testVec2)</span><br></pre></td></tr></table></figure><p>你会发现，这样写的算法无法进行分类，p0和p1的计算结果都是0，显然结果错误。这是为什么呢？</p><h4 id="3-4-朴素贝叶斯改进之拉普拉斯平滑"><a href="#3-4-朴素贝叶斯改进之拉普拉斯平滑" class="headerlink" title="3.4 朴素贝叶斯改进之拉普拉斯平滑"></a>3.4 朴素贝叶斯改进之拉普拉斯平滑</h4><p>利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算 p(w0|1)p(w1|1)p(w2|1)。如果其中有一个概率值为0，那么最后的成绩也为0。显然，这样是不合理的，为了降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。这种做法就叫做拉普拉斯平滑(Laplace Smoothing)又被称为加1平滑，是比较常用的平滑方法，它就是为了解决0概率问题。</p><p>另外一个遇到的问题就是下溢出，这是由于太多很小的数相乘造成的。我们在计算乘积时，由于大部分因子都很小，所以程序会下溢或者得不到正确答案。为了解决这个问题，对乘积结果取自然对数。通过求对数可以避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。下图给出函数f(x)和ln(f(x))的曲线。</p><p><img src="https://s2.ax1x.com/2019/02/06/kYjyJs.png" alt=""></p><p>检查这两条曲线就会发现它们在相同区域内同时增加或者减少，并且在相同点上取到极值。它们的取值虽然不同，但不影响最终结果。因此可以修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB</span>(<span class="params">trainMat,classVec</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(trainMat)                          <span class="comment"># 计算训练的文档数目</span></span><br><span class="line">    m = <span class="built_in">len</span>(trainMat[<span class="number">0</span>])                       <span class="comment"># 计算每篇文档的词条数</span></span><br><span class="line">    pAb = <span class="built_in">sum</span>(classVec)/n                      <span class="comment"># 文档属于侮辱类的概率</span></span><br><span class="line">    p0Num = np.ones(m); p1Num = np.ones(m)   <span class="comment"># 词条出现数初始化为1</span></span><br><span class="line">    p0Denom = <span class="number">2</span>; p1Denom = <span class="number">2</span>                   <span class="comment"># 分母初始化为2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):                         <span class="comment"># 遍历每一个文档</span></span><br><span class="line">        <span class="keyword">if</span> classVec[i] == <span class="number">1</span>:                   <span class="comment"># 统计属于侮辱类的条件概率所需的数据</span></span><br><span class="line">            p1Num += trainMat[i]</span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMat[i])</span><br><span class="line">        <span class="keyword">else</span>:                                  <span class="comment"># 统计属于非侮辱类的条件概率所需的数据</span></span><br><span class="line">            p0Num += trainMat[i]</span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMat[i])</span><br><span class="line">    p1V = np.log(p1Num / p1Denom)</span><br><span class="line">    p0V = np.log(p0Num / p0Denom)</span><br><span class="line">    <span class="keyword">return</span> p0V,p1V,pAb                         <span class="comment"># 返回属于非侮辱类,侮辱类和文档属于侮辱类的概率</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p0V,p1V,pAb = trainNB(trainMat,classVec)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span>(<span class="params">vec2Classify, p0V, p1V, pAb</span>):</span></span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2Classify * p1V) + np.log(pAb)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2Classify * p0V) + np.log(<span class="number">1</span>- pAb)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>测试代码运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试样本1</span></span><br><span class="line">testVec1 = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">testingNB(testVec1)</span><br><span class="line"><span class="comment">#测试样本2</span></span><br><span class="line">testVec2 = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">testingNB(testVec2)</span><br></pre></td></tr></table></figure><br>这样看，结果就没什么问题了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;] 属于非侮辱类</span><br><span class="line">[&#x27;stupid&#x27;, &#x27;garbage&#x27;] 属于侮辱类</span><br></pre></td></tr></table></figure></p><hr><h3 id="四、优点与缺点"><a href="#四、优点与缺点" class="headerlink" title="四、优点与缺点"></a>四、优点与缺点</h3><p>优点：在数据较少的情况下仍然有效，可以处理多类别问题。<br>缺点：对于输入数据的准备方式较为敏感。<br>适用数据类型：标称型数据。</p><hr><p>完整数据源码:   <a href="https://github.com/QzmVc1/Data-Mining/tree/master/Naive%20Bayes">QzmVc1/Data-Mining/Naive Bayes/</a><br>参考链接：<br><a href="https://www.bilibili.com/video/av36338359?from=search&amp;seid=11144196688254906983">【菊安酱的机器学习】第3期 朴素贝叶斯算法</a><br><a href="">机器学习实战.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Markdown中输入数学公式(MathJax)</title>
      <link href="/%E5%9C%A8Markdown%E4%B8%AD%E8%BE%93%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F-MathJax.html"/>
      <url>/%E5%9C%A8Markdown%E4%B8%AD%E8%BE%93%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F-MathJax.html</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Markdown编辑器支持基于MathJax编写LaTeX数学公式。</p><p>MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。这篇文章介绍如何使用LaTeX语法编写数学公式。<br><span id="more"></span></p><hr><h3 id="一、标记公式"><a href="#一、标记公式" class="headerlink" title="一、标记公式"></a>一、标记公式</h3><p>LaTeX的数学公式有两种：行内公式和块级公式。行内公式放在文中与其它文字混编，块级公式单独成行。都使用美元符号进行标记显示。</p><h4 id="1-1-行内公式"><a href="#1-1-行内公式" class="headerlink" title="1.1 行内公式"></a>1.1 行内公式</h4><p><strong>标记方法：使用一个美元符号包围起来</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$</span><br></pre></td></tr></table></figure><br><strong>例子：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是行内公式：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</span><br></pre></td></tr></table></figure><br><strong>效果：</strong></p><p>这是行内公式：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</p><h4 id="1-2-块级公式"><a href="#1-2-块级公式" class="headerlink" title="1.2 块级公式"></a>1.2 块级公式</h4><p><strong>标记方法：使用两个美元符号包围起来</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$数学公式$$</span><br></pre></td></tr></table></figure><br><strong>例子：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure><br><strong>效果：</strong></p><script type="math/tex; mode=display">x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}</script><h3 id="二、上标和下标"><a href="#二、上标和下标" class="headerlink" title="二、上标和下标"></a>二、上标和下标</h3><p>^ 表示上标，_ 表示下标。如果上下标的内容多于一个字符，要用 <strong>{}</strong> 把这些内容括起来当成一个整体。<strong>上下标是可以嵌套的，也可以同时使用。</strong></p><p><strong>例子：</strong> <code>$x\^&#123;y\^z&#125;=(1+e\^x)\^&#123;-2xy\^w&#125;$</code></p><p><strong>效果：</strong> $x^{y^z}=(1+e^x)^{-2xy^w}$</p><p>另外，如果要在左右两边都有上下标，可以用<code>\sideset</code>命令。</p><p><strong>例子：</strong> <code>$\\sideset&#123;\^1_2&#125;&#123;\^3_4&#125;\\bigotimes$</code></p><p><strong>效果：</strong> $\sideset{^1_2}{^3_4}\bigotimes$</p><h3 id="三、分数表示"><a href="#三、分数表示" class="headerlink" title="三、分数表示"></a>三、分数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1： \frac&#123;分子&#125;&#123;分母&#125;</span><br><span class="line">方法2： 分子 \over 分母</span><br></pre></td></tr></table></figure><p><strong>例子：</strong> <code>$\\frac&#123;a+b&#125;&#123;c+d&#125;$</code>　或　<code>$1 \\over 3$</code></p><p><strong>效果：</strong> $\frac{a+b}{c+d}$　或　$1 \over 3$</p><p><strong>注意：</strong> 对于<code>\\frac</code>的方法，如果分子分母都是单个数，那么大括号{}可以省略，如：<code>$\\frac12$</code> 表示 $\frac12$。</p><h3 id="四、各种括号"><a href="#四、各种括号" class="headerlink" title="四、各种括号"></a>四、各种括号</h3><p><code>()</code>、<code>[]</code>和<code>|</code>可以直接表示自己，而<code>&#123;&#125;</code>本来用于分组，因此需要用<code>\&#123;\&#125;</code>来表示自身，也可以使用<code>\lbrace</code>和<code>\rbrace</code>来表示，其它括号见下面那个表。</p><p><strong>例子：<code>$\&#123;[z-(1+\\frac23x)y]\\div 4\&#125;$</code></strong></p><p><strong>效果：$\{[z-(1+\frac23x)y]\div 4\}$</strong></p><p>注意原始符号并不会随着公式大小缩放。有时候我们想要括号和分隔符显示的大点，比如上面例子中希望括号能把整个分数都包住，那么可以用<code>\left</code>和<code>\right</code>标记，实现自适应调整。</p><p><strong>例子：<code>$\\left(1+\\frac23x\\right)$</code></strong></p><p><strong>效果：$\left(1+\frac23x\right)$</strong></p><p><strong><code>\\left</code> 和 <code>\\right</code> 标记能应用的括号很多：</strong></p><div class="table-container"><table><thead><tr><th>符号名称</th><th>LaTex代码</th><th>例子</th></tr></thead><tbody><tr><td>小括号</td><td>( 和 )</td><td>\\left(x\\right)</td></tr><tr><td>中括号</td><td>[ 和 ]</td><td>\\left[\\frac12\\right]</td></tr><tr><td>大括号</td><td>{ 和 }</td><td>\\left{\\frac12\\right}</td></tr><tr><td>取绝对值</td><td>丨</td><td>\\left丨\\frac12\\right丨</td></tr><tr><td>尖括号</td><td>\\langle 和 \\rangle</td><td>\\left\\langle\\frac12\\right\\rangle</td></tr><tr><td>向上取整</td><td>\\lceil 和 \\rceil</td><td>\\left\\lceil\\frac12\\right\\rceil</td></tr><tr><td>向下取整</td><td>\\lfloor 和 \\rfloor</td><td>\\left\\lfloor\\frac12\\right\\rfloor</td></tr></tbody></table></div><p><strong>注意：</strong></p><blockquote><p><code>\left</code> 和 <code>\right</code> 标记必须是成对出现的，但有时候我们只用到其中一个，比如只用一个|当作分割线，这时候可以通过.来表示空的那一方，即用 <code>\left.</code> 表达左边空的情况，用 <code>\right.</code> 表达右边空的情况。</p></blockquote><p>例子：<code>$\\left. \\frac&#123;du&#125;&#123;dx&#125; \\right|_&#123;x=0&#125;$</code></p><p><strong>效果：$\left. \frac{du}{dx} \right| _{x=0}$</strong></p><h3 id="五、根号表示"><a href="#五、根号表示" class="headerlink" title="五、根号表示"></a>五、根号表示</h3><p>根号开方使用 <code>\sqrt</code> 标记，语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sqrt[开方次数，默认为2]&#123;开方因子&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例子：<code>$\\sqrt&#123;x\^3&#125;$</code>　和　<code>$\\sqrt[3]&#123;\\frac xy&#125;$</code></strong></p><p><strong>效果：$\sqrt{x^3}$ 和 $\sqrt[3]{\frac xy}$&lt;/code&gt;</strong></p><h3 id="六、省略号"><a href="#六、省略号" class="headerlink" title="六、省略号"></a>六、省略号</h3><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号。</p><p><strong>例子：<code>$f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2$</code></strong></p><p><strong>效果：$f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</strong></p><p><strong>注意：</strong> <code>\\ldot</code> 和<code>\\cdot</code> 可以表示与文本底线和中线对齐的单个点。</p><h3 id="七、矢量表示"><a href="#七、矢量表示" class="headerlink" title="七、矢量表示"></a>七、矢量表示</h3><p>矢量用<code>\vect</code> 标记实现，语法格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\vec&#123;矢量值&#125;</span><br></pre></td></tr></table></figure></p><p><strong>例子：<code>$\\vec&#123;a&#125; \\cdot \\vec&#123;b&#125;=0$</code></strong></p><p><strong>效果：$\vec{a} \cdot \vec{b}=0$</strong></p><h3 id="八、间隔空间"><a href="#八、间隔空间" class="headerlink" title="八、间隔空间"></a>八、间隔空间</h3><p>通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a︹︹b</code>与<code>a︹︹︹︹︹b</code>（︹表示空格）都会显示为ab。可以通过在ab间加入<code>\空格</code>或<code>\;</code>增加些许间隙，<code>\quad</code> 与 <code>\qquad</code> 会增加更大的间隙。</p><p><strong>例子：<code>$\\vec&#123;a&#125; \\cdot \\vec&#123;b&#125;=0$</code></strong></p><p><strong>效果：$\vec{a} \cdot \vec{b}=0$</strong></p><h3 id="九、希腊字母"><a href="#九、希腊字母" class="headerlink" title="九、希腊字母"></a>九、希腊字母</h3><p>下面的表格用于查询和对比。<br><img src="https://s2.ax1x.com/2019/02/04/kJwVJK.png" alt=""></p><h3 id="十、特殊字符"><a href="#十、特殊字符" class="headerlink" title="十、特殊字符"></a>十、特殊字符</h3><h4 id="10-1-关系运算符"><a href="#10-1-关系运算符" class="headerlink" title="10.1 关系运算符"></a>10.1 关系运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>±</td><td>\\pm</td></tr><tr><td>×</td><td>\\times</td></tr><tr><td>÷</td><td>\\div</td></tr><tr><td>∣</td><td>\\mid</td></tr><tr><td>∤</td><td>\\nmid</td></tr><tr><td>·⋅</td><td>\\cdot</td></tr><tr><td>∘</td><td>\\circ</td></tr><tr><td>∗</td><td>\\ast</td></tr><tr><td>⨀</td><td>\\bigodot</td></tr><tr><td>⨂</td><td>\\bigotimes</td></tr><tr><td>⨁</td><td>\\bigoplus</td></tr><tr><td>≤</td><td>\\leq</td></tr><tr><td>≥</td><td>\\geq</td></tr><tr><td>≠</td><td>\\neq</td></tr><tr><td>≈</td><td>\\approx</td></tr><tr><td>≡</td><td>\\equiv</td></tr><tr><td>∑</td><td>\\sum</td></tr><tr><td>∏</td><td>\\prod</td></tr><tr><td>∐</td><td>\\coprod</td></tr></tbody></table></div><h4 id="10-2-集合运算符"><a href="#10-2-集合运算符" class="headerlink" title="10.2 集合运算符"></a>10.2 集合运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>∅</td><td>\\emptyset</td></tr><tr><td>∈</td><td>\\in</td></tr><tr><td>∉</td><td>\\notin</td></tr><tr><td>⊂</td><td>\\subset</td></tr><tr><td>⊃</td><td>\\supset</td></tr><tr><td>⊆</td><td>\\subseteq</td></tr><tr><td>⊇</td><td>\\supseteq</td></tr><tr><td>⋂</td><td>\\bigcap</td></tr><tr><td>⋃</td><td>\\bigcup</td></tr><tr><td>⋁</td><td>\\bigvee</td></tr><tr><td>⋀</td><td>\\bigwedge</td></tr><tr><td>⨄</td><td>\\biguplus</td></tr><tr><td>⨆</td><td>\\bigsqcup</td></tr></tbody></table></div><h4 id="10-3-对数运算符"><a href="#10-3-对数运算符" class="headerlink" title="10.3 对数运算符"></a>10.3 对数运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>log</td><td>\\log</td></tr><tr><td>lg</td><td>\\lg</td></tr><tr><td>ln</td><td>\\ln</td></tr></tbody></table></div><h4 id="10-4-三角运算符"><a href="#10-4-三角运算符" class="headerlink" title="10.4 三角运算符"></a>10.4 三角运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>⊥</td><td>\\bot</td></tr><tr><td>∠</td><td>\\angle</td></tr><tr><td>30∘</td><td>30^\\circ</td></tr><tr><td>sin</td><td>\\sin</td></tr><tr><td>cos</td><td>\\cos</td></tr><tr><td>tan</td><td>\\tan</td></tr><tr><td>cot</td><td>\\cot</td></tr><tr><td>sec</td><td>\\sec</td></tr><tr><td>csc</td><td>\\csc</td></tr></tbody></table></div><h4 id="10-5-微积分运算符"><a href="#10-5-微积分运算符" class="headerlink" title="10.5 微积分运算符"></a>10.5 微积分运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>′</td><td>\\prime</td></tr><tr><td>∫</td><td>\\int</td></tr><tr><td>∬</td><td>\\iint</td></tr><tr><td>∭</td><td>\\iiint</td></tr><tr><td>⨌</td><td>\\iiiint</td></tr><tr><td>∮</td><td>\\oint</td></tr><tr><td>lim</td><td>\\lim</td></tr><tr><td>∞</td><td>\\infty</td></tr><tr><td>∇</td><td>\\nabla</td></tr></tbody></table></div><h4 id="10-6-逻辑运算符"><a href="#10-6-逻辑运算符" class="headerlink" title="10.6 逻辑运算符"></a>10.6 逻辑运算符</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>∵</td><td>\\because</td></tr><tr><td>∴</td><td>\\therefore</td></tr><tr><td>∀</td><td>\\forall</td></tr><tr><td>∃</td><td>\\exists</td></tr><tr><td>≠</td><td>\\not=</td></tr><tr><td>≯</td><td>\\not&gt;</td></tr><tr><td>⊄</td><td>\\not\\subset</td></tr></tbody></table></div><h4 id="10-7-戴帽符号"><a href="#10-7-戴帽符号" class="headerlink" title="10.7 戴帽符号"></a>10.7 戴帽符号</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>y^</td><td>\\hat{y}</td></tr><tr><td>yˇ</td><td>\\check{y}</td></tr><tr><td>y˘</td><td>\\breve{y}</td></tr></tbody></table></div><h4 id="10-8-箭头符号"><a href="#10-8-箭头符号" class="headerlink" title="10.8 箭头符号"></a>10.8 箭头符号</h4><div class="table-container"><table><thead><tr><th>符号</th><th>LaTex</th></tr></thead><tbody><tr><td>↑</td><td>\\uparrow</td></tr><tr><td>↓</td><td>\\downarrow</td></tr><tr><td>⇑</td><td>\\Uparrow</td></tr><tr><td>⇓</td><td>\\Downarrow</td></tr><tr><td>→</td><td>\\rightarrow</td></tr><tr><td>←</td><td>\\leftarrow</td></tr><tr><td>⇒</td><td>\\Rightarrow</td></tr><tr><td>⇐</td><td>\\Leftarrow</td></tr><tr><td>⟶</td><td>\\longrightarrow</td></tr><tr><td>⟵</td><td>\\longleftarrow</td></tr><tr><td>⟹</td><td>\\Longrightarrow</td></tr><tr><td>⟸</td><td>\\Longleftarrow</td></tr></tbody></table></div><h3 id="十一、字体种类"><a href="#十一、字体种类" class="headerlink" title="十一、字体种类"></a>十一、字体种类</h3><p><img src="https://s2.ax1x.com/2019/04/22/Ekq1XD.png" alt=""></p><h3 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h3><h6 id="2019-04-22更新"><a href="#2019-04-22更新" class="headerlink" title="2019/04/22更新"></a>2019/04/22更新</h6><p><strong>①分段函数</strong></p><p><img src="https://s2.ax1x.com/2019/04/22/EkqQ1K.png" alt=""></p><p><strong>②正下方角标</strong></p><p><img src="https://s2.ax1x.com/2019/04/22/EkqMp6.png" alt=""></p><h6 id="2019-09-04更新"><a href="#2019-09-04更新" class="headerlink" title="2019/09/04更新"></a>2019/09/04更新</h6><p><strong>① Latex 设置字体大小命令由小到大依次为：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\tiny</span><br><span class="line">\scriptsize</span><br><span class="line">\footnotesize</span><br><span class="line">\small</span><br><span class="line">\normalsize</span><br><span class="line">\large</span><br><span class="line">\Large</span><br><span class="line">\LARGE</span><br><span class="line">\huge</span><br><span class="line">\Huge</span><br></pre></td></tr></table></figure><p><strong>② LaTex输入矩阵</strong></p><p><img src="https://s2.ax1x.com/2019/09/04/nVSMt0.png" alt=""></p><hr><p>参考链接：<a href="https://blog.csdn.net/lanxuezaipiao/article/details/44341645">CSDN-markdown语法之如何使用LaTeX语法编写数学公式</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Hexo中使用mathjax渲染数学公式</title>
      <link href="/%E5%9C%A8Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.html"/>
      <url>/%E5%9C%A8Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax%E6%B8%B2%E6%9F%93%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>在 <strong>hexo</strong> 中，你会发现我们不能用 <strong>Latex</strong> 语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题。<br><span id="more"></span></p><h3 id="第一步：-使用Kramed代替-Marked"><a href="#第一步：-使用Kramed代替-Marked" class="headerlink" title="第一步： 使用Kramed代替 Marked"></a>第一步： 使用Kramed代替 Marked</h3><p><strong>hexo</strong> 默认的渲染引擎是 <strong>marked</strong> ，但是 <strong>marked</strong> 不支持 <strong>mathjax</strong> 。 <strong>kramed</strong> 是在 <strong>marked</strong> 的基础上进行修改。我们在工程目录下执行以下命令来安装 <strong>kramed</strong> .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>然后，更改/node_modules/hexo-renderer-kramed/lib/renderer.js，更改：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&#x27;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &#x27;$$$$$1$$$$&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二步-停止使用-hexo-math"><a href="#第二步-停止使用-hexo-math" class="headerlink" title="第二步: 停止使用 hexo-math"></a>第二步: 停止使用 hexo-math</h3><p>首先，如果你已经安装 <strong>hexo-math</strong> , 请卸载它：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure><br>然后安装 <strong>hexo-renderer-mathjax</strong> 包：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></p><h3 id="第三步-更新-Mathjax-的-CDN-链接"><a href="#第三步-更新-Mathjax-的-CDN-链接" class="headerlink" title="第三步: 更新 Mathjax 的 CDN 链接"></a>第三步: 更新 Mathjax 的 CDN 链接</h3><p>首先，打开 /node_modules/hexo-renderer-mathjax/mathjax.html</p><p>然后，把 <strong>&lt;script&gt;</strong> 更改为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="第四步-更改默认转义规则"><a href="#第四步-更改默认转义规则" class="headerlink" title="第四步: 更改默认转义规则"></a>第四步: 更改默认转义规则</h3><p>因为 <strong>hexo</strong> 默认的转义规则会将一些字符进行转义，比如 <strong>_</strong> 转为  <strong>&lt;em&gt;</strong> , 所以我们需要对默认的规则进行修改.<br>修改 node_modules\kramed\lib\rules\inline.js 中的第11行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><br>以及第20行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><h3 id="第五步-开启mathjax"><a href="#第五步-开启mathjax" class="headerlink" title="第五步: 开启mathjax"></a>第五步: 开启mathjax</h3><p>在主题 <strong>_config.yml</strong> 中开启 <strong>Mathjax</strong> ， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure><br>这一步可选，在博客中开启 Mathjax， 添加以下内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Testing Mathjax with Hexo</span><br><span class="line">category: Uncategorized</span><br><span class="line">date: 2017/05/03</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h5 id="通过以上步骤，我们就可以在-hexo-中使用-Mathjax-来书写数学公式。"><a href="#通过以上步骤，我们就可以在-hexo-中使用-Mathjax-来书写数学公式。" class="headerlink" title="通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。"></a>通过以上步骤，我们就可以在 <strong>hexo</strong> 中使用 <strong>Mathjax</strong> 来书写数学公式。</h5><hr><p>参考链接：<a href="https://blog.csdn.net/u014630987/article/details/78670258">如何在 hexo 中支持 Mathjax？</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Data Analysis Library -- Pandas</title>
      <link href="/Python-Data-Analysis-Library-Pandas.html"/>
      <url>/Python-Data-Analysis-Library-Pandas.html</url>
      
        <content type="html"><![CDATA[<h3 id="Pandas简介"><a href="#Pandas简介" class="headerlink" title="Pandas简介"></a>Pandas简介</h3><p>1、Python Data Analysis Library 或 Pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。Pandas提供了大量能使我们快速便捷地处理数据的函数和方法。你很快就会发现，它是使Python成为强大而高效的数据分析环境的重要因素之一。</p><p>2、数据结构：</p><ul><li><strong>Series：</strong> 一维数组，与Numpy中的一维array类似。二者与Python基本的数据结构List也很相近，其区别是：List中的元素可以是不同的数据类型，而Array和Series中则只允许存储相同的数据类型，这样可以更有效的使用内存，提高运算效率。</li><li><strong>Time- Series：</strong> 以时间为索引的Series。</li><li><strong>DataFrame：</strong> 二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。以下的内容主要以DataFrame为主。</li><li><strong>Panel ：</strong> 三维的数组，可以理解为DataFrame的容器。</li></ul><p>Pandas 有两种自己独有的基本数据结构。读者应该注意的是，它固然有着两种数据结构，因为它依然是 Python 的一个库，所以，Python 中有的数据类型在这里依然适用，也同样还可以使用类自己定义数据类型。只不过，Pandas 里面又定义了两种数据类型：Series 和 DataFrame，它们让数据操作更简单了。</p><p>运行环境：<strong>jupyter notebook</strong><br>参考链接：<a href="http://www.cnblogs.com/chaosimple/p/4153083.html">十分钟搞定pandas</a><br><span id="more"></span></p><hr><blockquote><p>本文是对pandas官方网站上《10 Minutes to pandas》的一个简单的翻译，原文在<a href="http://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html">这里</a>。这篇文章是对pandas的一个简单的介绍，详细的介绍请参考：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html">Cookbook</a> 。习惯上，我们会按下面格式引入所需要的包：</p></blockquote><p><img src="https://s2.ax1x.com/2019/02/04/kJKBIs.png" alt=""></p><h3 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h3><p>可以通过 <a href="http://pandas.pydata.org/pandas-docs/stable/getting_started/dsintro.html">Data Structure Intro Setion</a> 来查看有关该节内容的详细信息。</p><p><strong>1.1</strong> 可以通过传递一个list对象来创建一个Series，pandas会默认创建整型索引：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKaqg.png" alt=""></p><p><strong>1.2</strong> 通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJK0aj.png" alt=""></p><p><strong>1.3</strong> 通过传递一个能够被转换成类似序列结构的字典对象来创建一个DataFrame：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKNM8.png" alt=""></p><p><strong>1.4</strong> 查看不同列的数据类型：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKGGt.png" alt=""></p><hr><h3 id="二、查看数据"><a href="#二、查看数据" class="headerlink" title="二、查看数据"></a>二、查看数据</h3><p>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html">Basics Section</a></p><p><strong>2.1</strong>  查看frame中头部和尾部的行：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKJRP.png" alt=""></p><p><strong>2.2</strong> 显示索引、列和底层的numpy数据：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKYxf.png" alt=""></p><p><strong>2.3</strong> describe()函数对于数据的快速统计汇总：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMeFs.png" alt=""></p><p><strong>2.4</strong> 对数据的转置：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKUsS.png" alt=""></p><p><strong>2.5</strong> 按轴进行排序</p><p><img src="https://s2.ax1x.com/2019/02/04/kJKrin.png" alt=""></p><hr><h3 id="三、选择"><a href="#三、选择" class="headerlink" title="三、选择"></a>三、选择</h3><p>虽然标准的Python/Numpy的选择和设置表达式都能够直接派上用场，但是作为工程使用的代码，我们推荐使用经过优化的pandas数据访问方式： .at, .iat, .loc, .iloc 和 .ix详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">Indexing and Selecing Data</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html">MultiIndex / Advanced Indexing</a>。</p><h4 id="3-1-获取"><a href="#3-1-获取" class="headerlink" title="3.1 获取"></a>3.1 获取</h4><p><strong>3.1.1</strong> 选择一个单独的列，这将会返回一个Series，等同于df.A：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMsTH.png" alt=""></p><p><strong>3.1.2</strong> 通过[ ]进行选择，这将会对行进行切片</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMtYR.png" alt=""></p><h4 id="3-2-通过标签选择"><a href="#3-2-通过标签选择" class="headerlink" title="3.2 通过标签选择"></a>3.2 通过标签选择</h4><p><strong>3.2.1</strong> 使用标签来获取一个交叉的区域</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMDmD.png" alt=""></p><p><strong>3.2.2</strong> 通过标签来在多个轴上进行选择</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQeBD.png" alt=""></p><p><strong>3.2.3</strong> 标签切片</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMw6K.png" alt=""></p><p><strong>3.2.4</strong> 获取一个标量</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMGTJ.png" alt=""></p><h4 id="3-3-通过位置选择"><a href="#3-3-通过位置选择" class="headerlink" title="3.3 通过位置选择"></a>3.3 通过位置选择</h4><p><strong>3.3.1</strong> 通过传递数值进行位置选择（选择的是行）</p><p><img src="https://s2.ax1x.com/2019/02/04/kJM8w4.png" alt=""></p><p><strong>3.3.2</strong> 通过数值进行切片，与numpy/python中的情况类似</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMaSx.png" alt=""></p><p><strong>3.3.3</strong> 通过指定一个位置的列表，与numpy/python中的情况类似</p><p><img src="https://s2.ax1x.com/2019/02/04/kJM0OO.png" alt=""></p><p><strong>3.3.4</strong> 对行进行切片</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMgfI.png" alt=""></p><p><strong>3.3.5</strong> 对列进行切片</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMctA.png" alt=""></p><p><strong>3.3.6</strong> 获取特定的值</p><p><img src="https://s2.ax1x.com/2019/02/04/kJM6kd.png" alt=""></p><h4 id="3-4-布尔索引"><a href="#3-4-布尔索引" class="headerlink" title="3.4 布尔索引"></a>3.4 布尔索引</h4><p><strong>3.4.1</strong> 使用一个单独列的值来选择数据：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJMr0e.png" alt=""></p><p><strong>3.4.2</strong> 使用where操作来选择数据：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQqVe.png" alt=""></p><p><strong>3.4.3</strong> 使用isin()方法来过滤：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQO5d.png" alt=""></p><h4 id="3-5-设置"><a href="#3-5-设置" class="headerlink" title="3.5 设置"></a>3.5 设置</h4><p><strong>3.5.1</strong> 设置一个新的列：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQLUH.png" alt=""></p><p><strong>3.5.2</strong> 通过标签设置新的值：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQ7DO.png" alt=""></p><p><strong>3.5.3</strong> 通过位置设置新的值：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQTKK.png" alt=""></p><p><strong>3.5.4</strong>  通过一个numpy数组设置一组新值：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQHbD.png" alt=""></p><p><strong>上述操作结果如下：</strong></p><p><img src="https://s2.ax1x.com/2019/02/04/kJQjPA.png" alt=""></p><hr><h3 id="四、缺失值处理"><a href="#四、缺失值处理" class="headerlink" title="四、缺失值处理"></a>四、缺失值处理</h3><p>在pandas中，使用np.nan来代替缺失值，这些值将默认不会包含在计算中，详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html">Missing Data Section</a>。</p><p><strong>4.1</strong> reindex()方法可以对指定轴上的索引进行改变/增加/删除操作，这将返回原始数据的一个拷贝：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQx2t.png" alt=""></p><p><strong>4.2</strong> 去掉包含缺失值的行：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQv8I.png" alt=""></p><p><strong>4.3</strong> 对缺失值进行填充：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlpKf.png" alt=""></p><p><strong>4.4</strong> 对数据进行布尔填充：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJQzxP.png" alt=""></p><hr><h3 id="五、相关操作"><a href="#五、相关操作" class="headerlink" title="五、相关操作"></a>五、相关操作</h3><p>详情请参与 <a href="http://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html">Basic Section On Binary Ops</a></p><h4 id="5-1-统计（相关操作通常情况下不包括缺失值）"><a href="#5-1-统计（相关操作通常情况下不包括缺失值）" class="headerlink" title="5.1 统计（相关操作通常情况下不包括缺失值）"></a>5.1 统计（相关操作通常情况下不包括缺失值）</h4><p><strong>5.1.1</strong> 执行描述性统计：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlurT.png" alt=""></p><p><strong>5.1.2</strong> 在其他轴上进行相同的操作：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlQZF.png" alt=""></p><h4 id="5-2-Apply"><a href="#5-2-Apply" class="headerlink" title="5.2 Apply"></a>5.2 Apply</h4><p><strong>5.2.1</strong> 对数据应用函数：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlKqU.png" alt=""></p><h4 id="5-3-直方图"><a href="#5-3-直方图" class="headerlink" title="5.3 直方图"></a>5.3 直方图</h4><p>具体请参照：<a href="http://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html">Histogramming and Discretization</a></p><p><img src="https://s2.ax1x.com/2019/02/04/kJl1IJ.png" alt=""></p><h4 id="5-4-字符串方法"><a href="#5-4-字符串方法" class="headerlink" title="5.4 字符串方法"></a>5.4 字符串方法</h4><p>Series对象在其str属性中配备了一组字符串处理方法，可以很容易的应用到数组中的每个元素，如下段代码所示。更多详情请参考：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/text.html">Vectorized String Methods</a>.</p><p><img src="https://s2.ax1x.com/2019/02/04/kJl8i9.png" alt=""></p><h3 id="六、合并"><a href="#六、合并" class="headerlink" title="六、合并"></a>六、合并</h3><p>Pandas提供了大量的方法能够轻松的对Series，DataFrame和Panel对象进行各种符合各种逻辑关系的合并操作。具体请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">Merging section</a></p><p><strong>6.1</strong> Concat</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlla4.png" alt=""></p><p><strong>6.2</strong> Append<br>将一行连接到一个DataFrame上，具体请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">Appending</a>：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlUsK.png" alt=""></p><hr><h3 id="七、分组"><a href="#七、分组" class="headerlink" title="七、分组"></a>七、分组</h3><p>对于”group by”操作，我们通常是指以下一个或多个操作步骤：</p><ul><li><p>（Splitting）按照一些规则将数据分为不同的组；</p></li><li><p>（Applying）对于每组数据分别执行一个函数；</p></li><li><p>（Combining）将结果组合到一个数据结构中；</p></li></ul><p>详情请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html">Grouping section</a></p><p><img src="https://s2.ax1x.com/2019/02/04/kJlyRI.png" alt=""></p><p><strong>7.1</strong> 分组并对每个分组执行sum函数：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlGGR.png" alt=""></p><p><strong>7.2</strong> 通过多个列进行分组形成一个层次索引，然后执行函数：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlJR1.png" alt=""></p><hr><h3 id="八、Categorical"><a href="#八、Categorical" class="headerlink" title="八、Categorical"></a>八、Categorical</h3><p>从0.15版本开始，pandas可以在DataFrame中支持Categorical类型的数据，详细 介绍参看：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html">categorical introduction</a> 和 <a href="http://pandas.pydata.org/pandas-docs/stable/reference/index.html">API documentation</a>。</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlNM6.png" alt=""></p><p><strong>8.1</strong> 将原始的grade转换为Categorical数据类型：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlYxx.png" alt=""></p><p><strong>8.2</strong> 将Categorical类型数据重命名为更有意义的名称：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlwZD.png" alt=""></p><p><strong>8.3</strong>  对类别进行重新排序，增加缺失的类别：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlaqO.png" alt=""></p><p><strong>8.4</strong> 对Categorical列进行排序时存在空的类别：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlsJA.png" alt=""></p><hr><h3 id="九、画图"><a href="#九、画图" class="headerlink" title="九、画图"></a>九、画图</h3><p>具体文档参看：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html">Plotting docs</a></p><p><img src="https://s2.ax1x.com/2019/02/04/kJl0de.png" alt=""></p><p>对于DataFrame来说，plot是一种将所有列及其标签进行绘制的简便方法：</p><p><img src="https://s2.ax1x.com/2019/02/04/kJlBIH.png" alt=""></p><hr><h3 id="十、导入和保存数据"><a href="#十、导入和保存数据" class="headerlink" title="十、导入和保存数据"></a>十、导入和保存数据</h3><h4 id="10-1-CSV"><a href="#10-1-CSV" class="headerlink" title="10.1 CSV"></a>10.1 CSV</h4><p>参考：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">Writing to a csv file</a></p><p><strong>10.1.1</strong> 写入csv文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(&quot;xxx.csv&quot;)</span><br></pre></td></tr></table></figure><br><strong>10.1.2</strong> 从csv文件中读取：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(&quot;xxx.csv&quot;)</span><br></pre></td></tr></table></figure></p><h4 id="10-2-Excel"><a href="#10-2-Excel" class="headerlink" title="10.2 Excel"></a>10.2 Excel</h4><p>参考：<a href="http://pandas.pydata.org/pandas-docs/stable/user_guide/io.html">MS Excel</a></p><p><strong>10.2.1</strong> 写入excel文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_excel(&quot;xxx.xlsx&quot;,sheet_name = &#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure><br><strong>10.2.2</strong> 从excel文件中读取：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.read_excel(&#x27;xxx.xlsx&#x27;,&#x27;Sheet1&#x27;,index_col=None,na_values=[&#x27;NA&#x27;])</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(二):KNN</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%BA%8C-%EF%BC%9AKNN.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%BA%8C-%EF%BC%9AKNN.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>k-近邻算法（k-Nearest Neighbour algorithm），又称为KNN算法，是数据挖掘技术中原理最简单的算法。KNN 的工作原理：给定一个已知标签类别的训练数据集，输入没有标签的新数据后，在训练数据集中找到与新数据最邻近的k个实例，如果这k个实例的多数属于某个类别，那么新数据就属于这个类别。可以简单理解为：由那些离X最近的k个点来投票决定X归为哪一类。</p><p>GitHub源码：<a href="https://github.com/QzmVc1/Data-Mining/tree/master/KNN">QzmVc1/Data-Mining/KNN/</a></p><p>参考链接：<br><a href="https://www.bilibili.com/video/av38115160?from=search&amp;seid=15385102981487130077">【智源学院】30分钟KNN算法-有意思专题系列(K-Nearest Neighbor, KNN)</a><br><a href="https://www.bilibili.com/video/av35390140?from=search&amp;seid=2014456835238388101">【菊安酱的机器学习】第1期 k-近邻算法</a></p><hr><span id="more"></span><h3 id="二、KNN算法的简单理解"><a href="#二、KNN算法的简单理解" class="headerlink" title="二、KNN算法的简单理解"></a>二、KNN算法的简单理解</h3><p><img src="https://s2.ax1x.com/2019/02/01/k3tjRs.jpg" alt=""></p><p>图中有红色三角和蓝色方块两种类别，我们现在需要判断绿色圆点属于哪种类别。<br>当k=3时，绿色圆点属于红色三角这种类别；<br>当k=5时，绿色圆点属于蓝色方块这种类别。</p><p>举个简单的例子，可以用k-近邻算法分类一个电影是爱情片还是动作片。（打斗镜头和接吻镜头数量为虚构）</p><p><img src="https://s2.ax1x.com/2019/02/01/k3UMXq.png" alt=""></p><p>上表就是我们已有的数据集合，也就是训练样本集。这个数据集有两个特征——打斗镜头数和接吻镜头数。除此之外，我们也知道每部电影的所属类型，即分类标签。粗略看来，接吻镜头多的就是爱情片，打斗镜头多的就是动作片。以我们多年的经验来看，这个分类还算合理。如果现在给我一部新的电影，告诉我电影中的打斗镜头和接吻镜头分别是多少，那么我可以根据你给出的信息进行判断，这部电影是属于爱情片还是动作片。</p><p>而k-近邻算法也可以像我们人一样做到这一点。但是，这仅仅是两个特征，如果把特征扩大到N个呢？我们人类还能凭经验“一眼看出”电影的所属类别吗？想想就知道这是一个非常困难的事情，但算法可以，这就是算法的魅力所在。</p><p>我们已经知道k-近邻算法的工作原理，根据特征比较，然后提取样本集中特征最相似数据（最近邻）的分类标签。 那么如何进行比较呢？比如表1中新出的电影，我们该如何判断他所属的电影类别呢？如下图所示:</p><p><img src="https://s2.ax1x.com/2019/02/01/k3UKcn.png" alt=""></p><p>我们可以从散点图中大致推断，这个未知电影有可能是爱情片，因为看起来距离已知的三个爱情片更近一点。k-近邻算法是用什么方法进行判断呢？没错，就是距离度量。这个电影分类例子中有两个特征，也就是在二维平面中计算两点之间的距离，就可以用我们高中学过的距离计算公式：</p><p><img src="https://s2.ax1x.com/2019/02/01/k3UOvn.png" alt=""></p><p>如果是多个特征扩展到N维空间，怎么计算？没错，我们可以使用欧氏距离（也称欧几里得度量），如下所示：</p><p><img src="https://s2.ax1x.com/2019/02/01/k3ULgs.png" alt=""></p><p>通过计算可以得到训练集中所有电影与未知电影的距离，如下表所示：</p><p><img src="https://s2.ax1x.com/2019/02/01/k3Uu1s.png" alt=""></p><p>通过表2的计算结果，我们可以知道绿点标记的电影到爱情片《后来的我们》距离最近，为29.1。如果仅仅根据这个结果，判定绿点电影的类别为爱情片，这个算法叫做最近邻算法，而非k-近邻算法。k-近邻算法步骤如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) 计算已知类别数据集中的点与当前点之间的距离；</span><br><span class="line">(2) 按照距离递增次序排序；</span><br><span class="line">(3) 选取与当前点距离最小的k个点；</span><br><span class="line">(4) 确定前k个点所在类别的出现频率；</span><br><span class="line">(5) 返回前k个点出现频率最高的类别作为当前点的预测类别。</span><br></pre></td></tr></table></figure></p><p>比如，现在K=4，那么在这个电影例子中，把距离按照升序排列，距离绿点电影最近的前4个的电影分别是《后来的我们》、《前任3》、《无问西东》和《红海行动》，这四部电影的类别统计为爱情片:动作片=3:1，出现频率最<br>高的类别为爱情片，所以在k=4时，绿点电影的类别为爱情片。这个判别过程就是k-近邻算法。</p><hr><h3 id="三、KNN算法的Python实现"><a href="#三、KNN算法的Python实现" class="headerlink" title="三、KNN算法的Python实现"></a>三、KNN算法的Python实现</h3><h4 id="3-1-Python代码"><a href="#3-1-Python代码" class="headerlink" title="3.1 Python代码"></a>3.1 Python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;iris.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    reader = csv.DictReader(fp)</span><br><span class="line">    datas = [row <span class="keyword">for</span> row <span class="keyword">in</span> reader]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据分成训练集和测试集</span></span><br><span class="line">random.shuffle(datas)</span><br><span class="line">n = <span class="built_in">len</span>(datas) // <span class="number">3</span></span><br><span class="line">test_set = datas[<span class="number">0</span>:n]</span><br><span class="line">train_set = datas[n:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧几里得距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span>(<span class="params">d1,d2</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&quot;Sepal.Length&quot;</span>,<span class="string">&quot;Sepal.Width&quot;</span>,<span class="string">&quot;Petal.Length&quot;</span>,<span class="string">&quot;Petal.Width&quot;</span>):</span><br><span class="line">        res += (<span class="built_in">float</span>(d1[key])-<span class="built_in">float</span>(d2[key]))**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> res**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">K = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KNN</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="comment"># 1.计算距离</span></span><br><span class="line">    res = [</span><br><span class="line">        &#123;<span class="string">&#x27;result&#x27;</span>:train[<span class="string">&#x27;Species&#x27;</span>],<span class="string">&#x27;distance&#x27;</span>:distance(data,train)&#125;</span><br><span class="line">        <span class="keyword">for</span> train <span class="keyword">in</span> train_set</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.升序排序</span></span><br><span class="line">    res = <span class="built_in">sorted</span>(res,key=<span class="keyword">lambda</span> item:item[<span class="string">&#x27;distance&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.取前K个数据</span></span><br><span class="line">    res2 = res[<span class="number">0</span>:K]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.加权平均</span></span><br><span class="line">    result = &#123;<span class="string">&#x27;versicolor&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;setosa&#x27;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res2:</span><br><span class="line">        <span class="built_in">sum</span> += r[<span class="string">&#x27;distance&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res2:</span><br><span class="line">        result[r[<span class="string">&#x27;result&#x27;</span>]] += <span class="number">1</span>-r[<span class="string">&#x27;distance&#x27;</span>]/<span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result[<span class="string">&#x27;versicolor&#x27;</span>] &gt; result[<span class="string">&#x27;setosa&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;versicolor&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;setosa&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试阶段</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> test_set:</span><br><span class="line">    result1 = test[<span class="string">&#x27;Species&#x27;</span>]</span><br><span class="line">    result2 = KNN(test)</span><br><span class="line">    <span class="keyword">if</span> result1 == result2:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(correct*<span class="number">100</span>/<span class="built_in">len</span>(test_set)))</span><br></pre></td></tr></table></figure><h4 id="3-2-数据集"><a href="#3-2-数据集" class="headerlink" title="3.2 数据集"></a>3.2 数据集</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IDSepal.LengthSepal.WidthPetal.LengthPetal.Width Species</span><br><span class="line">1      5.1          3.5        1.4          0.2     setosa</span><br><span class="line">2      4.9          3          1.4          0.2     setosa</span><br><span class="line">3      4.7          3.2        1.3          0.2     setosa</span><br><span class="line">4      4.6          3.1        1.5          0.2     setosa</span><br><span class="line">5      5            3.6        1.4          0.2     setosa</span><br><span class="line">6      5.4          3.9        1.7          0.4     setosa</span><br><span class="line">...     ...           ...         ...           ...      ...</span><br></pre></td></tr></table></figure><hr><h3 id="四、算法总结"><a href="#四、算法总结" class="headerlink" title="四、算法总结"></a>四、算法总结</h3><div class="table-container"><table><thead><tr><th>KNN</th><th></th></tr></thead><tbody><tr><td>算法功能</td><td>分类（核心），回归</td></tr><tr><td>算法类型</td><td>有监督学习 - 惰性学习，距离类模型</td></tr><tr><td>数据输入</td><td>包含数据标签y，且特征空间中至少包含k个训练样本（k&gt;=1) 特征空间中各个特征的量纲需统一，若不统一则需要进行归一化处理自定义的超参数k (k&gt;=1)</td></tr><tr><td>模型输出</td><td>包含数据标签y，且特征空间中至少包含k个训练样本（k&gt;=1) 特征空间中各个特征的量纲需统一，若不统一则需要进行归一化处理自定义的超参数k (k&gt;=1)</td></tr></tbody></table></div><h4 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h4><ul><li>简单好用，容易理解，精度高，理论成熟，既可以用来做分类也可以用来做回归</li><li>可用于数值型数据和离散型数据</li><li>无数据输入假定</li><li>适合对稀有事件进行分类</li></ul><h4 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h4><ul><li>计算复杂性高；空间复杂性高；</li><li>计算量太大，所以一般数值很大的时候不用这个，但是单个样本又不能太少，否则容易发生误分。</li><li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）</li><li>可理解性比较差，无法给出数据的内在含义</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进击数据挖掘十大算法(一):K-Means</title>
      <link href="/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%80-K-Means.html"/>
      <url>/%E8%BF%9B%E5%87%BB%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95-%E4%B8%80-K-Means.html</url>
      
        <content type="html"><![CDATA[<h3 id="聚类与分类的区别"><a href="#聚类与分类的区别" class="headerlink" title="聚类与分类的区别"></a>聚类与分类的区别</h3><p>分类：类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类。属于监督学习。</p><p>聚类：事先不知道数据会分为几类，通过聚类分析将数据聚合成几个群体。聚类不需要对数据进行训练和学习。属于无监督学习。</p><p>关于监督学习和无监督学习，这里给一个简单的介绍：是否有监督，就看输入数据是否有标签，输入数据有标签，则为有监督学习，否则为无监督学习。</p><p>Github源码：<a href="https://github.com/QzmVc1/Data-Mining/tree/master/K-Means">QzmVc1/Data-Mining/K-Means/</a></p><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/huangfei711/article/details/78480078">5 分钟带你弄懂 k-means 聚类</a></li><li><a href="https://blog.csdn.net/taoyanqi8932/article/details/53727841">深入理解K-Means聚类算法</a></li></ul><p><img src="https://s2.ax1x.com/2019/01/23/kEMDne.png" alt=""></p><hr><span id="more"></span><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-1-什么是聚类分析"><a href="#1-1-什么是聚类分析" class="headerlink" title="1.1 什么是聚类分析"></a>1.1 什么是聚类分析</h4><p>聚类分析是在数据中发现数据对象之间的关系，将数据进行分组，组内的相似性越大，组间的差别越大，则聚类效果越好。</p><h4 id="1-2-不同的簇类型"><a href="#1-2-不同的簇类型" class="headerlink" title="1.2 不同的簇类型"></a>1.2 不同的簇类型</h4><p>聚类旨在发现有用的对象簇，在现实中我们用到很多的簇的类型，使用不同的簇类型划分数据的结果是不同的，如下的几种簇类型。</p><p><img src="https://s2.ax1x.com/2019/01/23/kEmurj.png" alt=""></p><h5 id="1-2-1-明显分离的"><a href="#1-2-1-明显分离的" class="headerlink" title="1.2.1 明显分离的"></a>1.2.1 明显分离的</h5><p>可以看到(a)中不同组中任意两点之间的距离都大于组内任意两点之间的距离，明显分离的簇不一定是球形的，可以具有任意的形状。</p><h5 id="1-2-2-基于原型的"><a href="#1-2-2-基于原型的" class="headerlink" title="1.2.2 基于原型的"></a>1.2.2 基于原型的</h5><p>簇是对象的集合，其中每个对象到定义该簇的<strong>原型</strong>的距离比其他簇的原型距离更近，如(b)所示的原型即为中心点，在一个簇中的数据到其中心点比到另一个簇的中心点更近。这是一种常见的<strong>基于中心的簇</strong>，最常用的K-Means就是这样的一种簇类型。<br>这样的簇趋向于球形。</p><h5 id="1-2-3-基于密度的"><a href="#1-2-3-基于密度的" class="headerlink" title="1.2.3 基于密度的"></a>1.2.3 基于密度的</h5><p>簇是对象的密度区域，(d)所示的是基于密度的簇，当簇不规则或相互盘绕，并且有早上和离群点事，常常使用基于密度的簇定义。</p><hr><h4 id="1-3-基本的聚类分析算法"><a href="#1-3-基本的聚类分析算法" class="headerlink" title="1.3 基本的聚类分析算法"></a>1.3 基本的聚类分析算法</h4><h5 id="1-3-1-K均值："><a href="#1-3-1-K均值：" class="headerlink" title="1.3.1 K均值："></a>1.3.1 K均值：</h5><p>基于原型的、划分的距离技术，它试图发现用户指定个数(K)的簇。</p><h5 id="1-3-2-凝聚的层次距离："><a href="#1-3-2-凝聚的层次距离：" class="headerlink" title="1.3.2 凝聚的层次距离："></a>1.3.2 凝聚的层次距离：</h5><p>开始时，每个点都作为一个单点簇，然后，重复的合并两个最靠近的簇，直到尝试单个、包含所有点的簇。</p><h5 id="1-3-3-DBSCAN"><a href="#1-3-3-DBSCAN" class="headerlink" title="1.3.3 DBSCAN:"></a>1.3.3 DBSCAN:</h5><p>一种基于密度的划分距离的算法，簇的个数有算法自动的确定，低密度中的点被视为噪声而忽略，因此其不产生完全聚类。</p><hr><h4 id="1-4-距离量度"><a href="#1-4-距离量度" class="headerlink" title="1.4 距离量度"></a>1.4 距离量度</h4><p>不同的距离量度会对距离的结果产生影响，常见的距离量度如下所示：</p><p><img src="https://s2.ax1x.com/2019/01/23/kEnGTI.png" alt=""></p><p><img src="https://s2.ax1x.com/2019/01/23/kEn80A.png" alt=""></p><hr><h3 id="二、K-Means聚类"><a href="#二、K-Means聚类" class="headerlink" title="二、K-Means聚类"></a>二、K-Means聚类</h3><h4 id="2-1-算法思想："><a href="#2-1-算法思想：" class="headerlink" title="2.1 算法思想："></a>2.1 算法思想：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择K个点作为初始质心</span><br><span class="line">repeat</span><br><span class="line">    将每个点指派到最近的质心，形成K个簇</span><br><span class="line">    重新计算每个簇的质心</span><br><span class="line">until 簇不发生变化或达到最大迭代次数</span><br></pre></td></tr></table></figure><h4 id="2-2-具体解释："><a href="#2-2-具体解释：" class="headerlink" title="2.2 具体解释："></a>2.2 具体解释：</h4><p>K-Means聚类算法的大致意思就是“物以类聚，人以群分”：</p><blockquote><ol><li>首先输入 k 的值，即我们指定希望通过聚类得到 k 个分组；</li><li>从数据集中随机选取 k 个数据点作为初始大佬（质心）；</li><li>对集合中每一个小弟，计算与每一个大佬的距离，离哪个大佬距离近，就跟定哪个大佬。</li><li>这时每一个大佬手下都聚集了一票小弟，这时候召开选举大会，每一群选出新的大佬（即通过算法选出新的质心）。</li><li>如果新大佬和旧大佬之间的距离小于某一个设置的阈值（表示重新计算的质心的位置变化不大，趋于稳定，或者说收敛），可以认为我们进行的聚类已经达到期望的结果，算法终止。</li><li>如果新大佬和旧大佬距离变化很大，需要迭代3~5步骤。</li></ol></blockquote><p>下面举个非常形象简单的例子：<br>有6个点，从图上看应该可以分成两堆，前三个点一堆，后三个点另一堆。现在我手工地把K-Means计算过程演示一下，同时检验是不是和预期一致：</p><p><img src="https://s2.ax1x.com/2019/01/23/kEu7rQ.png" alt=""></p><p><strong>1.设定 k 值为2</strong></p><p><strong>2.选择初始大佬（就选 P1 和 P2）</strong></p><p><strong>3.计算小弟与大佬的距离：</strong></p><p><img src="https://s2.ax1x.com/2019/01/23/kEuTKg.png" alt=""></p><p>从上图可以看出，所有的小弟都离 P2 更近，所以次站队的结果是：</p><p>A 组：P1<br>B 组：P2、P3、P4、P5、P6</p><p><strong>4.召开选举大会：</strong></p><p>A 组没什么可选的，大佬就是自己<br>B 组有5个人，需要重新选大佬，这里要注意<strong>选大佬的方法是每个人 X 坐标的平均值和 Y 坐标的平均值组成的新的点</strong>，为新大佬，也就是说这个大佬是“虚拟的”。因此，B 组选出新大哥的坐标为：P（（1+3+8+9+10）/5，（2+1+8+10+7）/5）=（6.2，5.6）。<br>综合两组，新大哥为 P1’（0，0），P2’（6.2，5.6），而P2-P6重新成为小弟。</p><p><strong>5.再次计算小弟到大佬的距离：</strong></p><p><img src="https://s2.ax1x.com/2019/01/23/kEuIxS.png" alt=""></p><p>这时可以看到P2、P3离P1更近，P4、P5、P6离P哥更近，所以第二次站队的结果是：<br>A 组：P1、P2、P3<br>B 组：P4、P5、P6</p><p><strong>6.第二届选举大会：</strong><br>同样的方法选出新的虚拟大佬：P1’（1.33，1），P2’（9，8.33），P1-P6都成为小弟。</p><p><strong>7.第三次计算小弟到大佬的距离：</strong><br><img src="https://s2.ax1x.com/2019/01/23/kEu528.png" alt=""><br>这时可以看到 P1、P2、P3 离 P哥1 更近，P4、P5、P6离 P哥2 更近，所以第二次站队的结果是：<br>A 组：P1、P2、P3<br>B 组：P4、P5、P6</p><p>我们可以发现，这次站队的结果和上次没有任何变化了，说明<strong>已经收敛，聚类结束</strong>，聚类结果和我们最开始设想的结果完全一致。</p><hr><h3 id="三、K-Means算法Python实现"><a href="#三、K-Means算法Python实现" class="headerlink" title="三、K-Means算法Python实现"></a>三、K-Means算法Python实现</h3><p>Github源码：<a href="https://github.com/QzmVc1/Data-Mining/tree/master/K-Means">QzmVc1/Data-Mining/K-Means/</a></p><h4 id="3-1-Python代码"><a href="#3-1-Python代码" class="headerlink" title="3.1 Python代码"></a>3.1 Python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: QzmVc1</span></span><br><span class="line"><span class="string">Time: 2019/1/23</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧几里得距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distEclud</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.<span class="built_in">sum</span>((x-y)**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成k个初始聚类中心</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randCent</span>(<span class="params">dataSet,k</span>):</span></span><br><span class="line">    lst = []   <span class="comment"># 防止生成重复</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    m,n = dataSet.shape</span><br><span class="line">    centroids = np.zeros((k,n))  <span class="comment"># centroids 是保存k个质心的ndarray</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; k:</span><br><span class="line">        index = np.random.randint(<span class="number">0</span>,m)</span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">            lst.append(index)</span><br><span class="line">            centroids[i,:] = dataSet[index,:]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line"><span class="comment"># K-Means算法具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMeans</span>(<span class="params">dataSet,k</span>):</span></span><br><span class="line">    m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 生成k个初始聚类中心</span></span><br><span class="line">    centroids = randCent(dataSet,k)</span><br><span class="line">    <span class="comment"># 第一列存样本属于哪一簇</span></span><br><span class="line">    <span class="comment"># 第二列存样本的到簇的中心点的误差</span></span><br><span class="line">    clusterAssment = np.zeros((m,<span class="number">2</span>))  <span class="comment"># clusterAssment数组将各点和质心关联起来</span></span><br><span class="line">    clusterChange = <span class="literal">True</span>  <span class="comment"># 循环条件</span></span><br><span class="line">    <span class="keyword">while</span> clusterChange:</span><br><span class="line">        clusterChange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):   <span class="comment"># 遍历每一个点</span></span><br><span class="line">            minIndex = -<span class="number">1</span></span><br><span class="line">            minDist = <span class="number">10000</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):  <span class="comment"># 计算该点归属于哪一个质心</span></span><br><span class="line">                dist = distEclud(centroids[j, :], dataSet[i, :])</span><br><span class="line">                <span class="keyword">if</span> dist &lt; minDist:</span><br><span class="line">                    minIndex = j</span><br><span class="line">                    minDist = dist</span><br><span class="line">            <span class="comment"># 如果存在一个点没有收敛，则继续循环</span></span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i,<span class="number">0</span>] != minIndex:</span><br><span class="line">                clusterChange = <span class="literal">True</span></span><br><span class="line">                clusterAssment[i,:] = minIndex,minDist**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算新的k个质心</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            selectrow = dataSet[np.nonzero(clusterAssment[:,<span class="number">0</span>]==j)[<span class="number">0</span>]]  <span class="comment"># 获取簇类所有的点</span></span><br><span class="line">            centroids[j,:] = np.mean(selectrow,axis=<span class="number">0</span>)  <span class="comment"># 对矩阵的行求均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centroids,clusterAssment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画聚类图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCluster</span>(<span class="params">dataSet,k,centroids,clusterAssment</span>):</span></span><br><span class="line">    m,n = dataSet.shape</span><br><span class="line">    marker = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;Dr&#x27;</span>, <span class="string">&#x27;Db&#x27;</span>, <span class="string">&#x27;Dg&#x27;</span>, <span class="string">&#x27;Dk&#x27;</span>, <span class="string">&#x27;&lt;r&#x27;</span>, <span class="string">&#x27;pr&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据不是二维的！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> k &gt; <span class="built_in">len</span>(marker):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;聚类结果超出限制！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 绘制所有样本</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            plt.plot(dataSet[i,<span class="number">0</span>],dataSet[i,<span class="number">1</span>],marker[<span class="built_in">int</span>(clusterAssment[i,<span class="number">0</span>])])</span><br><span class="line">        <span class="comment"># 绘制质心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            plt.plot(centroids[i,<span class="number">0</span>],centroids[i,<span class="number">1</span>],marker[i+k])</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataSet = np.loadtxt(<span class="string">&#x27;K-Means_Data.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 聚类个数</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">centroids,clusterAssment = KMeans(dataSet,k)</span><br><span class="line">showCluster(dataSet,k,centroids,clusterAssment)</span><br></pre></td></tr></table></figure><h4 id="3-2-数据集"><a href="#3-2-数据集" class="headerlink" title="3.2 数据集"></a>3.2 数据集</h4><p>共80组数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">1.6589854.285136</span><br><span class="line">-3.4536873.424321</span><br><span class="line">4.838138-1.151539</span><br><span class="line">-5.379713-3.362104</span><br><span class="line">0.9725642.924086</span><br><span class="line">-3.5679191.531611</span><br><span class="line">0.450614-3.302219</span><br><span class="line">-3.487105-1.724432</span><br><span class="line">2.6687591.594842</span><br><span class="line">-3.1564853.191137</span><br><span class="line">3.165506-3.999838</span><br><span class="line">-2.786837-3.099354</span><br><span class="line">4.2081872.984927</span><br><span class="line">-2.1233372.943366</span><br><span class="line">0.704199-0.479481</span><br><span class="line">-0.392370-3.963704</span><br><span class="line">2.8316671.574018</span><br><span class="line">-0.7901533.343144</span><br><span class="line">2.943496-3.357075</span><br><span class="line">-3.195883-2.283926</span><br><span class="line">2.3364452.875106</span><br><span class="line">-1.7863452.554248</span><br><span class="line">2.190101-1.906020</span><br><span class="line">-3.403367-2.778288</span><br><span class="line">1.7781243.880832</span><br><span class="line">-1.6883462.230267</span><br><span class="line">2.592976-2.054368</span><br><span class="line">-4.007257-3.207066</span><br><span class="line">2.2577343.387564</span><br><span class="line">-2.6790110.785119</span><br><span class="line">0.939512-4.023563</span><br><span class="line">-3.674424-2.261084</span><br><span class="line">2.0462592.735279</span><br><span class="line">-3.1894701.780269</span><br><span class="line">4.372646-0.822248</span><br><span class="line">-2.579316-3.497576</span><br><span class="line">1.8890345.190400</span><br><span class="line">-0.7987472.185588</span><br><span class="line">2.836520-2.658556</span><br><span class="line">-3.837877-3.253815</span><br><span class="line">2.0967013.886007</span><br><span class="line">-2.7090342.923887</span><br><span class="line">3.367037-3.184789</span><br><span class="line">-2.121479-4.232586</span><br><span class="line">2.3295463.179764</span><br><span class="line">-3.2848163.273099</span><br><span class="line">3.091414-3.815232</span><br><span class="line">-3.762093-2.432191</span><br><span class="line">3.5420562.778832</span><br><span class="line">-1.7368224.241041</span><br><span class="line">2.127073-2.983680</span><br><span class="line">-4.323818-3.938116</span><br><span class="line">3.7921215.135768</span><br><span class="line">-4.7864733.358547</span><br><span class="line">2.624081-3.260715</span><br><span class="line">-4.009299-2.978115</span><br><span class="line">2.4935251.963710</span><br><span class="line">-2.5136612.642162</span><br><span class="line">1.864375-3.176309</span><br><span class="line">-3.171184-3.572452</span><br><span class="line">2.8942202.489128</span><br><span class="line">-2.5625392.884438</span><br><span class="line">3.491078-3.947487</span><br><span class="line">-2.565729-2.012114</span><br><span class="line">3.3329483.983102</span><br><span class="line">-1.6168053.573188</span><br><span class="line">2.280615-2.559444</span><br><span class="line">-2.651229-3.103198</span><br><span class="line">2.3213953.154987</span><br><span class="line">-1.6857032.939697</span><br><span class="line">3.031012-3.620252</span><br><span class="line">-4.599622-2.185829</span><br><span class="line">4.1962231.126677</span><br><span class="line">-2.1338633.093686</span><br><span class="line">4.668892-2.562705</span><br><span class="line">-2.793241-2.149706</span><br><span class="line">2.8841053.043438</span><br><span class="line">-2.9676472.848696</span><br><span class="line">4.479332-1.764772</span><br><span class="line">-4.905566-2.911070</span><br></pre></td></tr></table></figure></p><h4 id="3-3-运行结果"><a href="#3-3-运行结果" class="headerlink" title="3.3 运行结果"></a>3.3 运行结果</h4><p><img src="https://s2.ax1x.com/2019/01/23/kEMEwj.png" alt=""></p><hr><h3 id="四、K-Means优点与缺点"><a href="#四、K-Means优点与缺点" class="headerlink" title="四、K-Means优点与缺点"></a>四、K-Means优点与缺点</h3><blockquote><p>优点： 易于实现</p><p>缺点:</p><ol><li><strong>K值需要预先给定，属于预先知识，很多情况下K值的估计是非常困难的</strong>，对于像计算全部微信用户的交往圈这样的场景就完全的没办法用K-Means进行。对于可以确定K值不会太大但不明确的K值的场景，可以进行迭代运算，然后找出Cost Function最小时所对应的K值，这个值往往能较好的描述有多少个簇类。</li><li><strong>K-Means算法对初始选取的聚类中心点是敏感的，不同的随机种子点得到的聚类结果完全不同。</strong></li><li><strong>K-Means算法并不是能处理所有的数据类型</strong>。它不能处理非球形簇、不同尺寸和不同密度的簇。</li><li><strong>对离群点的数据进行聚类时，K均值也有问题</strong>，这种情况下，离群点检测和删除有很大的帮助。</li></ol></blockquote><h4 id="拙劣的初始质心"><a href="#拙劣的初始质心" class="headerlink" title="拙劣的初始质心"></a>拙劣的初始质心</h4><p>当初始质心是随机的进行初始化的时候，K均值的每次运行将会产生不同的SSE,而且随机的选择初始质心结果可能很糟糕，<strong>可能只能得到局部的最优解，而无法得到全局的最优解</strong>。如下图所示：</p><p><img src="https://s2.ax1x.com/2019/01/23/kEliZQ.png" alt=""></p><p>可以看到程序迭代了4次终止，其得到了局部的最优解，显然我们可以看到其不是全局最优的，我们仍然可以找到一个更小的SSE的聚类。</p><h4 id="随机初始化的局限"><a href="#随机初始化的局限" class="headerlink" title="随机初始化的局限"></a>随机初始化的局限</h4><p>你可能会想到：多次运行，每次使用一组不同的随机初始质心，然后选择一个具有最小的SSE的簇集。该策略非常的简单，但是效果可能不是很好，这取决于数据集合寻找的簇的个数。</p><h4 id="K-Means优化算法"><a href="#K-Means优化算法" class="headerlink" title="K-Means优化算法"></a>K-Means优化算法</h4><p>为了克服K-Means算法收敛于局部最小值的问题，提出了一种二分K-均值(bisecting K-means)算法。</p><h5 id="待补充…"><a href="#待补充…" class="headerlink" title="待补充…"></a>待补充…</h5><hr>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Python3绘图库matplotlib的使用</title>
      <link href="/%E6%B5%85%E6%9E%90Python3%E7%BB%98%E5%9B%BE%E5%BA%93matplotlib%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
      <url>/%E6%B5%85%E6%9E%90Python3%E7%BB%98%E5%9B%BE%E5%BA%93matplotlib%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><b>前言</b></h3><blockquote><p>import matplotlib.pyplot as plt</p></blockquote><p>matplotlib.pyplot是一个有命令风格的函数集合，它看起来和Matlab很相似。每一个pyplot函数都使一副图像做出些许改变，例如创建一幅图，在图中创建一个绘图区域，在绘图区域中添加一条线等等。在matplotlib.pyplot中，各种状态通过函数调用保存起来，以便于可以随时跟踪像当前图像和绘图区域这样的东西。绘图函数是直接作用于当前axes(matplotlib中的专有名词，图形中组成部分，不是数学中的坐标系)。</p><hr><span id="more"></span><h3 id="一、Plot函数"><a href="#一、Plot函数" class="headerlink" title="一、Plot函数"></a>一、Plot函数</h3><p>先举一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/22/kkqgyj.png" alt=""></p><p>你可能会很疑惑X和Y轴为什么是0~3和1~4。原因是这样的，这里我们只是为plot()命令提供了一个list或者是array，matplotlib就会假设这个序列是Y轴上的取值，并且会自动为你生成X轴上的值。因为Python中的范围是从0开始的，因此X轴就是从0开始，长度与Y的长度相同，也就是[0,1,2,3]。</p><p>plot()是一个灵活的命令，它的参数可以是任意数量，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br></pre></td></tr></table></figure><br>这表示的是(x,y)对，(1,1)(2,4)(3,9)(4,16)。这里有第三个可选参数，它是字符串格式的，表示颜色和线的类型。该字符串格式中的字母和符号来自于Matlab，它是颜色字符串和线的类型字符串的组合。默认情况下，该字符串参数是 ‘b-‘，表示蓝色的实线。<br>举一个使用红色圆圈绘制上述点集的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/22/kkLa3F.png" alt=""></p><p>字符串参数表：</p><div class="table-container"><table><thead><tr><th>character</th><th>description</th><th>character</th><th>color</th></tr></thead><tbody><tr><td>‘-‘</td><td>solid line style</td><td>‘b’</td><td>blue</td></tr><tr><td>‘—‘</td><td>dashed line style</td><td>‘g’</td><td>green</td></tr><tr><td>‘-.’</td><td>dash-dot line style</td><td>‘r’</td><td>red</td></tr><tr><td>‘:’</td><td>dotted line style</td><td>‘c’</td><td>cyan</td></tr><tr><td>‘.’</td><td>point marker</td><td>‘m’</td><td>magenta</td></tr><tr><td>‘,’</td><td>pixel marker</td><td>‘y’</td><td>yellow</td></tr><tr><td>‘o’</td><td>circle marker</td><td>‘k’</td><td>black</td></tr><tr><td>‘v’</td><td>triangle_down marker</td><td>‘w’</td><td>white</td></tr><tr><td>‘^’</td><td>triangle_up marker</td></tr><tr><td>‘&lt;’</td><td>triangle_left marker</td></tr><tr><td>‘&gt;’</td><td>triangle_right marker</td></tr><tr><td>‘1’</td><td>tri_down marker</td></tr><tr><td>‘2’</td><td>tri_up marker</td></tr><tr><td>‘3’</td><td>tri_left marker</td></tr><tr><td>‘4’</td><td>tri_right marker</td></tr><tr><td>‘s’</td><td>square marker</td></tr><tr><td>‘p’</td><td>pentagon marker</td></tr><tr><td>‘*’</td><td>star marker</td></tr><tr><td>‘h’</td><td>hexagon1 marker</td></tr><tr><td>‘H’</td><td>hexagon2 marker</td></tr><tr><td>‘+’</td><td>plus marker</td></tr><tr><td>‘x’</td><td>x marker</td></tr><tr><td>‘D’</td><td>diamond marker</td></tr><tr><td>‘d’</td><td>thin_diamond marker</td></tr><tr><td>‘丨’</td><td>vline marker</td></tr><tr><td>‘_’</td><td>hline marker</td></tr></tbody></table></div><p>如果matplotlib仅限于使用上面那种list，那么它将显得毫无用处。通常，我们都是使用numpy数组，实际上，所有的序列都将被在内部被转化成numpy数字。下面的例子是使用一个命令用几种不同风格的线绘制一个数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0到5之间每隔0.2取一个数</span></span><br><span class="line">t = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 红色的破折号，蓝色的方块，绿色的三角形</span></span><br><span class="line">plt.plot(t, t, <span class="string">&#x27;r--&#x27;</span>, t, t**<span class="number">2</span>, <span class="string">&#x27;bs&#x27;</span>, t, t**<span class="number">3</span>, <span class="string">&#x27;g^&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：<br><img src="https://s2.ax1x.com/2019/01/22/kkjxDH.png" alt=""></p><hr><h4 id="1-1-xlabel-、ylabel-、title"><a href="#1-1-xlabel-、ylabel-、title" class="headerlink" title="1.1 xlabel()、ylabel()、title()"></a>1.1 xlabel()、ylabel()、title()</h4><ul><li>xlabel()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为X轴添加注解</li><li>label()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为Y轴添加注解</li><li>title()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为图像添加标题</li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties  <span class="comment">#字体管理器</span></span><br><span class="line"></span><br><span class="line">font = FontProperties(fname=<span class="string">&#x27;C:\\QzmVc1\\STZHONGS.TTF&#x27;</span>,size=<span class="number">15</span>)</span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">20</span>,<span class="number">100</span>)</span><br><span class="line">plt.plot(x,np.sin(x),<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X轴&#x27;</span>,fontproperties=font)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y轴&#x27;</span>,fontproperties=font)</span><br><span class="line">plt.legend([<span class="string">&#x27;f(x)=sin(x)&#x27;</span>],prop=font,loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;f(x) = sin(x)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果:</p><p><img src="https://s2.ax1x.com/2019/01/22/kASvWt.png" alt=""></p><p><strong>注：因为这里注解是中文的话会产生乱码问题，我们通过添加字体管理器来解决。</strong></p><h4 id="1-2-legend-、axis-、grid"><a href="#1-2-legend-、axis-、grid" class="headerlink" title="1.2 legend()、axis()、grid()"></a>1.2 legend()、axis()、grid()</h4><ul><li>legend()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为图像添加图例</li><li>axis()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定坐标轴的范围</li><li>grid()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像网格的显示</li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>,endpoint=<span class="literal">False</span>)</span><br><span class="line">plt.plot(x,x**<span class="number">2</span>,linewidth=<span class="number">1.5</span>,linestyle=<span class="string">&#x27;-&#x27;</span>,color=<span class="string">&#x27;red&#x27;</span>,marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.plot(x,x**<span class="number">3</span>,linewidth=<span class="number">1.5</span>,linestyle=<span class="string">&#x27;-&#x27;</span>,color=<span class="string">&#x27;green&#x27;</span>,marker=<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;x^2&#x27;</span>,<span class="string">&#x27;x^3&#x27;</span>],loc = <span class="string">&#x27;best&#x27;</span>) <span class="comment">#对好位置</span></span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">600</span>])</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAFKIg.png" alt=""></p><p>注：关于legend()的loc参数</p><div class="table-container"><table><thead><tr><th>序号</th><th>位置</th></tr></thead><tbody><tr><td>0</td><td>‘best’</td></tr><tr><td>1</td><td>‘upper right’</td></tr><tr><td>2</td><td>‘upper left’</td></tr><tr><td>3</td><td>‘lower left’</td></tr><tr><td>4</td><td>‘lower right’</td></tr><tr><td>5</td><td>‘right’</td></tr><tr><td>6</td><td>‘center left’</td></tr><tr><td>7</td><td>‘center right’</td></tr><tr><td>8</td><td>‘lower center’</td></tr><tr><td>9</td><td>‘upper center’</td></tr><tr><td>10</td><td>‘center’</td></tr></tbody></table></div><h4 id="1-3-xlim-、ylim-、xticks-、yticks"><a href="#1-3-xlim-、ylim-、xticks-、yticks" class="headerlink" title="1.3 xlim()、ylim()、xticks()、yticks()"></a>1.3 xlim()、ylim()、xticks()、yticks()</h4><ul><li>xlim()、ylim() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置坐标轴刻度取值范围</li><li>xticks()、yticks()&nbsp;&nbsp;&nbsp;&nbsp;设置XY轴的刻度标签值</li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAAW2d.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.xticks([<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="string">r&#x27;two&#x27;</span>,<span class="string">r&#x27;four&#x27;</span>,<span class="string">r&#x27;six&#x27;</span>,<span class="string">r&#x27;8&#x27;</span>,<span class="string">r&#x27;10&#x27;</span>])</span><br><span class="line">plt.yticks([-<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>],[<span class="string">r&#x27;bottom&#x27;</span>,<span class="string">r&#x27;0.0&#x27;</span>,<span class="string">r&#x27;1.0&#x27;</span>,<span class="string">r&#x27;2.0&#x27;</span>,<span class="string">r&#x27;3.0&#x27;</span>,<span class="string">r&#x27;4.0&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAAR8H.png" alt=""></p><h4 id="1-4-text-、annotate"><a href="#1-4-text-、annotate" class="headerlink" title="1.4 text()、annotate()"></a>1.4 text()、annotate()</h4><ul><li>text() &nbsp;&nbsp;&nbsp;&nbsp;设置图片任何位置上的文字描述和注解</li><li>annotate() &nbsp;&nbsp;&nbsp;&nbsp;对图片上某个点加注解</li></ul><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mu,sigma = <span class="number">100</span>,<span class="number">15</span></span><br><span class="line">x = mu + sigma * np.random.randn(<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">plt.hist(x,<span class="number">50</span>,normed=<span class="number">1</span>,facecolor=<span class="string">&#x27;g&#x27;</span>,alpha=<span class="number">0.75</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Smarts&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Probability&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Histogram of IQ&#x27;</span>)</span><br><span class="line">plt.text(<span class="number">60</span>,<span class="number">0.025</span>,<span class="string">r&#x27;$\mu=100,\sigma=15$&#x27;</span>) <span class="comment">#TeX表达式 &amp;...&amp;</span></span><br><span class="line">plt.axis([<span class="number">40</span>,<span class="number">160</span>,<span class="number">0</span>,<span class="number">0.03</span>])</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAE6Lq.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.01</span>)</span><br><span class="line">s = np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line">plt.plot(t,s,linewidth=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  xy -- 为注释点的坐标</span></span><br><span class="line"><span class="comment">#  xytext -- 为注解内容位置坐标，当该值为None时，注解内容放置在xy处</span></span><br><span class="line"><span class="comment">#  arrowprops -- 用于设置箭头的形状，类型为字典类型</span></span><br><span class="line">plt.annotate(<span class="string">&#x27;local max&#x27;</span>,xy=(<span class="number">2</span>,<span class="number">1</span>),xytext=(<span class="number">3</span>,<span class="number">1.5</span>),</span><br><span class="line">            arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>,shrink=<span class="number">0.05</span>),)</span><br><span class="line"></span><br><span class="line">plt.ylim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://s2.ax1x.com/2019/01/23/kAEyyn.png" alt=""></p><hr><h3 id="二、图表和子图"><a href="#二、图表和子图" class="headerlink" title="二、图表和子图"></a>二、图表和子图</h3><p>Matlab和pyplot都有当前图形(figure)和当前坐标系(axes)的概念。所有的绘图命令都是应用于当前坐标系的。gca()和gcf()(get current axes/figures)分别获取当前axes和figures的对象。通常，你不用担心这些，因为他们都在幕后被保存了，下面是一个例子，创建了两个子绘图区域(subplot)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.exp(-t) * np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line"></span><br><span class="line">t1 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">t2 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">&quot;2subplot&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(t1, f(t1), <span class="string">&#x27;bo&#x27;</span>, t2, f(t2), <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(t2, np.cos(<span class="number">2</span>*np.pi*t2), <span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>运行结果：<br><img src="https://s2.ax1x.com/2019/01/23/kAE4W4.png" alt=""></p><p>figure()命令在这儿可以不写，因为figure(1)将会被默认执行，同样，subplot(111)也是默认被执行的。subplot()中的参数分别指定了numrows、numcols、fignum，其中fignum的取值范围为1到numrows*numcols，分别表示的是将绘图区域划分为numrows行和numcols列个子绘图区域，fignum为当前子图的编号。编号是从1开始，一行一行由左向右编号的。其实subplot中的参数【111】本应写作【1,1,1】，但是如果这三个参数都小于10(其实就是第三个参数小于10)就可以省略逗号。你可以创建任意数量的子图(subplots)和坐标系(axes)。如果你想手动放置一个axes，也就是它不再是一个矩形方格，你就可以使用命令axes()，它可以让坐标系位于任何位置，axes([left,bottom,width,height])，其中所有的值都是0到1(axes([0.3,0.4,0.2,0.3])表示的是该坐标系位于figure的(0.3,0.4)处，其宽度和长度分别为figure横坐标和纵坐标总长的0.2和0.3)。其实subplot和axes的区别就在于axes大小和位置更加随意。<br>你可以创建多个figure，通过调用figure()，其参数为figure的编号。当然每个figure可以包含多个subplot或者是多个axes。例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(<span class="number">1</span>)                <span class="comment"># 编号为1的figure</span></span><br><span class="line">plt.subplot(<span class="number">211</span>)             <span class="comment"># figure1中的第一个子图</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">plt.subplot(<span class="number">212</span>)             <span class="comment"># figure1中的第二个子图</span></span><br><span class="line">plt.plot([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)                <span class="comment"># figure2</span></span><br><span class="line">plt.plot([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])          <span class="comment"># 默认使用subplot(111),此时figure2为当前figure</span></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)                <span class="comment"># 设置figure1为当前figure;</span></span><br><span class="line">                             <span class="comment"># 但是subplot(212)为当前子图</span></span><br><span class="line">plt.subplot(<span class="number">211</span>)             <span class="comment"># 使subplot(211)为当前子图</span></span><br><span class="line">plt.title(<span class="string">&#x27;Easy as 1, 2, 3&#x27;</span>) <span class="comment"># 对subplot(211)命名</span></span><br></pre></td></tr></table></figure><br>我们可以使用clf()和cla()(clear current figure/axes)清除当前figure和当前axes。<br>如果你创建了许多figures，你需要注意一件事：figure的内存直到显示调用close()函数才会被完全释放，否则它并没有被全部释放。如果只是删掉对figure的引用，或者是通过关闭window进程管理器关闭该figure，这都是不完全删除figure的，因为pyplot在内部维持了一个引用，直到close()被调用。</p><h4 id="2-1-sca-函数"><a href="#2-1-sca-函数" class="headerlink" title="2.1 sca()函数"></a>2.1 sca()函数</h4><p>sca()用来选择子图，例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>,dpi=<span class="number">50</span>) <span class="comment"># dpi为图表的大小，默认为 80</span></span><br><span class="line">ax1 = plt.subplot(<span class="number">211</span>)      <span class="comment">#创建子图 ax1</span></span><br><span class="line">ax2 = plt.subplot(<span class="number">212</span>)      <span class="comment">#创建子图 ax2</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>)   <span class="comment"># x轴定义域</span></span><br><span class="line"></span><br><span class="line">plt.sca(ax1)                <span class="comment">#选择子图 ax1</span></span><br><span class="line">plt.plot(x,np.exp(x))       <span class="comment">#在子图 ax1中绘制函数 exp(x)</span></span><br><span class="line"></span><br><span class="line">plt.sca(ax2)                <span class="comment">#选择子图 ax2</span></span><br><span class="line">plt.plot(x,np.sin(x))       <span class="comment">#在子图 ax2中绘制函数 sin(x)</span></span><br><span class="line"></span><br><span class="line">plt.show()                  <span class="comment">#展示所有图表</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="三、直方图hist"><a href="#三、直方图hist" class="headerlink" title="三、直方图hist()"></a>三、直方图hist()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)  <span class="comment"># 创建图表1</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">plt.hist(data)  <span class="comment"># 只要传入数据，直方图就会统计数据出现的次数</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAV2jA.png" alt=""></p><hr><h3 id="四、散点图scatter"><a href="#四、散点图scatter" class="headerlink" title="四、散点图scatter()"></a>四、散点图scatter()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生测试数据</span></span><br><span class="line">x = y = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">plt.scatter(x,y,color=<span class="string">&#x27;r&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAVgcd.png" alt=""></p><hr><h3 id="五、饼图pie"><a href="#五、饼图pie" class="headerlink" title="五、饼图pie()"></a>五、饼图pie()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = [<span class="number">100</span>,<span class="number">500</span>,<span class="number">300</span>]                    <span class="comment">#饼图中的数据</span></span><br><span class="line">plt.pie(data,                          <span class="comment"># 每个饼块的实际数据，如果大于1，会进行归一化，计算percentage</span></span><br><span class="line">        explode=[<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.1</span>],               <span class="comment"># 每个饼块离中心的距离</span></span><br><span class="line">        colors=[<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;g&#x27;</span>],               <span class="comment"># 每个饼块的颜色,黄红绿</span></span><br><span class="line">        labels=[<span class="string">&#x27;A part&#x27;</span>,<span class="string">&#x27;B part&#x27;</span>,<span class="string">&#x27;C part&#x27;</span>], <span class="comment"># 每个饼块的标签</span></span><br><span class="line">        labeldistance=<span class="number">1.2</span>,                   <span class="comment"># 每个饼块标签到中心的距离</span></span><br><span class="line">        autopct=<span class="string">&#x27;%0.1f%%&#x27;</span>,                  <span class="comment"># 百分比的显示格式</span></span><br><span class="line">        pctdistance=<span class="number">0.4</span>,                     <span class="comment"># 百分比到中心的距离</span></span><br><span class="line">        shadow=<span class="literal">True</span>,                         <span class="comment"># 每个饼块是否显示阴影</span></span><br><span class="line">        startangle=<span class="number">0</span>,                        <span class="comment"># 默认从x轴正半轴逆时针起</span></span><br><span class="line">        radius=<span class="number">1</span>                           <span class="comment"># 饼块的半径</span></span><br><span class="line">        )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/01/23/kAVc1H.png" alt=""></p><hr><h3 id="六、图片保存savefig"><a href="#六、图片保存savefig" class="headerlink" title="六、图片保存savefig()"></a>六、图片保存savefig()</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>当使用如下代码使用plt.savefig()保存生成的图片时，结果打开生成的图片却是一片空白。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 一些画图代码 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line">plt.savefig(<span class="string">&quot;filename.png&quot;</span>)</span><br></pre></td></tr></table></figure></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>其实产生这个现象的原因很简单：在plt.show()后调用了plt.savefig()，在plt.show()后实际上已经创建了一个新的空白的图片，这时候你再plt.savefig()就会保存这个新生成的空白图片。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>知道了原因，就不难知道解决办法了，解决办法有两种：</p><blockquote><p>1.在plt.show()之前调用plt.savefig()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&quot;&quot;&quot; 一些画图代码 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;plt.savefig(<span class="string">&quot;filename.png&quot;</span>)</span><br><span class="line">&gt;plt.show()</span><br></pre></td></tr></table></figure></p><p>2.画图的时候获取当前图像（这一点非常类似于Matlab的句柄的概念）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># gcf: Get Current Figure</span></span><br><span class="line">   fig = plt.gcf()</span><br><span class="line">   plt.show()</span><br><span class="line">   fig.savefig(<span class="string">&#x27;filename.png&#x27;</span>, dpi=<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化算法(一)：模拟退火算法</title>
      <link href="/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%B8%80-%EF%BC%9A%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95.html"/>
      <url>/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-%E4%B8%80-%EF%BC%9A%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际日常中，人们会经常遇到如下问题：在某个给定的定义域X内，求函数f(x)对应的最优值。此处以最小值问题举例（最大值问题可以等价转化成最小值问题），形式化为：<br>　　　　　　　　　　　　　　　　　<strong>min  f(x).</strong><br>如果X是离散有限取值，那么可以通过穷取法获得问题的最优解；如果X连续，但f(x)是凸的，那可以通过梯度下降等方法获得最优解；如果X连续且f(x)非凸，虽说根据已有的近似求解法能够找到问题解，可解是否是最优的还有待考量，很多时候若初始值选择的不好，非常容易陷入局部最优值。<br><img src="https://s1.ax1x.com/2018/12/17/F04aZV.png" alt=""></p><p>随着日常业务场景的复杂化，第三种问题经常遇见。如何有效地避免局部最优的困扰？模拟退火算法应运而生。其实模拟退火也算是启发式算法的一种，具体学习的是冶金学中金属加热-冷却的过程。由S.Kirkpatrick, C.D.Gelatt和M.P.Vecchi在1983年所发明的，V.Čern在1985年也独立发明此演算法。</p><p>不过模拟退火算法到底是如何模拟金属退火的原理？主要是将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。演算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。若概率大于给定的阈值，则跳转到“邻居”；若概率较小，则停留在原位置不动。<br><span id="more"></span></p><hr><h3 id="一、模拟退火算法基本思想"><a href="#一、模拟退火算法基本思想" class="headerlink" title="一、模拟退火算法基本思想"></a>一、模拟退火算法基本思想</h3><p>爬山法是一种贪婪的方法，对于一个优化问题，其大致图像如下图所示：</p><p><img src="https://s1.ax1x.com/2018/12/17/F046MR.png" alt=""></p><p>其目标是要找到函数的最大值，若初始化时，初始点的位置在C处，则会寻找到附近的局部最大值A点处，由于A点出是一个局部最大值点，故对于爬山法来讲，该算法无法跳出局部最大值点。若初始点选择在D处，根据爬山法，则会找到全部最大值点B。这一点也说明了这样基于贪婪的爬山法是否能够取得全局最优解与初始值的选取由很大的关系。</p><p>模拟退火算法(Simulated Annealing, SA)的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><p>模拟退火算法从某一较高的温度出发，这个温度称为初始温度，伴随着温度参数的不断下降，算法中的解趋于稳定，但是，可能这样的稳定解是一个局部最优解，此时，模拟退火算法中会以一定的概率跳出这样的局部最优解，以寻找目标函数的全局最优解。如上图中所示，若此时寻找到了A点处的解，模拟退火算法会以一定的概率跳出这个解，如跳到了D点重新寻找，这样在一定程度上增加了寻找到全局最优解的可能性。</p><p><img src="https://s1.ax1x.com/2018/12/17/F04Xo8.png" alt=""></p><hr><h3 id="二、模拟退火算法过程"><a href="#二、模拟退火算法过程" class="headerlink" title="二、模拟退火算法过程"></a>二、模拟退火算法过程</h3><p>(1)随机挑选一个单元k，并给它一个随机的位移，求出系统因此而产生的能量变化ΔEk。</p><p>(2)若ΔEk⩽0，该位移可采纳，而变化后的系统状态可作为下次变化的起点；<br>若ΔEk&gt;0，位移后的状态可采纳的概率为</p><p><img src="https://s1.ax1x.com/2018/12/17/F05Fe0.png" alt=""></p><p>式中T为温度，然后从(0,1)区间均匀分布的随机数中挑选一个数R，若R &lt; Pk ，则将变化后的状态作为下次的起点；否则，将变化前的状态作为下次的起点。</p><p>(3)转第(1)步继续执行，知道达到平衡状态为止。</p><p><img src="https://s1.ax1x.com/2018/12/17/F05AoT.png" alt=""></p><hr><h3 id="三、模拟退火算法的优缺点"><a href="#三、模拟退火算法的优缺点" class="headerlink" title="三、模拟退火算法的优缺点"></a>三、模拟退火算法的优缺点</h3><p>模拟退火算法的应用很广泛，可以高效地求解NP完全问题，如货郎担问题(Travelling Salesman Problem，简记为TSP)、最大截问题(Max Cut Problem)、0-1背包问题(Zero One Knapsack Problem)、图着色问题(Graph Colouring Problem)等等，但其参数难以控制，不能保证一次就收敛到最优值，一般需要多次尝试才能获得（大部分情况下还是会陷入局部最优值）。观察模拟退火算法的过程，发现其主要存在如下三个参数问题：</p><p><strong>(1) 温度T的初始值设置问题</strong><br>　　温度T的初始值设置是影响模拟退火算法全局搜索性能的重要因素之一、初始温度高，则搜索到全局最优解的可能性大，但因此要花费大量的计算时间；反之，则可节约计算时间，但全局搜索性能可能受到影响。</p><p>　　<strong>(2) 退火速度问题，即每个T值的迭代次数</strong><br>　　模拟退火算法的全局搜索性能也与退火速度密切相关。一般来说，同一温度下的“充分”搜索是相当必要的，但这也需要计算时间。循环次数增加必定带来计算开销的增大。</p><p>　　<strong>(3) 温度管理问题</strong><br>　　温度管理问题也是模拟退火算法难以处理的问题之一。实际应用中，由于必须考虑计算复杂度的切实可行性等问题，常采用如下所示的降温方式：<br>　　　　　　　　　　　　　　　　<strong>T=α×T.α∈(0,1).</strong><br>注：为了保证较大的搜索空间，α一般取接近于1的值，如0.95、0.9。</p><hr><h3 id="四、模拟退火算法Python实战"><a href="#四、模拟退火算法Python实战" class="headerlink" title="四、模拟退火算法Python实战"></a>四、模拟退火算法Python实战</h3><p>经过上面理论知识的熏陶，相信大家已经对模拟退火算法有了较深入的理解，接下来通过实战再强化一下大家的认识，此处利用模拟退火算法求解如下优化问题：<br>　　　　　　　　<strong>min f(x)=(x−2)∗(x+3)∗(x+8)∗(x−9)</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inputfun</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x-<span class="number">2</span>)*(x+<span class="number">3</span>)*(x+<span class="number">8</span>)*(x-<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">initT = <span class="number">1000</span> <span class="comment">#初始温度</span></span><br><span class="line">minT = <span class="number">1</span> <span class="comment">#温度下限</span></span><br><span class="line">iterL = <span class="number">1000</span> <span class="comment">#每个T值的迭代次数</span></span><br><span class="line">delta = <span class="number">0.95</span> <span class="comment">#温度衰减系数</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">initx = <span class="number">10</span>*(<span class="number">2</span>*np.random.rand()-<span class="number">1</span>)</span><br><span class="line">nowt = initT</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始解：&quot;</span>,initx)</span><br><span class="line"></span><br><span class="line">xx = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">300</span>)</span><br><span class="line">yy = inputfun(xx)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(xx,yy)</span><br><span class="line">plt.plot(initx,inputfun(initx),<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟退火算法寻找最小值过程</span></span><br><span class="line"><span class="keyword">while</span> nowt&gt;minT:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">1</span>,iterL,<span class="number">1</span>):</span><br><span class="line">        funVal = inputfun(initx)</span><br><span class="line">        xnew = initx+(<span class="number">2</span>*np.random.rand()-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> xnew&gt;=-<span class="number">10</span> <span class="keyword">and</span> xnew&lt;=<span class="number">10</span>:</span><br><span class="line">            funnew = inputfun(xnew)</span><br><span class="line">            res = funnew-funVal</span><br><span class="line">            <span class="keyword">if</span> res&lt;<span class="number">0</span>:</span><br><span class="line">                initx = xnew</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = np.exp(-(res)/(k*nowt))</span><br><span class="line">                <span class="keyword">if</span> np.random.rand()&lt;p:</span><br><span class="line">                    initx = xnew</span><br><span class="line">    nowt = nowt * delta</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优解：&quot;</span>,initx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优值：&quot;</span>,inputfun(initx))</span><br><span class="line">plt.plot(initx,inputfun(initx),<span class="string">&#x27;*r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><hr><p>参考链接：<br><a href="https://blog.csdn.net/AI_BigData_wh/article/details/77943787">https://blog.csdn.net/AI_BigData_wh/article/details/77943787</a><br><a href="https://blog.csdn.net/google19890102/article/details/45395257">https://blog.csdn.net/google19890102/article/details/45395257</a><br><a href="https://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html">https://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 优化算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习日记(二):信号与槽</title>
      <link href="/PyQt5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html"/>
      <url>/PyQt5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BA%8C-%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。它为高层次的事件处理自动生成所需要的附加代码。在我们所熟知的很多 GUI 工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。<br><span id="more"></span></p><hr><h3 id="二、信号与槽"><a href="#二、信号与槽" class="headerlink" title="二、信号与槽"></a>二、信号与槽</h3><h4 id="2-1-信号"><a href="#2-1-信号" class="headerlink" title="2.1 信号"></a>2.1 信号</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当对象的状态发生改变的时候，信号就由该对象发射 (emit) 出去。当一个信号被发射(emit)时候，与其关联的槽函数被立刻执行。其中该对象只负责发送信号，发射该信号的对象并不知道是那个对象在接收这个信号。这样保证了对象与对象之间的低耦合。<br>如果存在信号和多个槽函数相关联的时候，当信号被发射时，这些槽的执行顺序将会是随机的、不确定的。</p><h4 id="2-2-槽"><a href="#2-2-槽" class="headerlink" title="2.2 槽"></a>2.2 槽</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于接受信号，而且槽只是普通的对象成员函数。当和槽连接的信号被发射时，槽会被调用。一个槽并不知道是否有任何信号与自己相连接。</p><h4 id="2-3-信号与槽的绑定"><a href="#2-3-信号与槽的绑定" class="headerlink" title="2.3 信号与槽的绑定"></a>2.3 信号与槽的绑定</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过调用 QObject 对象的 connect 函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：</p><blockquote><p>connect(slot[, type=PyQt5.QtCore.Qt.AutoConnection[, no_receiver_check=False]])<br>Parameters:<br>slot – the slot to connect to, either a Python callable or another bound signal.<br>type – the type of the connection to make.<br>no_receiver_check – suppress the check that the underlying C++ receiver instance still exists and deliver the signal anyway.</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当信号与槽没有必要继续保持关联时，我们可以使用 disconnect 函数来断开连接。其定义如下：</p><blockquote><p>disconnect([slot])<br>Parameters: slot – the optional slot to disconnect from, either a Python callable or another bound signal. If it is omitted then all slots connected to the signal are disconnected.</p></blockquote><hr><h3 id="三、信号与槽的特点"><a href="#三、信号与槽的特点" class="headerlink" title="三、信号与槽的特点"></a>三、信号与槽的特点</h3><p><strong>1、一个信号可以连接到多个槽；<br>当信号发出后，槽函数都会被调用，但是调用的顺序是随机的，不确定的。</strong></p><blockquote><p>self.slider.valueChanged.connect(self.pBar.setValue)      self.slider.valueChanged.connect(self.lcdNumber.display)</p></blockquote><p>QSlider数据的变化同时绑定在setValue()和display()两个槽上。</p><p><strong>2、多个信号可以连接到同一个槽；<br>其中任何一个信号发出，槽函数都会被执行。</strong></p><blockquote><p>self.buttonOn.clicked.connect(self.showMessage)<br>self.buttonOff.clicked.connect(self.showMessage)</p></blockquote><p>showMessage()同时绑定在两个button的clicked信号上。</p><p><strong>3、信号的参数可以是任何的Python类型;</strong></p><p>如list，dict等python独有的类型。自定义信号的时候举例说明。</p><p><strong>4、信号和槽的连接可以被移除；</strong></p><p>比如断开某个特定信号的关联。</p><blockquote><p>self.buttonOn.clicked.disconnect(self.showMessage)</p></blockquote><p><strong>5、信号可以和另外一个信号进行关联；<br>第一个信号发出后，第二个信号也同时发送。</strong></p><p>比如关闭系统的信号发出之后，同时会发出保存数据的信号。</p><hr><h3 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h3><p>说实话对于像我这样的新手来说看着就脑壳疼，想学会它没办法，我们还是简化一下概念吧：</p><p>所有QObject类都可以使用信号槽，换句话来说继承自PyQt5中的类基本上都可以使用信号槽机制。当然非QObject也是可以通过其他一些办法来使用信号槽的。</p><p>仅仅有了信号和槽是不行的，我们还需要了解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信号(Signal)、槽(slot)、连接(connect)、动作事件(action)、发射(emit)、发送者、接受者等等一些列的知识。好吧，别搞的那么复杂行不行，我们还是学学该怎么用吧。</p><p>在Qt Designer中为我们提供了一些基本的信号槽方法，我们来看看：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击工具栏上的“编辑信号/槽”，进入信号槽编辑模式，我们可以直接在发送者（button）上按住鼠标左键不放，拖动到接收者（Form窗体）上。这样就建立起了连接。</p><p><img src="https://s1.ax1x.com/2018/12/05/Fl4lJe.png" alt=""></p><p>接着，会弹出配置连接对话框。</p><p><img src="https://s1.ax1x.com/2018/12/05/Fl41RH.png" alt=""></p><p>左边是发送者（按钮）的信号（动作事件），右边是接收者（窗体）的槽（动作事件）。</p><p>如图所示，我信号选择的是clicked,槽选择的是close:</p><p><img src="https://s1.ax1x.com/2018/12/05/Fl4QiD.png" alt=""></p><p>我们看一下编译后生成的代码：</p><blockquote><p>self.quitButton.clicked.connect(Form.close)</p><p>实现的功能是：当按钮点击之后关闭窗体。</p><p>流程：<br>按钮是信号发送者，当点击按钮之后会发送一个信号出去，通过这段代码程序内部的通讯机制知道这个按钮的点击事情被连接到窗体的关闭事件上去了，然后通知接受者窗体，你该运行槽函数close了！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets  </span><br><span class="line"><span class="keyword">from</span> untitled <span class="keyword">import</span> Ui_Form  </span><br><span class="line"><span class="string">&quot;&quot;&quot;点击按钮，在控制台输出helloworld&quot;&quot;&quot;</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mywindow</span>(<span class="params">QtWidgets.QWidget,Ui_Form</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="built_in">super</span>(mywindow,self).__init__()  </span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.myButton.clicked.connect(self.myPrint)   <span class="comment">#槽函数不用加括号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPrint</span>(<span class="params">self</span>):</span>                                <span class="comment">#定义槽</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;helloWorld&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    <span class="keyword">import</span> sys  </span><br><span class="line">  </span><br><span class="line">    app=QtWidgets.QApplication(sys.argv)  </span><br><span class="line">    myshow=mywindow()  </span><br><span class="line">    myshow.show()  </span><br><span class="line">    sys.exit(app.exec_())  </span><br></pre></td></tr></table></figure><hr><h3 id="五、小提示"><a href="#五、小提示" class="headerlink" title="五、小提示"></a>五、小提示</h3><p>槽其实就个函数（方法），Qt5中的槽函数不在限定必须是slot，可以是普通的函数、类的普通成员函数、lambda函数等。编译期间就会检查信号与槽是否存在！</p><p>信号的connect连接最好放在<strong>init</strong>析构函数里面，这样只会声明一次连接，如果在类方法（函数中）使用的话，要记得disconnect，否则connect会连接多次，导致程序异常。</p><p>信号槽函数不用加 ()，否则可能会导致连接异常。</p><hr><p>参考链接1：<a href="https://blog.csdn.net/zhulove86/article/details/52530214">https://blog.csdn.net/zhulove86/article/details/52530214</a><br>参考链接2：<a href="https://blog.csdn.net/a359680405/article/details/45148717">https://blog.csdn.net/a359680405/article/details/45148717</a></p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyQt5 </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习日记(一):第一个GUI程序</title>
      <link href="/PyQt5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AAGUI%E7%A8%8B%E5%BA%8F.html"/>
      <url>/PyQt5%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AAGUI%E7%A8%8B%E5%BA%8F.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://zhuanlan.zhihu.com/xdbcb8?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage">https://zhuanlan.zhihu.com/xdbcb8?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage</a></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>PyQt5是基于Digia公司强大的图形程式框架Qt5的python接口，由一组Python模块构成。PyQt5本身拥有超过620个类和6000函数及方法。在可以运行于多个平台，包括：Unix, Windows, and Mac OS。</p><p>PyQt5的类存在于如下模块当中：</p><ul><li><p>QtCore</p></li><li><p>QtGui</p></li><li><p>QtWidgets</p></li><li><p>QtMultimedia</p></li><li><p>QtBluetooth</p></li><li><p>QtNetwork</p></li><li><p>QtPositioning</p></li><li><p>Enginio</p></li><li><p>QtWebSockets</p></li><li><p>QtWebKit</p></li><li><p>QtWebKitWidgets</p></li><li><p>QtXml</p></li><li><p>QtSvg</p></li><li><p>QtSql</p></li><li><p>QtTest</p></li></ul><span id="more"></span><p><strong>QtCore模块</strong>涵盖了包的核心的非GUI功能，此模块被用于处理程序中涉及到的 time、文件、目录、数据类型、文本流、链接、mime、线程或进程等对象。</p><p><strong>QtGui模块</strong>涵盖多种基本图形功能的类; 包括但不限于：窗口集、事件处理、2D图形、基本的图像和界面 和字体文本。</p><p><strong>QtWidgets模块</strong>包含了一整套UI元素组件，用于建立符合系统风格的classic界面，非常方便，可以在安装时选择是否使用此功能。</p><p><strong>QtMultimedia模块</strong>包含了一套类库，该类库被用于处理多媒体事件，通过调用API接口访问摄像头、语音设备、收发消息（radio functionality）等。</p><p><strong>QtBluetooth模块</strong>包含了处理蓝牙活动的类库，它的功能包括：扫描设备、连接、交互等行为。</p><p><strong>QtNetwork模块</strong>包含用于网络编程的类库，这组类程序通过提供便捷的TCP/IP 及 UDP 的 c/s 程式码集合，使得基于Qt的网络编程更容易。</p><p><strong>QtPositioning模块</strong>用于获取位置信息，此模块允许使用多种方式达成定位，包括但不限于：卫星、无线网、文字信息。此应用一般用于网络地图定位系统。</p><p><strong>Enginio模块</strong>用于构建客户端的应用程式库，用于在运行时访问 Qt Cloud 服务器托管的应用程序。</p><p><strong>QtWebSockets模块</strong>包含了一组类程序，用以实现websocket协议。</p><p><strong>QtWebKit模块</strong>包含了用于实现基于webkit2的网络浏览器的类库。</p><p><strong>QtWebKitWidgets模块</strong>包含用于基于WebKit1的Web浏览器实现的类，用于基于QtWidgets的应用程序</p><p><strong>QtXml模块</strong>包含了用于处理XML的类库，此模块为SAX和DOM API 的实现提供了方法。</p><p><strong>QtSvg模块</strong>通过一组类，为显示矢量图形文件的内容提供了方法。</p><p><strong>QtSql模块</strong>提供了数据库对象的接口以供使用</p><p><strong>QtTest模块</strong>包含了可以通过单元测试，以调试PyQt5应用程式的功能。</p><blockquote><p><strong>PyQt5并不向下兼容PyQt4</strong>，主要是由于其有几个较大的改变。虽不兼容，但是旧代码调整到新库并不是很难。它们的主要差异如下：</p><p>Python的模块已经重新构建，一些模块已经被放弃，如：QtScript。其他的模块被分割到一些子模块当中，如：QtGui，QtWebkit。</p><p>一些新的模块会推出，如：QtBluetooth，QtPositioning或Enginio。</p><p><strong>PyQt5仅支持新型信号和插槽</strong>。对SIGNAL（）或SLOT（）的调用不再支持（这点很重要哦！）。</p><p>PyQt5不支持在Qt v5.0中标记为已弃用或过时的Qt API的任何部分。</p><hr><h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><p><strong>1. 首先在控制台输入如下命令</strong></p></blockquote><p>pyqt5是Python中实现GUI的一个模块，而pyqt5-tools包含了Qt designer这样的绘图软件。</p><blockquote><p>pip install pyqt5</p><p>pip install pyqt5-tools</p></blockquote><p><strong>2. 配置PyCharm</strong></p><p>1）打开PyCharm，执行快捷键ctrl+alt+s打开设置界面，输入tool，点开external tools，配置qtdesigner。</p><p>点击左上角的加号，作如下配置：</p><p>在Qt Designer的设置中，Program选择PyQt安装目录中 <strong>designer.exe</strong> 的路径</p><p>Work directory 使用变量 <strong>$FileDir$</strong> （点击后面的 Insert macro 按钮可以不用输入双击上屏）</p><p><img src="https://s1.ax1x.com/2018/12/05/Fl5l7V.png" alt=""></p><p>2）设置“PyUIC” — 这个主要是用来将 Qt界面 转换成 py代码</p><p>在PyUIC的设置中，其他的都差不多，Program 写入Python的地址，Parameters写入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m PyQt5.uic.pyuic  $FileName$ -o $FileNameWithoutExtension$.py</span><br></pre></td></tr></table></figure><br>把上面的Python路径修改成自己的即可！</p><p>Work directory 使用变量 <strong>$FileDir$</strong></p><p><img src="https://s1.ax1x.com/2018/12/05/Fl5Q00.png" alt=""></p><h3 id="三、第一个PyQt5程序"><a href="#三、第一个PyQt5程序" class="headerlink" title="三、第一个PyQt5程序"></a>三、第一个PyQt5程序</h3><p>利用PyQt5写界面的话，可以通过手动代码实现；也可以先通过Qt designer生成.ui文件，然后利用PyUIC将.ui文件转成.py文件。我主要介绍手动代码实现(<del>因为ui我学不会！emmmm</del>)。所以不懂刚才的环境配置也没关系，只要你装了PyQt5这个库就可以啦！</p><p>老规矩，先上代码~</p><hr><h4 id="3-1-第一个窗口"><a href="#3-1-第一个窗口" class="headerlink" title="3.1 第一个窗口"></a>3.1 第一个窗口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">    w = QWidget()</span><br><span class="line">    w.resize(<span class="number">600</span>,<span class="number">300</span>)</span><br><span class="line">    w.move(<span class="number">600</span>,<span class="number">600</span>)</span><br><span class="line">    w.setWindowTitle(<span class="string">&#x27;QzmVc1&#x27;</span>)</span><br><span class="line">    w.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>执行的结果如下图：</p><p><img src="https://s1.ax1x.com/2018/12/05/Fl52jA.png" alt=""></p><p>我想这个大概就是最简单的图形界面程序了，虽然简单但是确实现了图形界面程序均有的功能。</p><blockquote><p>import sys<br>from PyQt5.QtWidgets import QApplication, QWidget</p></blockquote><p>这段代码表明我们引入了python的相关模块，这就包括了sys模块，以及PyQt5中的QtWidgets模块。我们在之前（上面）描述了QtWidgets模块包含了一整套UI元素组件，用于建立符合系统风格的classic界面，非常方便。同时为了更方便的使用我们还明确了使用QtWidgets模块中的QApplication, QWidget。</p><blockquote><p>app = QApplication(sys.argv)</p></blockquote><p>每个PyQt5应用程序必须创建一个应用程序对象。 sys.argv参数是来自命令行的参数列表。 Python脚本可以从shell运行。 写了这句话就能让我们的程序从命令行启动。</p><blockquote><p>w = QWidget()</p></blockquote><p>QWidget小部件是PyQt5中所有用户界面对象的基类。 我们提供了QWidget的默认构造函数。 默认构造函数没有父类。 没有父类口小部件称为窗口。</p><blockquote><p>w.resize(600,300)</p></blockquote><p>resize（）方法调整窗口小部件的大小。这里我们设定窗口的大小：宽600像素，高300像素。</p><blockquote><p>w.move(600,600)</p></blockquote><p>move（）方法将小部件移动到屏幕上x = 600，y = 600坐标处的位置。这里我们来看一下屏幕坐标是怎么设定的，来看看下图。</p><p><img src="https://pic2.zhimg.com/80/v2-5d0b81b07074fde612b64ce9f0d62809_hd.jpg" alt=""></p><p>通过上图我们可以知晓，坐标原点是从哪里开始计算的，我们要是将程序中的（600,600）这个坐标改成（0，0），窗口就会跑到左上角去了，大家可以试试。</p><blockquote><p>w.setWindowTitle(‘QzmVc1’)</p></blockquote><p>这个方法顾名思义，就是设置窗口的标题。</p><blockquote><p>w.show()</p></blockquote><p>show（）方法在屏幕上显示窗口小部件。 一个小部件首先在内存中创建，然后在屏幕上显示。</p><blockquote><p>sys.exit(app.exec_())</p></blockquote><p>最后，我们进入应用程序的主循环(main loop)。 事件处理从这一点开始。 主循环(main loop)从窗口系统接收事件并将它们分派到应用程序小部件。 如果我们调用exit（）方法或者主窗口小部件被破坏，那么主循环(main loop)就会结束。</p><p>sys.exit（）方法确保一个干净的退出。</p><p>exec_（）方法有一个下划线。 这是因为exec是一个Python关键字。 因此，使用exec_（）。</p><p><strong>注意：为了便于初学者理解，我们把主循环(main loop)简单的谈一下。GUI应用程序都是事件驱动的。比如键盘事件、鼠标事件等等。还有一些事件来自于系统内部，比如定时事件、其它文件事件等等。在没有任何事件的情况下，应用程序处于睡眠状态。这种事件驱动机制，GUI应用程序都需要一个主循环(main loop)。主循环(main loop)控制应用程序什么时候进入睡眠状态，什么时候被唤醒。所以主循环(main loop)就是干这个的。</strong></p><hr><h4 id="3-2-为窗口设置图标"><a href="#3-2-为窗口设置图标" class="headerlink" title="3.2 为窗口设置图标"></a>3.2 为窗口设置图标</h4><p>接下来呢，我们把这个窗口美化一下，增加一个图标。当然写法上调整一下，上面的代码基本上是按照面向过程来写的，下面开始我们采用面向对象的方式进行编码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ico</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">super</span>().__init__()</span><br><span class="line">       self.initUI()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">       self.setGeometry(<span class="number">600</span>, <span class="number">600</span>, <span class="number">600</span>, <span class="number">300</span>)</span><br><span class="line">       self.setWindowTitle(<span class="string">&#x27;QzmVc1&#x27;</span>)</span><br><span class="line">       self.setWindowIcon(QIcon(path)) <span class="comment"># path填图片路径名</span></span><br><span class="line">       self.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">ex = Ico()</span><br><span class="line">sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><br>下面我们对新出现的代码进行相应的解析。</p><blockquote><p>from PyQt5.QtGui import QIcon</p></blockquote><p>从PyQt5.QtGui中引入QIcon这个类，也是为了便于图标的设定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ico</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">super</span>().__init__()</span><br><span class="line">       self.initUI()</span><br></pre></td></tr></table></figure><p>很明显，我这里继承了QWidget这个基类，并自定义了一个名为Ico的新类。同时对这个Ico的新类进行了初始化。</p><blockquote><p>self.initUI()</p></blockquote><p>程序的GUI界面用initUI()函数创建。</p><blockquote><p>self.setGeometry(600, 600, 600, 300)<br>       self.setWindowTitle(‘QzmVc1’)<br>       self.setWindowIcon(QIcon(path)) # path填图片路径名</p></blockquote><p>上面的三种方法都已经从QWidget类中继承的。 setGeometry（）做了两件事情：它在屏幕上定位窗口并设置它的大小；前两个参数是窗口的x和y位置；第三个是宽度；第四个是窗口的高度。实际上，它在一个方法中组合了resize（）和move（）方法。 最后一个方法设置应用程序图标。 为此，我们创建了一个QIcon对象。 QIcon接收到我们要显示的图标的路径。</p><hr><h4 id="3-3-关闭窗口"><a href="#3-3-关闭窗口" class="headerlink" title="3.3 关闭窗口"></a>3.3 关闭窗口</h4><p>接下我们再这个窗口增加一个关闭按钮并实现关闭窗口的功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget, QPushButton</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QCoreApplication</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ico</span>(<span class="params">QWidget</span>):</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">       self.initUI()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">initUI</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">       self.setGeometry(<span class="number">600</span>, <span class="number">600</span>, <span class="number">600</span>, <span class="number">300</span>)</span><br><span class="line">       self.setWindowTitle(<span class="string">&#x27;QzmVc1&#x27;</span>)</span><br><span class="line">       self.setWindowIcon(QIcon(path)) <span class="comment"># path填图片路径名</span></span><br><span class="line"></span><br><span class="line">       qbtn = QPushButton(<span class="string">&#x27;退出&#x27;</span>, self)</span><br><span class="line">       qbtn.clicked.connect(QCoreApplication.instance().quit)</span><br><span class="line">       qbtn.resize(<span class="number">70</span>,<span class="number">30</span>)</span><br><span class="line">       qbtn.move(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">       self.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">   app = QApplication(sys.argv)</span><br><span class="line">   ex = Ico()</span><br><span class="line">   sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><br>我们来解析一下代码。</p><blockquote><p>from PyQt5.QtWidgets import QPushButton<br>from PyQt5.QtCore import QCoreApplication</p></blockquote><p>因为需要增加按钮，所以我们引入了QPushButton类。同时我们还需要一个来自QtCore模块的对象。</p><blockquote><p>qbtn = QPushButton(‘Quit’, self)</p></blockquote><p>我们创建一个按钮。该按钮是QPushButton类的一个实例。构造函数的第一个参数是按钮的标签。第二个参数是父窗口小部件。父窗口小部件是示例窗口小部件，它是通过QWidget继承的。</p><blockquote><p>qbtn.clicked.connect(QCoreApplication.instance().quit)</p></blockquote><p>PyQt5中的事件处理系统采用信号和槽机制构建。 如果我们点击按钮，点击的信号被发出。 槽可以是Qt槽函数或任何Python可调用的函数。 QCoreApplication包含主事件循环; 它处理和调度所有事件。 instance（）方法给我们当前的实例。</p><p>请注意，QCoreApplication是通过QApplication创建的。 点击的信号连接到终止应用程序的quit（）方法。</p><p>通信在两个对象之间完成：发送方和接收方。 发送方是按钮，接收者是应用对象。</p><p>简单的来说就是按钮发出被单击的信号，连接到退出程序的方法。</p><p>这里大家看不懂没有关系，信号和槽机制很重要，可以说是PyQt5图形界面编程中十分重要的概念，我们会后面单独花费一章来讲解。</p><hr><h4 id="3-4-第一个完整程序——猜数字游戏"><a href="#3-4-第一个完整程序——猜数字游戏" class="headerlink" title="3.4 第一个完整程序——猜数字游戏"></a>3.4 第一个完整程序——猜数字游戏</h4><p>上回我们说到了改变主窗口图标，设置一个小按钮、并且关闭这个窗口。</p><p>现在我们将更加完善一下相关的小部件（唯一的按钮用途有所改变），来完成一个简单的猜数字游戏。ok，开始吧！</p><p>本次课程涉及的知识点，主要是以下几点：</p><ul><li>按钮小提示</li><li>QLineEdit小部件使用</li><li>QMessageBox的使用</li><li>关闭窗口事件触发</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget,QApplication,QPushButton,QMessageBox,QLineEdit</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.initUi()</span><br><span class="line">        self.num = randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUi</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.setGeometry(<span class="number">600</span>,<span class="number">600</span>,<span class="number">800</span>,<span class="number">600</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&#x27;猜数字&#x27;</span>)</span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">&#x27;C:\\Users\\QzmVc1\\Pictures\\Saved Pictures\\20181022195131.jpg&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        self.bt1 = QPushButton(<span class="string">&#x27;我猜&#x27;</span>,self)</span><br><span class="line">        self.bt1.setGeometry(<span class="number">380</span>,<span class="number">150</span>,<span class="number">70</span>,<span class="number">30</span>)</span><br><span class="line">        self.bt1.setToolTip(<span class="string">&#x27;点击这里猜数字&#x27;</span>)</span><br><span class="line">        self.bt1.clicked.connect(self.showMessage)</span><br><span class="line"></span><br><span class="line">        self.text = QLineEdit(<span class="string">&#x27;在这里输入数字&#x27;</span>,self)</span><br><span class="line">        self.text.selectAll()</span><br><span class="line">        self.text.setFocus()</span><br><span class="line">        self.text.setGeometry(<span class="number">350</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showMessage</span>(<span class="params">self</span>):</span></span><br><span class="line">        guessnumber = <span class="built_in">int</span>(self.text.text())</span><br><span class="line">        <span class="built_in">print</span>(self.num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guessnumber &gt; self.num:</span><br><span class="line">            QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">            self.text.setFocus()</span><br><span class="line">        <span class="keyword">elif</span> guessnumber &lt; self.num:</span><br><span class="line">            QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">            self.text.setFocus()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;答对了！进入下一轮！&#x27;</span>)</span><br><span class="line">            self.num = randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">            self.text.clear()</span><br><span class="line">            self.text.setFocus()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        reply = QMessageBox.question(self,<span class="string">&#x27;确认&#x27;</span>,<span class="string">&#x27;确认退出吗&#x27;</span>,QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)</span><br><span class="line">        <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line">            event.accept()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            event.ignore()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>上面这个程序实现的主要功能是，系统随机产生一个1-100之间的整数，我们去猜，看看能否猜中这个数字。</p><blockquote><p>import sys</p><p>from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QLineEdit</p><p>from PyQt5.QtGui import QIcon</p><p>from random import randint</p></blockquote><p>本次程序中我们使用到的模块，较上次教程多了QMessageBox, QLineEdit类和random模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">       self.initUI()</span><br><span class="line"></span><br><span class="line">       self.num = randint(<span class="number">1</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>类在进行初始化的时候，自动产生一个1-100的随机整数。</p><blockquote><p>self.bt1.setToolTip(‘点击这里猜数字’)</p></blockquote><p>要创建一个工具提示，我们调用setTooltip()方法。 我们可以使用富文本格式。鼠标停留在按钮上就会出现，如下图：</p><p><img src="https://s1.ax1x.com/2018/12/05/FlIvMd.jpg" alt=""></p><blockquote><p>self.bt1.clicked.connect(self.showMessage)</p></blockquote><p>当按钮被单击时我们调用showMessage())方法去响应执行。下一章节我们重点介绍PyQt5信号与槽的关系。</p><blockquote><p>self.text = QLineEdit(‘在这里输入数字’, self)</p><p>self.text.selectAll()</p><p>self.text.setFocus()</p><p>self.text.setGeometry(350,100,150,30)</p></blockquote><p>这里建立一个QLineEdit对象，用于让玩家输入数字。“在这里输入数字”是当窗口出现时出现的默认字符；selectAll()方法则是可以理解为将“在这里输入数字”进行全选，方便输入数字，否则你还得手动全选删除默认字符，如下图：</p><p><img src="https://s1.ax1x.com/2018/12/05/FlIxsA.jpg" alt=""></p><p>setFocus()就是让焦点置于文本栏中，方便用户输入，不然还得手动在文本栏中单击一下，很是麻烦。没有焦点的效果如下：</p><p><img src="https://s1.ax1x.com/2018/12/05/FlIzqI.jpg" alt=""></p><p>setGeometry()就是设置小部件的摆放坐标以及大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showMessage</span>(<span class="params">self</span>):</span></span><br><span class="line">    guessnumber = <span class="built_in">int</span>(self.text.text())</span><br><span class="line">    <span class="built_in">print</span>(self.num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guessnumber &gt; self.num:</span><br><span class="line">        QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">        self.text.setFocus()</span><br><span class="line">    <span class="keyword">elif</span> guessnumber &lt; self.num:</span><br><span class="line">        QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">        self.text.setFocus()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        QMessageBox.about(self,<span class="string">&#x27;看结果&#x27;</span>,<span class="string">&#x27;答对了！进入下一轮！&#x27;</span>)</span><br><span class="line">        self.num = randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">        self.text.clear()</span><br><span class="line">        self.text.setFocus()</span><br></pre></td></tr></table></figure><p>这里就是对猜测的数字和系统随机生成的数字就行判断了。因为QLineEdit输入的内容是str类型的，所有我们要进行类型转换。</p><p>QMessageBox.about就是弹出一个对话框，告诉你结果是什么样的。如下图：</p><p><img src="https://s1.ax1x.com/2018/12/05/FloKoV.jpg" alt=""></p><p>事实上QMessageBox除了有about外，还有我们程序中用到的QMessageBox.question</p><p><img src="https://s1.ax1x.com/2018/12/05/FlolJU.jpg" alt=""></p><p>QMessageBox.critical</p><p><img src="https://s1.ax1x.com/2018/12/05/FloQiT.jpg" alt=""></p><p>QMessageBox.warning</p><p><img src="https://s1.ax1x.com/2018/12/05/Floud0.jpg" alt=""></p><p>QMessageBox.information</p><p><img src="https://s1.ax1x.com/2018/12/05/FlonZq.jpg" alt=""></p><p>QMessageBox对话框包含类型只是图标不同其他无太大差别。</p><p>这里在说明一下，当我们回答正确的时候，调用clear()方法，将文本栏里面的内容清除，同时重新生成一个随机数，并将焦点置于文本栏中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line"></span><br><span class="line">       reply = QMessageBox.question(self, <span class="string">&#x27;确认&#x27;</span>, <span class="string">&#x27;确认退出吗&#x27;</span>, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> reply == QMessageBox.Yes:</span><br><span class="line"></span><br><span class="line">           event.accept()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">           event.ignore()</span><br></pre></td></tr></table></figure><br>如果关闭QWidget，则生成QCloseEvent。 要修改widget的行为，我们需要重新实现closeEvent（）事件处理程序。</p><p>我们显示一个带有两个按钮的消息框：Yes和No。第一个字符串出现在标题栏上。 第二个字符串是对话框显示的消息文本。 第三个参数指定出现在对话框中的按钮的组合。 最后一个参数是默认按钮。 它是初始键盘焦点的按钮。 返回值存储在答复变量中。</p><p>这里我们根据返回值进行判断。 如果我们单击Yes按钮，我们接受导致关闭窗口小部件并终止应用程序的事件。 否则我们忽略关闭事件。</p><hr><h2 id="本章完"><a href="#本章完" class="headerlink" title="本章完"></a>本章完</h2><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyQt5 </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器的通俗理解</title>
      <link href="/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3.html"/>
      <url>/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="http://lib.csdn.net/article/python/62942">http://lib.csdn.net/article/python/62942</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在学习Python的过程中，我相信有很多人和我一样，对Python的装饰器一直觉得很困惑，我也是困惑了好久，并通过思考和查阅才能略有领悟，我希望以下的内容会对你有帮助，我也努力通过通俗的方式使得对Python装饰器的理解更加的透彻。在文中如有遗漏和不足，欢迎交流和指点。</p><p>很多人对装饰器难以理解，原因是由于以下三点内容没有搞清楚：</p><ul><li><strong>关于函数“变量”（或“变量”函数）的理解</strong></li><li><strong>关于高阶函数的理解</strong></li><li><strong>关于嵌套函数的理解</strong><br>那么如果能对以上的问题一一攻破，同时遵循装饰器的基本原则，相信会对装饰器有个很好的理解的。那么我们先来看以下装饰器的目的及其原则。<span id="more"></span></li></ul><hr><h3 id="一、装饰器"><a href="#一、装饰器" class="headerlink" title="一、装饰器"></a>一、装饰器</h3><p>装饰器实际上就是为了给某程序增添功能，但该程序已经上线或已经被使用，那么就不能大批量的修改源代码，这样是不科学的也是不现实的，因为就产生了装饰器，使得其满足：</p><ul><li><strong>不能修改被装饰的函数的源代码</strong></li><li><strong>不能修改被装饰的函数的调用方式</strong></li><li><strong>满足1、2的情况下给程序增添功能</strong></li></ul><p>那么根据需求，同时满足了这三点原则，这才是我们的目的。因为，下面我们从解决这三点原则入手来理解装饰器。</p><p>等等，我要在需求之前先说装饰器的原则组成：</p><p><strong>&lt; 函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 = 装饰器 &gt;</strong></p><p>这个式子是贯穿装饰器的灵魂所在！</p><hr><h3 id="二、需求的实现"><a href="#二、需求的实现" class="headerlink" title="二、需求的实现"></a>二、需求的实现</h3><p>假设有代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><br>很显然，这段代码运行的结果一定是：等待约2秒后，输出:</p><blockquote><p>test is running</p></blockquote><p>那么要求在满足三原则的基础上，给程序添加统计运行时间（2 second）功能<br>在行动之前，我们先来看一下文章开头提到的原因1（关于函数“变量”（或“变量”函数）的理解）</p><h4 id="2-1、函数“变量”（或“变量”函数）"><a href="#2-1、函数“变量”（或“变量”函数）" class="headerlink" title="2.1、函数“变量”（或“变量”函数）"></a>2.1、函数“变量”（或“变量”函数）</h4><p>假设有代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Do something&quot;</span>)</span><br><span class="line">test2 = <span class="keyword">lambda</span> x:x*<span class="number">2</span></span><br></pre></td></tr></table></figure><br>那么在内存中，应该是这样的：</p><p><img src="http://i.imgur.com/XG8SykL.jpg" alt=""></p><p>很显然，函数和变量是一样的，都是“一个名字对应内存地址中的一些内容”<br>那么根据这样的原则，我们就可以理解两个事情：</p><p>test1表示的是函数的内存地址<br>test1()就是调用对在test1这个地址的内容，即函数<br>如果这两个问题可以理解，那么我们就可以进入到下一个原因(关于高阶函数的理解)</p><h4 id="2-2高阶函数"><a href="#2-2高阶函数" class="headerlink" title="2.2高阶函数"></a>2.2高阶函数</h4><p>那么对于高阶函数的形式可以有两种：</p><p>把一个函数名当作实参传给另外一个函数（“实参高阶函数”）<br>返回值中包含函数名（“返回值高阶函数”）</p><p>那么这里面所说的函数名，实际上就是函数的地址，也可以认为是函数的一个标签而已，并不是调用，是个名词。如果可以把函数名当做实参，那么也就是说可以把函数传递到另一个函数，然后在另一个函数里面做一些操作，根据这些分析来看，这岂不是满足了装饰器三原则中的第一条，即不修改源代码而增加功能。那我们看来一下具体的做法：</p><p>还是针对上面那段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func() <span class="comment">#2</span></span><br><span class="line">    stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(stop-start)</span><br><span class="line"></span><br><span class="line">deco(test) <span class="comment">#1</span></span><br></pre></td></tr></table></figure></p><p>我们来看一下这段代码，在#1处，我们把test当作实参传递给形参func，即func=test。注意，这里传递的是地址，也就是此时func也指向了之前test所定义的那个函数体，可以说在deco()内部，func就是test。在#2处，把函数名后面加上括号，就是对函数的调用（执行它）。因此，这段代码运行结果是：</p><blockquote><p>test is running!<br>the run time is 3.0009405612945557</p></blockquote><p>我们看到似乎是达到了需求，即执行了源程序，同时也附加了计时功能，但是这只满足了原则1（不能修改被装饰的函数的源代码），但这修改了调用方式。假设不修改调用方式，那么在这样的程序中，被装饰函数就无法传递到另一个装饰函数中去。</p><p>那么再思考，如果不修改调用方式，就是一定要有test()这条语句，那么就用到了第二种高阶函数，即返回值中包含函数名。</p><p>如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line">t = deco(test) <span class="comment">#3</span></span><br><span class="line"><span class="comment">#t()#4</span></span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><br>我们看这段代码，在#3处，将test传入deco()，在deco()里面操作之后，最后返回了func，并赋值给t。因此这里test =&gt; func =&gt; t，都是一样的函数体。最后在#4处保留了原来的函数调用方式。<br>看到这里显然会有些困惑，我们的需求不是要计算函数的运行时间么，怎么改成输出函数地址了。是因为，单独采用第二种高阶函数（返回值中包含函数名）的方式，并且保留原函数调用方式，是无法计时的。如果在deco()里计时，显然会执行一次，而外面已经调用了test()，会重复执行。这里只是为了说明第二种高阶函数的思想，下面才真的进入重头戏。</p><h4 id="2-3-嵌套函数"><a href="#2-3-嵌套函数" class="headerlink" title="2.3 嵌套函数"></a>2.3 嵌套函数</h4><p>嵌套函数指的是在函数内部定义一个函数，而不是调用，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#而不是</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    func2()</span><br></pre></td></tr></table></figure><br>另外还有一个题外话，函数只能调用和它同级别以及上级的变量或函数。也就是说：里面的能调用和它缩进一样的和他外部的，而内部的是无法调用的。</p><p>那么我们再回到我们之前的那个需求，想要统计程序运行时间，并且满足三原则。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>) #5</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">deco</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="built_in">print</span>(stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line">test = timer(test) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">test() <span class="comment">#7</span></span><br></pre></td></tr></table></figure><br>这段代码可能会有些困惑，怎么忽然多了这么多，暂且先接受它，分析一下再来说为什么是这样。</p><p>首先，在#6处，把test作为参数传递给了timer()，此时，在timer()内部，func = test，接下来，定义了一个deco()函数，当并未调用，只是在内存中保存了，并且标签为deco。在timer()函数的最后返回deco()的地址deco。</p><p>然后再把deco赋值给了test，那么此时test已经不是原来的test了，也就是test原来的那些函数体的标签换掉了，换成了deco。那么在#7处调用的实际上是deco()。</p><p>那么这段代码在本质上是修改了调用函数，但在表面上并未修改调用方式，而且实现了附加功能。</p><p><strong>那么通俗一点的理解就是：</strong><br>把函数看成是盒子，test是小盒子，deco是中盒子，timer是大盒子。程序中，把小盒子test传递到大盒子temer中的中盒子deco，然后再把中盒子deco拿出来，打开看看（调用）</p><p>这样做的原因是：</p><p>我们要保留test()，还要统计时间，而test()只能调用一次（调用两次运行结果会改变，不满足），再根据函数即“变量”，那么就可以通过函数的方式来回闭包。于是乎，就想到了，把test传递到某个函数，而这个函数内恰巧内嵌了一个内函数，再根据内嵌函数的作用域（可以访问同级及以上，内嵌函数可以访问外部参数），把test包在这个内函数当中，一起返回，最后调用这个返回的函数。而test传递进入之后，再被包裹出来，显然test函数没有弄丢（在包裹里），那么外面剩下的这个test标签正好可以替代这个包裹（内含test()）。</p><p><img src="http://i.imgur.com/hDBssgi.jpg" alt=""></p><p>至此，一切皆合，大功告成，单只差一步。</p><hr><h3 id="三、真正的装饰器"><a href="#三、真正的装饰器" class="headerlink" title="三、真正的装饰器"></a>三、真正的装饰器</h3><p>根据以上分析，装饰器在装饰时，需要在每个函数前面加上：</p><blockquote><p>test = timer(test)</p></blockquote><p>显然有些麻烦，Python提供了一种语法糖，即：</p><blockquote><p>@timer</p></blockquote><p>这两句是等价的，只要在函数前加上这句，就可以实现装饰作用。</p><p>以上为无参形式</p><hr><h3 id="四、装饰有参函数"><a href="#四、装饰有参函数" class="headerlink" title="四、装饰有参函数"></a>四、装饰有参函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>)</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">deco</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="built_in">print</span>(stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">parameter</span>):</span> <span class="comment">#8</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>对于一个实际问题，往往是有参数的，如果要在#8处，给被修饰函数加上参数，显然这段程序会报错的。错误原因是test()在调用的时候缺少了一个位置参数的。而我们知道test = func = deco，因此test()=func()=deco()<br>，那么当test(parameter)有参数时，就必须给func()和deco()也加上参数，为了使程序更加有扩展性，因此在装饰器中的deco()和func()，加如了可变参数<em>args和 *</em>kwargs。</p><p>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>)</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">deco</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="built_in">print</span>(stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">parameter</span>):</span> <span class="comment">#8</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><br>那么我们再考虑个问题，如果原函数test()的结果有返回值呢？比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">parameter</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Returned value&quot;</span></span><br></pre></td></tr></table></figure><br>那么面对这样的函数，如果用上面的代码来装饰，最后一行的test()实际上调用的是deco()。有人可能会问，func()不就是test()么，怎么没返回值呢？</p><p>其实是有返回值的，但是返回值返回到deco()的内部，而不是test()即deco()的返回值，那么就需要再返回func()的值，因此就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>)</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">deco</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(*args, **kwargs)<span class="comment">#9</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="built_in">print</span>(stop-start)</span><br><span class="line">        <span class="keyword">return</span> res<span class="comment">#10</span></span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure><br>其中，#9的值在#10处返回。</p><p>完整程序为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">improt time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>)</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">deco</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="built_in">print</span>(stop-start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">parameter</span>):</span> <span class="comment">#8</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test is running!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Returned value&quot;</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><hr><h3 id="五、带参数的装饰器"><a href="#五、带参数的装饰器" class="headerlink" title="五、带参数的装饰器"></a>五、带参数的装饰器</h3><p>又增加了一个需求，一个装饰器，对不同的函数有不同的装饰。那么就需要知道对哪个函数采取哪种装饰。因此，就需要装饰器带一个参数来标记一下。例如：</p><blockquote><p>@decorator(parameter = value)</p></blockquote><p>比如有两个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task2&quot;</span>)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure><br>要对这两个函数分别统计运行时间，但是要求统计之后输出：</p><blockquote><p>the task1/task2 run time is : 2.00……</p></blockquote><p>于是就要构造一个装饰器timer，并且需要告诉装饰器哪个是task1，哪个是task2，也就是要这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer(<span class="params">parameter=<span class="string">&#x27;task1&#x27;</span></span>) </span><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">parameter=<span class="string">&#x27;task2&#x27;</span></span>) </span><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task2&quot;</span>)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure><br>那么方法有了，但是我们需要考虑如何把这个parameter参数传递到装饰器中，我们以往的装饰器，都是传递函数名字进去，而这次，多了一个参数，要怎么做呢？<br>于是，就想到再加一层函数来接受参数，根据嵌套函数的概念，要想执行内函数，就要先执行外函数，才能调用到内函数，那么就有：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">parameter</span>):</span> <span class="comment">#</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the auth :&quot;</span>, parameter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer_deco</span>(<span class="params">func</span>):</span> <span class="comment">#</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in the outer_wrapper:&quot;</span>, parameter)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outer_deco</span><br></pre></td></tr></table></figure></p><p>首先timer(parameter)，接收参数parameter=’task1/2’，而@timer(parameter)也恰巧带了括号，那么就会执行这个函数， 那么就是相当于：</p><blockquote><p>timer = timer(parameter)<br>task1 = timer(task1)</p></blockquote><p>后面的运行就和一般的装饰器一样了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">parameter</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer_wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> parameter == <span class="string">&#x27;task1&#x27;</span>:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;the task1 run time is :&quot;</span>, stop - start)</span><br><span class="line">            <span class="keyword">elif</span> parameter == <span class="string">&#x27;task2&#x27;</span>:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;the task2 run time is :&quot;</span>, stop - start)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outer_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">parameter=<span class="string">&#x27;task1&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">parameter=<span class="string">&#x27;task2&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in the task2&quot;</span>)</span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br></pre></td></tr></table></figure><br>至此，装饰器的全部内容结束。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用selenium自动填写南邮正方的教学质量评价</title>
      <link href="/%E5%88%A9%E7%94%A8selenium%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E5%8D%97%E9%82%AE%E6%AD%A3%E6%96%B9%E7%9A%84%E6%95%99%E5%AD%A6%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7.html"/>
      <url>/%E5%88%A9%E7%94%A8selenium%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E5%8D%97%E9%82%AE%E6%AD%A3%E6%96%B9%E7%9A%84%E6%95%99%E5%AD%A6%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>这几天，南邮正方开放了教学质量评价的接口，苦于一个一个选择很麻烦，花了点时间写了个脚本进行自动填写。主要利用了Python的selenium库模拟浏览器进行自动填写。</strong></p><p><strong>转载请注明出处</strong><br><span id="more"></span></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">-*-author : QzmVc1 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="comment"># 显示等待</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="comment"># 设置等待执行语句</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> dirname,join</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">USERNAME = <span class="built_in">input</span>(<span class="string">&quot;请输入正方账号：&quot;</span>)</span><br><span class="line">PASSWORD = <span class="built_in">input</span>(<span class="string">&quot;请输入正方密码：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆正方</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;http://jwxt.njupt.edu.cn/&#x27;</span>)</span><br><span class="line"><span class="comment"># 输入账号</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;txtUserName&#x27;</span>).clear()</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;txtUserName&#x27;</span>).send_keys(USERNAME)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密码处理</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;Textbox1&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;form1&quot;]/div/div[1]/h2/img&#x27;</span>).click()</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;TextBox2&#x27;</span>).clear()</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;TextBox2&#x27;</span>).send_keys(PASSWORD)</span><br><span class="line"><span class="comment"># path = join(dirname(__file__),&#x27;save.png&#x27;)</span></span><br><span class="line"><span class="comment"># urlretrieve(&#x27;http://jwxt.njupt.edu.cn/CheckCode.aspx&#x27;,path)</span></span><br><span class="line"><span class="comment"># im = Image.open(path)</span></span><br><span class="line"><span class="comment"># im.show()</span></span><br><span class="line"><span class="comment"># 手动输入验证码</span></span><br><span class="line">cap = <span class="built_in">input</span>(<span class="string">&quot;请输入验证码：&quot;</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;txtSecretCode&#x27;</span>).send_keys(cap)</span><br><span class="line"><span class="comment"># WebDriverWait(driver,10).until(</span></span><br><span class="line"><span class="comment">#     EC.presence_of_element_located(</span></span><br><span class="line"><span class="comment">#        (By.ID,&#x27;TextBox2&#x27;),</span></span><br><span class="line"><span class="comment">#     )</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&#x27;Button1&#x27;</span>).click()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------南邮正方系统自动登陆成功！------------&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.switch_to.alert.accept()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------开始自动填写教学质量评价！------------\n...&quot;</span>)</span><br><span class="line">length1 = <span class="built_in">len</span>(driver.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;headDiv&quot;]/ul/li[3]/ul/li&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length1+<span class="number">1</span>):</span><br><span class="line">        drop_down = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;headDiv&quot;]/ul/li[3]/a/span&#x27;</span>)</span><br><span class="line">        action = ActionChains(driver)</span><br><span class="line">        action.move_to_element(drop_down).perform()</span><br><span class="line">        action.move_by_offset(<span class="number">0</span>,i*<span class="number">20</span>).click().perform()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            driver.switch_to.alert.accept()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        driver.switch_to.frame(<span class="string">&#x27;iframeautoheight&#x27;</span>)</span><br><span class="line">        length1_ = <span class="built_in">len</span>(driver.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;DataGrid1&quot;]/tbody/tr&#x27;</span>))-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,length1_+<span class="number">1</span>):</span><br><span class="line">                Select(driver.find_element_by_id(<span class="string">&#x27;DataGrid1__ctl&#123;0&#125;_JS1&#x27;</span>.<span class="built_in">format</span>(j))).select_by_value(<span class="string">&quot;完全认同&quot;</span>)</span><br><span class="line">            Select(driver.find_element_by_id(<span class="string">&#x27;DataGrid1__ctl&#123;0&#125;_JS1&#x27;</span>.<span class="built_in">format</span>(length1_+<span class="number">1</span>))).select_by_value(<span class="string">&quot;相对认同&quot;</span>)</span><br><span class="line">            driver.find_element_by_name(<span class="string">&#x27;Button1&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">if</span> i == length1:</span><br><span class="line">                driver.find_element_by_name(<span class="string">&#x27;Button2&#x27;</span>).click()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    driver.switch_to.alert.accept()</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;...\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, length1_ + <span class="number">1</span>):</span><br><span class="line">                Select(driver.find_element_by_id(<span class="string">&#x27;DataGrid1__ctl&#123;0&#125;_JS1&#x27;</span>.<span class="built_in">format</span>(j))).select_by_value(<span class="string">&quot;好&quot;</span>)</span><br><span class="line">            Select(driver.find_element_by_id(<span class="string">&#x27;DataGrid1__ctl&#123;0&#125;_JS1&#x27;</span>.<span class="built_in">format</span>(length1_ + <span class="number">1</span>))).select_by_value(<span class="string">&quot;较好&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> i != length1:</span><br><span class="line">                driver.find_element_by_name(<span class="string">&#x27;Button1&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                driver.find_element_by_name(<span class="string">&#x27;Button1&#x27;</span>).click()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    driver.switch_to.alert.accept()</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                driver.find_element_by_name(<span class="string">&#x27;Button2&#x27;</span>).click()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    driver.switch_to.alert.accept()</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;...\n&quot;</span>)</span><br><span class="line">        driver.switch_to.default_content()</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------教学质量评价已全部自动填写完毕！------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意点1：南邮正方密码的send_keys处理</p><p>注意点2：iframe框架的处理</p><p>注意点3：弹框的异常处理</p><p>注意点4： 程序的普适性和鲁棒性</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> selenium </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(八) 利用Scrapy爬取数据绘制词云图片</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E5%85%AB-%E5%88%A9%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E8%AF%8D%E4%BA%91%E5%9B%BE%E7%89%87.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E5%85%AB-%E5%88%A9%E7%94%A8Scrapy%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E8%AF%8D%E4%BA%91%E5%9B%BE%E7%89%87.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>偶然间看到了利用Python绘制词云图，一时兴起，睡意全无，导致现在已经深夜两点多了一个人默默坐在宿舍的客厅里敲着代码。现在的天气是真的冷啊，可有什么办法呢，<del>我就是这么热爱学习！</del> 哈哈哈哈hahahah。<br>虽然本篇博客把它归到了Scrapy里面，但是其大部分内容还是和绘图有关的(其实也没多少)。我们仅仅利用Scrapy爬取网上的相关数据做成一份单词表就够了，话不多说，直接正题叭~<br><span id="more"></span></p><hr><h3 id="一、利用Scrapy爬取数据"><a href="#一、利用Scrapy爬取数据" class="headerlink" title="一、利用Scrapy爬取数据"></a>一、利用Scrapy爬取数据</h3><p>应该是很熟练的一个操作了叭，可我还是掉进了很多坑，呜呜呜，wtcl。<br>像以前一样，新建Scrapy项目，然后创建我们的爬虫，直接上代码吧！</p><p><strong><em>wordcloud.py</em></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordcloudSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;wordcloud&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/subject/26752088/discussion/&#x27;</span>]</span><br><span class="line">    bash_url = <span class="string">&#x27;https://movie.douban.com/subject/26752088/discussion/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        URL = response.xpath(<span class="string">&#x27;//span[@class=&quot;next&quot;]/a//@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URL:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(urljoin(self.bash_url,url),dont_filter=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URL:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(urljoin(self.bash_url,url),callback=self.parse_item,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        comments = response.xpath(<span class="string">&#x27;//a[@title]/text()&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> comment <span class="keyword">in</span> comments:</span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: comment.strip()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><img src="https://s1.ax1x.com/2018/11/29/FZlEkT.png" alt=""></p><p>这个代码的主要目的是爬取以上页面的title值做一份单词表。</p><p>接下来我们执行命令将数据存入csv文件中:</p><blockquote><p>scrapy crawl wordcloud -o save.csv -s CLOSESPIDER_ITEMCOUNT=10</p></blockquote><p><strong><em>save.csv</em></strong></p><p><img src="https://s1.ax1x.com/2018/11/29/FZlZhF.png" alt=""></p><hr><h3 id="二、开始绘图"><a href="#二、开始绘图" class="headerlink" title="二、开始绘图"></a>二、开始绘图</h3><p><img src="https://s1.ax1x.com/2018/11/29/FZluc9.png" alt=""></p><p>我们首先将以上文件放入同一文件夹中：</p><ul><li>ciyun.py 脚本</li><li>save.csv 刚刚爬取的数据文件</li><li>ciyun01.png 词云的背景图</li></ul><p><img src="https://s1.ax1x.com/2018/11/29/FZlUcd.png" alt=""></p><p>先上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取脚本所在目录</span></span><br><span class="line">Path = os.path.dirname(__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取csv文件并用jieba分词库制作词表</span></span><br><span class="line">csv = <span class="built_in">open</span>(os.path.join(Path,<span class="string">&#x27;save.csv&#x27;</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()</span><br><span class="line">seg_list = jieba.cut(csv,cut_all=<span class="literal">False</span>)</span><br><span class="line">seg_list = <span class="string">&quot; &quot;</span>.join(seg_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用PIL.Image读取图片并通过numpy将之转化为数据矩阵</span></span><br><span class="line">picture = np.array(Image.<span class="built_in">open</span>(os.path.join(Path,<span class="string">&#x27;ciyun01.png&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成词云</span></span><br><span class="line">wc = WordCloud(font_path=<span class="string">&#x27;C:\QzmVc1\STZHONGS.TTF&#x27;</span>,background_color=<span class="string">&quot;white&quot;</span>,max_words=<span class="number">1000</span>,max_font_size=<span class="number">300</span>,mask=picture)</span><br><span class="line">wc.generate(seg_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过双插值算法将数据转化为图片</span></span><br><span class="line">plt.imshow(wc, interpolation=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line"><span class="comment">#是否显示坐标尺</span></span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line">wc.to_file(os.path.join(Path,<span class="string">&#x27;C:\QzmVc1\Code\PyCharm\Python_Project\Python_Spider\Spider_Test1\WordCloud\WordCloud\ciyun_new01.png&#x27;</span>))</span><br></pre></td></tr></table></figure></p><p>关于以上代码做几点说明：</p><blockquote><p>1.<code>os.path.dirname(__file__)</code> 是当前py文件所在的文件目录，不包含py文件</p><p>2.打开csv文件设置的 <b>encoding=’utf-8’</b> 是为了将数据显示为中文 </p><p>3.WordCloud中设置了字体、字号、单词个数、图片数据等参数，stzhongs.ttf是宋体，需要自行下载，不设置此参数的话词云中的单词全是小方框！</p><p>4.interpolation=’bilinear’这个是双插值算法绘制图片</p></blockquote><p>图片效果：<br><img src="https://s1.ax1x.com/2018/11/29/FZlajA.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(七) 利用Scrapy进行模拟登陆</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%83-%E5%88%A9%E7%94%A8Scrapy%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%83-%E5%88%A9%E7%94%A8Scrapy%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　初来乍到的crawler，刚开始的时候觉得所有的网站无非就是分析HTML、json数据，但是忽略了很多的一个问题，有很多的网站为了反爬虫，除了需要高可用代理IP地址池外，还需要登录。例如知乎、豆瓣等等。很多信息都是需要登录以后才能爬取，但是频繁登录后就会出现验证码（有些网站直接就让你输入验证码），这就坑了，毕竟运维同学很辛苦，该反的还得反，那我们怎么办呢？这不说验证码的事儿，你可以自己手动输入验证，或者直接用云打码平台，这里我们介绍一个利用Scrapy进行模拟登录的用法。</p><p><strong>本片博客是对豆瓣进行模拟登陆，包括验证码的简单处理，不涉及爬取信息。</strong><br><span id="more"></span></p><hr><h3 id="一、分析豆瓣登陆"><a href="#一、分析豆瓣登陆" class="headerlink" title="一、分析豆瓣登陆"></a>一、分析豆瓣登陆</h3><ol><li>分析豆瓣的登陆样式 <a href="https://accounts.douban.com/login?alias=&amp;redir=https%3A%2F%2Fwww.douban.com%2F&amp;source=index_nav&amp;error=1001">豆瓣</a></li></ol><p><img src="https://s1.ax1x.com/2018/11/28/FZiRC6.png" alt=""></p><p>从上图可以看出：</p><p>(1)表单的action地址为:</p><blockquote><p><a href="https://accounts.douban.com/login">https://accounts.douban.com/login</a></p></blockquote><p>(2)验证码图片的地址为:</p><blockquote><p><a href="https://www.douban.com/misc/captcha?id=hBSbgCAQKftF1BGBeXNPI8uA:en&amp;size=s">https://www.douban.com/misc/captcha?id=hBSbgCAQKftF1BGBeXNPI8uA:en&amp;size=s</a></p></blockquote><p>(3)captcha-id值:</p><blockquote><type="hidden"name="captcha-id"value="hBSbgCAQKftF1BGBeXNPI8uA:en"></blockquote><ol><li>分析豆瓣登录页的form表单登录</li></ol><p>通过登录页我们输入错误的密码登录一次，因为只有输入错误的密码，才可以看到Network里面提交了什么样式的表单。</p><p><img src="https://s1.ax1x.com/2018/11/28/FZARCq.png" alt=""></p><p><img src="https://s1.ax1x.com/2018/11/28/FZAcUs.png" alt=""><br>因此我们需要通过Scrapy提取以下来填充表单：<br>captcha-id：图片验证码id<br>captcha-solution：图片验证码，我们通过查看图片手动输入验证码</p><p>其他如form_email等固定信息我们可以提前填入表单。</p><hr><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><p><strong>2.1 在开始着手写代码之前，我们先了解一些关于POST请求所需要的函数：</strong></p><p><strong>模拟浏览器登录</strong></p><blockquote><p><b>start_requests()：</b> 可以返回一个请求给爬虫的起始网站，这个返回的请求相当于start_urls，start_requests()返回的请求会替代start_urls里的请求。之所以利用该方法重写起始请求，是因为我们可以自定义一些解析函数；而start_urls和parse()默认解析函数是绑定在一起的。</p><p><b>Request()：</b> get请求，可以设置url、cookie、回调函数等。</p><p><b>FormRequest.from_response(): </b>表单post提交。第一个参数是上一次响应cookie的response对象，其他参数有cookie、url、表单内容等。</p><p>yield Request()可以将一个新的请求返回给爬虫执行</p><p>在发送请求时cookie的操作:<br><b>meta={‘cookiejar’:1}</b>表示开启cookie记录，首次请求时写在Request()里</p><p><b>meta={‘cookiejar’:response.meta[‘cookiejar’]}</b>表示使用上一次response的cookie，写在FormRequest.from_response()里</p><p><b>meta={‘cookiejar’:True}</b>表示使用授权后的cookie访问需要登录查看的页面</p></blockquote><p><strong>2.2 爬虫代码实现</strong></p><p><strong><em>login.py</em></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;login&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    <span class="comment"># start_urls = [&#x27;http://web/&#x27;] 我们重写start_requests</span></span><br><span class="line">    <span class="comment"># 设置防盗链，防止反爬</span></span><br><span class="line">    headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#请求登陆页面,用meta开启cookie记录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [scrapy.FormRequest(<span class="string">&quot;https://accounts.douban.com/login&quot;</span>,headers=self.headers,meta=&#123;<span class="string">&#x27;cookiejar&#x27;</span>:<span class="number">1</span>&#125;,callback=self.parse_before_login,dont_filter=<span class="literal">True</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#登陆表单填充，查看验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_before_login</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆前表单填充：......&quot;</span>)</span><br><span class="line">        <span class="comment"># 获取验证码的 id 和 url</span></span><br><span class="line">        captcha_id = response.xpath(<span class="string">&#x27;//input[@name=&quot;captcha-id&quot;]/@value&#x27;</span>).extract_first()</span><br><span class="line">        captcha_src_url = response.xpath(<span class="string">&#x27;//img[@id=&quot;captcha_image&quot;]/@src&#x27;</span>).extract_first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> captcha_src_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登陆时无需验证码...&#x27;</span>)</span><br><span class="line">            formdata = &#123;</span><br><span class="line">                <span class="string">&quot;source&quot;</span> : <span class="string">&quot;index_nav&quot;</span>,</span><br><span class="line">                <span class="string">&quot;form_email&quot;</span> : <span class="string">&quot;1026740678@qq.com&quot;</span>,</span><br><span class="line">                <span class="string">&quot;form_password&quot;</span> : <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登陆时需要验证码...&#x27;</span>)</span><br><span class="line">            <span class="comment">#通过urllib将图片下载到本地，用Pillow打开并手动输入验证码</span></span><br><span class="line">            <span class="comment">#本地存储路径</span></span><br><span class="line">            save_path = <span class="string">&#x27;C:\QzmVc1\Code\PyCharm\Python_Project\Python_Spider\Spider_Test1\SimulatedLanding\SimulatedLanding\captcha.jpeg&#x27;</span></span><br><span class="line">            <span class="comment">#下载</span></span><br><span class="line">            urlretrieve(captcha_src_url,save_path)</span><br><span class="line">            <span class="comment">#用Pillow打开图片</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                im = Image.<span class="built_in">open</span>(save_path)</span><br><span class="line">                im.show()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">            captcha_solution = <span class="built_in">input</span>(<span class="string">&quot;请输入验证码：&quot;</span>)</span><br><span class="line">            formdata = &#123;</span><br><span class="line">                <span class="string">&quot;source&quot;</span>: <span class="string">&quot;index_nav&quot;</span>,</span><br><span class="line">                <span class="string">&quot;redir&quot;</span>: <span class="string">&quot;https: // www.douban.com /&quot;</span>,</span><br><span class="line">                <span class="string">&quot;form_email&quot;</span>: <span class="string">&quot;1026740678@qq.com&quot;</span>,</span><br><span class="line">                <span class="string">&quot;form_password&quot;</span>: <span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;captcha-solution&quot;</span>: captcha_solution,</span><br><span class="line">                <span class="string">&quot;captcha-id&quot;</span>: captcha_id,</span><br><span class="line">                <span class="string">&quot;login&quot;</span>: <span class="string">&quot;登录&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在登陆...&quot;</span>)</span><br><span class="line">        <span class="comment"># 提交表单进行登陆</span></span><br><span class="line">        <span class="keyword">return</span> scrapy.FormRequest.from_response(response,headers=self.headers,meta=&#123;<span class="string">&#x27;cookiejar&#x27;</span>:response.meta[<span class="string">&#x27;cookiejar&#x27;</span>]&#125;,formdata=formdata,callback=self.parse_after_login,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_after_login</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        <span class="comment">#验证是否登录成功</span></span><br><span class="line">        account = response.xpath(<span class="string">&#x27;//a[@class=&quot;bn-more&quot;]/span/text()&#x27;</span>).extract_first()</span><br><span class="line">        <span class="keyword">if</span> account <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;登陆失败...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;登陆成功! 账户为%s &quot;</span> % (account))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>输入以下命令开始模拟登陆：</p><blockquote><p>scrapy crawl login</p></blockquote><p>运行结果：</p><p><img src="https://s1.ax1x.com/2018/11/28/FZnQgI.png" alt=""></p><p>运行到验证码获取图片时它会自己蹦出来:</p><p><img src="https://s1.ax1x.com/2018/11/28/FZnlvt.png" alt=""></p><p>登陆成功！是不是很激动呢！</p><hr><h3 id="三、问题处理"><a href="#三、问题处理" class="headerlink" title="三、问题处理"></a>三、问题处理</h3><p><strong>每次进行请求时别忘了将dont_filter设置为True！我又掉了一次坑。</strong></p><h4 id="本章完"><a href="#本章完" class="headerlink" title="本章完"></a>本章完</h4><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(六) 通过Scrapy内置的ImagePipeline下载图片</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E5%85%AD-%E9%80%9A%E8%BF%87Scrapy%E5%86%85%E7%BD%AE%E7%9A%84ImagePipeline%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E5%85%AD-%E9%80%9A%E8%BF%87Scrapy%E5%86%85%E7%BD%AE%E7%9A%84ImagePipeline%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="相信大家学了这么长时间的爬虫后都想干点什么。这章的主要任务是抓取网页上的图片并把它们下载到本地，听起来不太容易实现，但其实这很简单！"><a href="#相信大家学了这么长时间的爬虫后都想干点什么。这章的主要任务是抓取网页上的图片并把它们下载到本地，听起来不太容易实现，但其实这很简单！" class="headerlink" title="相信大家学了这么长时间的爬虫后都想干点什么。这章的主要任务是抓取网页上的图片并把它们下载到本地，听起来不太容易实现，但其实这很简单！"></a>相信大家学了这么长时间的爬虫后都想干点什么。这章的主要任务是抓取网页上的图片并把它们下载到本地，听起来不太容易实现，但其实这很简单！</h4><h4 id="注：本章爬取的网页是我的博客-http-qzmvc1-top"><a href="#注：本章爬取的网页是我的博客-http-qzmvc1-top" class="headerlink" title="注：本章爬取的网页是我的博客: http://qzmvc1.top/"></a>注：本章爬取的网页是我的博客: <a href="http://qzmvc1.top/">http://qzmvc1.top/</a></h4><span id="more"></span><hr><h3 id="一、爬取图片链接"><a href="#一、爬取图片链接" class="headerlink" title="一、爬取图片链接"></a>一、爬取图片链接</h3><p>首先要做的当然是新建爬虫项目和爬虫文件，通过图下命令即可：</p><blockquote><p>scrapy startproject ImageDownloads<br>cd ImageDownloads<br>scrapy genspider image</p></blockquote><p>下面我们开始着手工作！</p><h4 id="1-1-items-py"><a href="#1-1-items-py" class="headerlink" title="1.1 items.py"></a>1.1 items.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagedownloadsItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">  <span class="comment"># image_urls是存储图片链接的元数据</span></span><br><span class="line">    image_urls = scrapy.Field()</span><br></pre></td></tr></table></figure><h4 id="1-2-image-py"><a href="#1-2-image-py" class="headerlink" title="1.2 image.py"></a>1.2 image.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> ImageDownloads.items <span class="keyword">import</span> ImagedownloadsItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;image&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://qzmvc1.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        URL1 = response.xpath(<span class="string">&#x27;//a[@class=&quot;extend next&quot;]//@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URL1:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        URL2 = response.xpath(<span class="string">&#x27;//a[@class=&quot;article-title&quot;]/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URL2:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),callback=self.parse_item,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        item = ImagedownloadsItem()</span><br><span class="line">        image_urls = response.xpath(<span class="string">&#x27;//img/@src&#x27;</span>).extract()</span><br><span class="line">        item[<span class="string">&#x27;image_urls&#x27;</span>] = image_urls</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>水平爬取，垂直爬取一些基本的操作感到生疏的可以复习复习我以前的博客:<br><a href="http://qzmvc1.top/2018/11/19/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AAScrapy%E9%A1%B9%E7%9B%AE/">第一个Scrapy项目</a><br><a href="http://qzmvc1.top/2018/11/19/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%8C-%E6%8A%BD%E5%8F%96%E6%9B%B4%E5%A4%9A%E7%9A%84URL/">抽取更多的URL</a></p><p>parse_item()这个解析函数主要做的就是对于每一个待解析的页面(就是我们垂直爬取的内容页面)，通过Xpath表达式获取该页面内所有图片的<strong>一个URL列表</strong>，并把这个<strong>列表</strong>赋值给<em>items.py</em> 中我们定义的元数据。</p><p>之所以需要给元数据赋值为列表，是因为<strong>管道里面需要用到列表进行迭代操作</strong>，如果不是列表爬取日志上会显示 <strong><em>raise ValueError(‘Missing scheme in request url: %s’ % self._url)</em></strong> 这个错误信息。</p><p><strong>所以，<em>image.py</em> 主要是获取每张页面的图片链接，并返回每个Item。</strong></p><h4 id="1-3-pipelines-py"><a href="#1-3-pipelines-py" class="headerlink" title="1.3 pipelines.py"></a>1.3 pipelines.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> cursors</span><br><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagedownloadsPipeline</span>(<span class="params">ImagesPipeline</span>):</span></span><br><span class="line">   <span class="comment"># 迭代获取图片URL链接并进行下载</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span>(<span class="params">self,item,info</span>):</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> item[<span class="string">&#x27;image_urls&#x27;</span>]:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;http&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> url:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                   <span class="keyword">yield</span> Request(url)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    文件下载完成之后，返回一个列表 results</span></span><br><span class="line"><span class="string">    列表中是一个元组，第一个值是布尔值，请求成功或失败，第二个值是下载到的资源</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span>(<span class="params">self,results,item,info</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> results[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">&#x27;Download failure!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    lst = <span class="built_in">set</span>()</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_settings</span>(<span class="params">cls,settings</span>):</span></span><br><span class="line">        adbparams = <span class="built_in">dict</span>(</span><br><span class="line">            host = settings[<span class="string">&#x27;MYSQL_HOST&#x27;</span>],</span><br><span class="line">            user = settings[<span class="string">&#x27;MYSQL_USER&#x27;</span>],</span><br><span class="line">            password = settings[<span class="string">&#x27;MYSQL_PASSWORD&#x27;</span>],</span><br><span class="line">            db = settings[<span class="string">&#x27;MYSQL_DB&#x27;</span>],</span><br><span class="line">            cursorclass = cursors.DictCursor</span><br><span class="line">        )</span><br><span class="line">        dbpool = adbapi.ConnectionPool(<span class="string">&#x27;pymysql&#x27;</span>,**adbparams)</span><br><span class="line">        <span class="keyword">return</span> cls(dbpool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,dbpool</span>):</span></span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert,item)</span><br><span class="line">        query.addErrback(self.handle_error)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_error</span>(<span class="params">self,failure</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;failure&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_insert</span>(<span class="params">self,cursor,item</span>):</span></span><br><span class="line">        sql = <span class="string">&quot;insert into image(name,url) values(%s,%s);&quot;</span></span><br><span class="line">        urls = item[<span class="string">&#x27;image_urls&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> urls:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.lst:</span><br><span class="line">                cursor.execute(sql, (random.randint(<span class="number">0</span>, <span class="number">10000</span>), unquote(i)))</span><br><span class="line">                self.lst.add(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在 <em>Pipelines.py</em> 中定义了两个管道。一个是用来下载图片的管道，还有一个就是将图片的地址存入到数据库的管道。如果对于存储数据到数据库不熟悉的同学可以看我的另一篇博客：</p><p><a href="http://qzmvc1.top/2018/11/22/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%94-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/">Scrapy框架(五) 将数据存储到数据库</a></p><p>我们主要介绍一下 <strong>ImagedownloadsPipeline</strong> 这个管道。<br>我们在里面定义了两个函数，<strong>这两个函数的名字都是固定的。</strong> 一个是 <strong>get_media_requests()</strong> ，还有一个是 <strong>item_completed()。</strong></p><h5 id="1-3-1-get-media-requests"><a href="#1-3-1-get-media-requests" class="headerlink" title="1.3.1 get_media_requests()"></a>1.3.1 get_media_requests()</h5><p>首先我们将图片下载到本地，需要借助Scrapy内置的ImagesPipeline这个管道。</p><blockquote><p>from scrapy.pipelines.images import ImagesPipeline</p></blockquote><p>我们在 <strong><em>get_media_requests（）</em></strong> 中循环迭代存储图片URL的列表，通过 <strong><em>Request()</em></strong> 进行访问并下载。为什么要引入异常操作呢？这是因为我们爬取的图片中包含了一些本地图片：</p><p><img src="https://s1.ax1x.com/2018/11/27/FEyvKx.png" alt=""></p><p>如果不引入异常操作的话会报错:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;NoneType&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure><br>于是我们访问那些具有http请求头的URL并进行下载。</p><h5 id="1-3-2-item-completed"><a href="#1-3-2-item-completed" class="headerlink" title="1.3.2 item_completed()"></a>1.3.2 item_completed()</h5><p>文件下载完成之后，返回一个列表 results。列表中是一个元组，第一个值是布尔值，请求成功或失败，第二个值是下载到的资源。代码很简单，非常好懂！</p><h4 id="1-4-settings-py"><a href="#1-4-settings-py" class="headerlink" title="1.4 settings.py"></a>1.4 settings.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管道</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">      <span class="string">&#x27;ImageDownloads.pipelines.ImagedownloadsPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">      <span class="string">&#x27;ImageDownloads.pipelines.MysqlPipeline&#x27;</span>:<span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 数据库</span></span><br><span class="line">MYSQL_HOST = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">MYSQL_USER = <span class="string">&quot;root&quot;</span></span><br><span class="line">MYSQL_PASSWORD = <span class="string">&quot;root&quot;</span></span><br><span class="line">MYSQL_DB = <span class="string">&quot;pysqltest&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片存储路径</span></span><br><span class="line">IMAGES_STORE = <span class="string">&#x27;C:\QzmVc1\Code\PyCharm\Python_Project\Python_Spider\Spider_Test1\ImageDownloads\Spider_Picture&#x27;</span></span><br></pre></td></tr></table></figure><p>我们在 <em>settings.py</em> 中设置图片的存储路径 <strong>IMAGES_STORE</strong> ，这可以是绝对路径，也可以是相对路径。</p><h4 id="1-5-运行"><a href="#1-5-运行" class="headerlink" title="1.5 运行"></a>1.5 运行</h4><blockquote><p>scrapy crawl images</p></blockquote><p>结果如下：<br><img src="https://s1.ax1x.com/2018/11/27/FE6geK.png" alt=""></p><p><strong>注1： 图片的名字是根据URL的SHA1 值进行生成的，如果想要让名字变得更规范，可以增加file_name()函数，没什么时间了这里就先不写了，emmm…</strong></p><p><strong>注2： settings.py里面关于图片的下载除了下载路径其实还可以添加很多东西，像一些失效时间，缩略图的设置等等…有需求的可以看看文档。</strong></p><hr><h5 id="注：我们也可以通过Crawlspider进行爬取，里面的Rules也很好用。"><a href="#注：我们也可以通过Crawlspider进行爬取，里面的Rules也很好用。" class="headerlink" title="注：我们也可以通过Crawlspider进行爬取，里面的Rules也很好用。"></a>注：我们也可以通过Crawlspider进行爬取，里面的Rules也很好用。</h5><h3 id="本章完"><a href="#本章完" class="headerlink" title="本章完"></a>本章完</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(五) 将数据存储到数据库</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%94-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0Mysql%E6%95%B0%E6%8D%AE%E5%BA%93.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%94-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0Mysql%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>这章作为我最感兴趣的一章，当然要好好大写特写一番了！</p><p>因为本人对Mysql比较熟悉，Python也有Pymysql这个库可以和Mysql进行交互，所以这章主要就是介绍将数据存储到Mysql数据库的Pipeline。之前也听说过Scrapy和Mongodb数据库结合起来也很方便，有空的话以后学了再补上叭~</p><p>注：以下的演示都是基于本机上的操作，一些库名，表名，项目名什么的各位看官自己写就好啦！</p><hr><h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>我们首先需要创建或安装一些东西：</p><ul><li><p><strong>Mysql localhost新建数据库pysqltest，在该数据库下创建表单名为blog</strong></p></li><li><p><strong>安装pymysql用于连接Mysql服务器</strong></p></li></ul><p>如果对Mysql不熟悉或者需要补一下Pymysql操作的可以参考我的以下博客：</p><ol><li><p><a href="http://qzmvc1.top/2018/10/28/MySQL%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/">Mysql之增删改查</a></p></li><li><p><a href="http://qzmvc1.top/2018/10/29/PyMySQL%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92/">Pymysql实现与数据库的交互</a></p></li></ol><hr><span id="more"></span><h3 id="三、同步存储和异步存储"><a href="#三、同步存储和异步存储" class="headerlink" title="三、同步存储和异步存储"></a>三、同步存储和异步存储</h3><p>存储数据有两种方法：</p><ul><li><p><strong>同步存储</strong>：适用于数据爬取量较少的情况</p></li><li><p><strong>异步存储</strong>: 适用于数据量较大的情况( 因为Scrapy爬取的速度快于数据库的插入速度，当数据量大时，就会出现阻塞，需要异步解决 )</p></li></ul><h4 id="3-1-同步存储"><a href="#3-1-同步存储" class="headerlink" title="3.1 同步存储"></a><strong>3.1 同步存储</strong></h4><p>先来介绍一下什么是同步吧。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为，也就是说需要等待返回值或者响应。</p><p>同步存储利用pymysql与数据库进行交互就可以实现，看过那篇博客学会了pymysql之后，代码看上去就会变得非常简单了。下面的代码主要是Pipeline里面需要注意，其它的前几篇Scrapy博客都有讲解。</p><p>直接上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># items.py</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    time = scrapy.Field()</span><br><span class="line">    author = scrapy.Field()</span><br><span class="line">    link = scrapy.Field()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose,Join</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        URLS = response.xpath(<span class="string">&#x27;//*[@class=&quot;extend next&quot;]//@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        content_urls = response.xpath(<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> content_urls:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),callback=self.parse_item,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(),response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_value(<span class="string">&#x27;link&#x27;</span>,unquote(response.url))</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pipelines.py</span></span><br><span class="line"><span class="comment"># 详情请见博客：Pymysql实现与数据库的交互</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,db=<span class="string">&quot;pysqltest&quot;</span>)</span><br><span class="line">        self.cur = self.db.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        sql = <span class="string">&quot;insert into blog(title,author,time,link) values(%s,%s,%s,%s);&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cur.execute(sql,(item[<span class="string">&#x27;title&#x27;</span>],item[<span class="string">&#x27;author&#x27;</span>],item[<span class="string">&#x27;time&#x27;</span>],item[<span class="string">&#x27;link&#x27;</span>]))</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.db.rollback()</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        self.db.close()</span><br><span class="line">        self.cur.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;Demo.pipelines.DemoPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>最后，cmd在项目文件夹中输入：</p><blockquote><p>scrapy crawl demo</p></blockquote><p>即可看到运行结果:<br><img src="https://s1.ax1x.com/2018/11/22/FPlJrF.png" alt=""></p><p>是不是很棒呢！</p><h4 id="3-2-异步存储"><a href="#3-2-异步存储" class="headerlink" title="3.2 异步存储"></a><strong>3.2 异步存储</strong></h4><p>再来介绍一下什么是异步吧。在同步中，单线程会遇到阻塞的情况，这个时候必须等待响应才能继续进行；而异步碰到阻塞时，阻塞会被挂起，线程继续执行下去，也就是获取下一个响应，遇到阻塞继续挂起，以此反复。可以明显的看到异步的执行速度比同步快出很多。</p><p>先贴一篇博客：<a href="http://qzmvc1.top/2018/10/29/PyMySQL%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92/">Pymysql实现与数据库的交互</a>里面对pymysql驱动访问数据库有很形象的比喻。</p><p>先上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># items.py</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoItem</span>(<span class="params">scrapy.Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    time = scrapy.Field()</span><br><span class="line">    author = scrapy.Field()</span><br><span class="line">    link = scrapy.Field()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># demo.py</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose,Join</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        URLS = response.xpath(<span class="string">&#x27;//*[@class=&quot;extend next&quot;]//@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        content_urls = response.xpath(<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> content_urls:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),callback=self.parse_item,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(),response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_value(<span class="string">&#x27;link&#x27;</span>,unquote(response.url))</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pipelines.py</span></span><br><span class="line"><span class="comment"># 使用twsited异步IO框架，实现数据的异步写入。</span></span><br><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> cursors</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_settings</span>(<span class="params">cls,settings</span>):</span></span><br><span class="line">        adbparams = <span class="built_in">dict</span>(</span><br><span class="line">            host = settings[<span class="string">&#x27;MYSQL_HOST&#x27;</span>],</span><br><span class="line">            user = settings[<span class="string">&#x27;MYSQL_USER&#x27;</span>],</span><br><span class="line">            password = settings[<span class="string">&#x27;MYSQL_PASSWORD&#x27;</span>],</span><br><span class="line">            db = settings[<span class="string">&#x27;MYSQL_DB&#x27;</span>],</span><br><span class="line">            cursorclass = cursors.DictCursor,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 初始化数据库连接池(线程池)</span></span><br><span class="line">        <span class="comment"># 参数一：mysql的驱动</span></span><br><span class="line">        <span class="comment"># 参数二：连接mysql的配置信息</span></span><br><span class="line">        dbpool = adbapi.ConnectionPool(<span class="string">&#x27;pymysql&#x27;</span>,**adbparams)</span><br><span class="line">        <span class="keyword">return</span> cls(dbpool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,dbpool</span>):</span></span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        <span class="comment"># 在该函数内，利用连接池对象，开始操作数据，将数据写入到数据库中。</span></span><br><span class="line">        <span class="comment">#使用twiest将mysql插入变成异步</span></span><br><span class="line">        <span class="comment"># 参数1：在异步任务中要执行的函数insert_db；</span></span><br><span class="line">        <span class="comment"># 参数2：给该函数insert_db传递的参数</span></span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert,item)</span><br><span class="line">        <span class="comment"># 如果异步任务执行失败的话，可以通过ErrBack()进行监听, 给insert_db添加一个执行失败的回调事件</span></span><br><span class="line">        query.addErrback(self.handle_error)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="comment">#处理异步的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_error</span>(<span class="params">self,failure</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;failure&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_insert</span>(<span class="params">self,cursor,item</span>):</span></span><br><span class="line">        sql = <span class="string">&quot;insert into blog(title,author,time,link) values(%s,%s,%s,%s);&quot;</span></span><br><span class="line">        cursor.execute(sql,(item[<span class="string">&#x27;title&#x27;</span>],item[<span class="string">&#x27;author&#x27;</span>],item[<span class="string">&#x27;time&#x27;</span>],item[<span class="string">&#x27;link&#x27;</span>]))</span><br><span class="line">        <span class="comment"># 在execute()之后，不需要再进行commit()，连接池内部会进行提交的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;Demo.pipelines.DemoPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYSQL_HOST = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">MYSQL_DB = <span class="string">&quot;pysqltest&quot;</span></span><br><span class="line">MYSQL_USER = <span class="string">&quot;root&quot;</span></span><br><span class="line">MYSQL_PASSWORD = <span class="string">&quot;root&quot;</span></span><br></pre></td></tr></table></figure><br><img src="https://s1.ax1x.com/2018/11/22/FiPjp9.png" alt=""></p><p>下面对程序做几点说明：</p><blockquote><p>1．@classmethod<br>一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。<br>而使用@classmethod，就可以不需要实例化，直接 <strong>类名.方法名()</strong> 来调用。<br>这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁。<br>@classmethod也不需要self参数，<strong>第一个参数需要是表示自身类的cls参数。</strong></p><p>2．将数据存储到数据库，我们首先要做的是和数据库进行连接。我们定义了<strong><em>from_settings这个类方法</em></strong>，并且在里面通过<strong><em>adbapi.ConnectionPool</em></strong> 生成数据库连接池，就好比同步存储中的connect()一样。<strong>那什么是数据库连接池呢？</strong> 每次对数据库进行操作时，重新获取数据库连接时间消耗等比较大，可以建立一个连接池保存一定数量的连接，当有对象需要数据库连接时，直接将这个连接返回给该对象，不再用重新获取数据库连接，加载驱动等；在初始化连接池对象时加载一次驱动，后面都不再需要加载驱动。差不多就是这个意思。它接受两个参数，一个是数据库驱动，你要访问什么数据库就需要什么样的驱动，这里我们访问mysql就用到了pymysql模块；第二个参数是一个字典，里面包括一些数据库服务器，用户名，密码，库名等信息。可以发现，与pymysql.connect()类似。</p><p>3．关于adbparams字典，我们首先需要将一些信息存入settings.py，方便调用它们，可以看到上面的settings.py文件。还有一点需要注意的是，key值的名字都是固定的，比如cursorclass等，如果擅自修改会报错：<em>TypeError: <strong>init</strong>() got an unexpected keyword argument ‘cursor’</em>。</p><p>4．我们通过cls(dbpool)返回类对象，同时会调用构造函数，对属性进行赋值。OK, dbpool连接池属性生成成功，Mysql连接成功！</p><p>5．下面程序来到了process_item(self,item,spider)这个必须函数，在这个函数中，我们做了两件事：第一件事就是通过runInteraction()将存储变成异步存储；第二件事就是常见的事故处理方法，通过ErrBack()进行监听, 给insert_db添加一个执行失败的回调事件。</p><p>6．定于插入函数<em>do_insert</em> 和异常处理函数<em>handle_error</em> 。运行程序，OK大功告成！</p></blockquote><p>其实刚看这段程序还是花了我不少时间的，自己学着去理解程序的运行思路，还是自己面向对象这边的知识不扎实啊！！还是需要继续加油！！</p><p>有机会看看能不能搞一篇Mongodb出来叭~~</p><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(四) 使用Pipeline处理数据(一)</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E5%9B%9B-%E4%BD%BF%E7%94%A8Pipeline%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE(%E4%B8%80).html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E5%9B%9B-%E4%BD%BF%E7%94%A8Pipeline%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE(%E4%B8%80).html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Item-Pipeline简介"><a href="#一、Item-Pipeline简介" class="headerlink" title="一、Item Pipeline简介"></a>一、Item Pipeline简介</h3><p><strong>Item Pipeline的主要责任是负责处理爬虫从网页中抽取的Item，它的主要任务是清晰、验证和存储数据。</strong><br>当页面被爬虫解析后，将被发送到Item管道，并经过几个特定的次序处理数据。<br>每个初始Item管道的组件都是由一个简单的方法组成的Python类。<br>如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><br>但是我们没有具体定义，因此执行爬虫并不会输出结果。<br>他们获取了Item并执行他们的方法，同时他们还需要确定的是是否需要在Item管道中继续执行下一步或是直接丢弃掉不处理。</p><hr><h3 id="二、Item管道的通常执行过程"><a href="#二、Item管道的通常执行过程" class="headerlink" title="二、Item管道的通常执行过程"></a>二、Item管道的通常执行过程</h3><ul><li>清理HTML数据  　</li><li>验证解析到的数据（检查Item是否包含必要的字段）　　</li><li>检查是否是重复数据（如果重复就删除）　　</li><li>将解析到的数据存储到数据库中　　</li></ul><hr><span id="more"></span><h3 id="三、编写pineline规范"><a href="#三、编写pineline规范" class="headerlink" title="三、编写pineline规范"></a>三、编写pineline规范</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 可选方法，用于做参数初始化等操作，常用于保存item到文件中穿件文件并打开时用到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># doing someting</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">return</span> item   <span class="comment">#如果有下一个管道，为了传给下一个管道时用</span></span><br><span class="line">    <span class="comment"># 参数item---被爬取的item</span></span><br><span class="line">    <span class="comment"># 参数spider--爬取该item的spider</span></span><br><span class="line">    <span class="comment"># 该方法process_item是必须的方法，必须返回一个Item对象或者抛出DropItem异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 参数spider---被开启的spider</span></span><br><span class="line">    <span class="comment"># 当spider被开启时，该方法open_spider会被调用</span></span><br><span class="line">    <span class="comment"># 该方法open_spider为可选方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self, spider</span>):</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 参数spider---被关闭的spider</span></span><br><span class="line">    <span class="comment"># 当spider爬虫被关闭时，close_spider方法会被调用</span></span><br><span class="line">    <span class="comment"># 该方法close_spider为可选方法</span></span><br></pre></td></tr></table></figure><p>注意:</p><blockquote><p><strong>在settings.py文件中默认是关闭pipeline管道的。因此如果要使用自定义的管道文件，还需要在settings.py文件中启用pipeline。如果你在pipeline定义了多个管道的类，在settings.py中可以写多个pipeline的类，通过后面的数字的优先级区分哪个先执行。优先级的取值范围为0到1000，数值越小优先级越高。</strong></p></blockquote><p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See https://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;Demo.pipelines.DemoPipeline1&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">   <span class="string">&#x27;Demo.pipelines.DemoPipeline2&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述DemoPipeline2先执行。</p><hr><h3 id="四、Item-Pipeline例子"><a href="#四、Item-Pipeline例子" class="headerlink" title="四、Item Pipeline例子"></a>四、Item Pipeline例子</h3><h4 id="4-1-数据清理"><a href="#4-1-数据清理" class="headerlink" title="4.1 数据清理"></a>4.1 数据清理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：VAT:Value Added Tax(增值税)</span></span><br><span class="line"><span class="comment"># 以上代码可以过滤那些没有价格的产品，并且对那些不包括增值税产品的价格进行调整</span></span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    vat_factor = <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&#x27;price&#x27;</span>]:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="string">&#x27;price_excludes_vat&#x27;</span>]:</span><br><span class="line">                item[<span class="string">&#x27;price&#x27;</span>] = item[<span class="string">&#x27;price&#x27;</span>] * self.vat_factor</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">&quot;Missing price in %s&quot;</span> % item)</span><br></pre></td></tr></table></figure><h4 id="4-2-把Item写入Json文件"><a href="#4-2-把Item写入Json文件" class="headerlink" title="4.2 把Item写入Json文件"></a>4.2 把Item写入Json文件</h4><p>还是之前的项目Demo, 我们直接修改 <em>pipelines.py</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入Json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 生成文件对象</span></span><br><span class="line">        self.fp = <span class="built_in">open</span>(<span class="string">&#x27;C:\QzmVc1\Code\PyCharm\Python_Project\Python_Spider\Spider_Test1\Demo\scrapy.json&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self,item,spider</span>):</span></span><br><span class="line">        <span class="comment"># 将item转换为json格式</span></span><br><span class="line">        data = json.dumps(<span class="built_in">dict</span>(item),ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 写入json文件</span></span><br><span class="line">        self.fp.write(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span>(<span class="params">self,spider</span>):</span></span><br><span class="line">        <span class="comment"># 关闭文件</span></span><br><span class="line">        self.fp.close()</span><br></pre></td></tr></table></figure><br>scrapy.json文件内容:<br><img src="https://s1.ax1x.com/2018/11/21/FClz1f.png" alt=""></p><p>有的时候真的不能只看不练，当自己真正上手写的时候，才会发现自己的基础是那么差，漏洞百出。这里写的时候又碰到N多个坑，慢慢来吧，唉…</p><p>我同时也会把这些坑加入到我的这篇博客：<a href="http://qzmvc1.top/2018/11/19/Scrapy%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BB%86%E6%95%B0%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">Scrapy框架之细数到目前为止我遇到的坑</a></p><blockquote><p>坑1：<strong>json.dumps的参数ensure_ascii=False：</strong></p><p>在使用json.dumps时要注意一个问题<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> json.dumps(<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line"></span><br><span class="line">输出：<span class="string">&quot;\u4e2d\u56fd&quot;</span></span><br><span class="line">输出的会是</span><br><span class="line"><span class="string">&#x27;中国&#x27;</span> 中的<span class="built_in">ascii</span> 字符码，而不是真正的中文。</span><br></pre></td></tr></table></figure><br>因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False;</p><p>坑2：<strong>中文保存到json文件中产生乱码</strong></p><p>如上述代码所示转换为’UTF-8’编码，因为str.encode返回值是一个bytes对象，因此打开文件的方式要写成 ‘wb’ 。<br>也可以通过在settings.py中添加如下代码：</p><blockquote><p>FEED_EXPORT_ENCODING = ‘UTF-8’</p></blockquote></blockquote><h4 id="4-3-删除重复数据"><a href="#4-3-删除重复数据" class="headerlink" title="4.3 删除重复数据"></a>4.3 删除重复数据</h4><p>一个用于去重的过滤器，丢弃那些已经被处理过的item。假设item有一个唯一的id，但是我们spider返回的多个item中包含了相同的id,去重方法如下：这里初始化了一个集合，每次判断id是否在集合中已经存在，从而做到去重的功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplicatesPipeline</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ids_seen = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span>(<span class="params">self, item, spider</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&#x27;id&#x27;</span>] <span class="keyword">in</span> self.ids_seen:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">&quot;Duplicate item found: %s&quot;</span> % item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.ids_seen.add(item[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="4-4-将数据写入数据库"><a href="#4-4-将数据写入数据库" class="headerlink" title="4.4 将数据写入数据库"></a>4.4 将数据写入数据库</h4><p>见下一章</p><hr><h3 id="五、激活Item-Pipeline组件"><a href="#五、激活Item-Pipeline组件" class="headerlink" title="五、激活Item Pipeline组件"></a>五、激活Item Pipeline组件</h3><p>在settings.py文件中，往ITEM_PIPELINES中添加项目管道的类名，就可以激活项目管道组件，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;Demo.pipelines.DemoPipeline1&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">&#x27;Demo.pipelines.DemoPipeline2&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>整数值通常设置在0-1000之间，数值越低代表优先级越高。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(三) 基于Excel文件爬取的爬虫</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%89-%E5%9F%BA%E4%BA%8EExcel%E6%96%87%E4%BB%B6%E7%88%AC%E5%8F%96%E7%9A%84%E7%88%AC%E8%99%AB.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%89-%E5%9F%BA%E4%BA%8EExcel%E6%96%87%E4%BB%B6%E7%88%AC%E5%8F%96%E7%9A%84%E7%88%AC%E8%99%AB.html</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a><b>引言</b></h3><p>大多数情况下，每个源网站只会有一个爬虫；不过在某些情况下，你想要抓取的数据来自多个网站，此时唯一变化的东西就是所使用的XPath表达式。对于此类情况，如果为每个网站都设置一个爬虫则显得有些小题大做。那么可以只使用一个爬虫来爬取所有这些网站吗？答案是肯定的。</p><hr><span id="more"></span><h3 id="一、基于Excel文件爬取的爬虫"><a href="#一、基于Excel文件爬取的爬虫" class="headerlink" title="一、基于Excel文件爬取的爬虫"></a><b>一、基于Excel文件爬取的爬虫</b></h3><h4 id="1-1-CSV文件创建"><a href="#1-1-CSV文件创建" class="headerlink" title="1.1 CSV文件创建"></a><b>1.1 CSV文件创建</b></h4><p>现在，创建一个.csv文件，其中包含想要抽取的信息。可以使用一个电子表格程序，比如Microsoft Excel，来创建这个.csv文件。</p><p>关于csv文件，可以参考我的一篇博客：<a href="http://qzmvc1.top/2018/10/28/Python3-%E7%94%A8CSV%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99CSV%E6%96%87%E4%BB%B6/">用CSV模块读写CSV文件</a></p><p>按下图填入相关信息，参考如下：<br><img src="https://s1.ax1x.com/2018/11/19/FSHZW9.png" alt=""></p><p>然后将其命名为todo.csv，保存到爬虫根目录中。</p><h4 id="1-2-Python3中的CSV模块"><a href="#1-2-Python3中的CSV模块" class="headerlink" title="1.2 Python3中的CSV模块"></a><b>1.2 Python3中的CSV模块</b></h4><p><a href="http://qzmvc1.top/2018/10/28/Python3-%E7%94%A8CSV%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99CSV%E6%96%87%E4%BB%B6/">用CSV模块读写CSV文件</a></p><p>Python中有一个用于处理.csv文件的内置库。只需通过 <em>import csv</em> 导入模块，然后就可以使用如下这些直截了当的代码，以字典的形式读取文件中的所有行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;name.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    reader = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(line[<span class="string">&#x27;id&#x27;</span>],line[<span class="string">&#x27;class&#x27;</span>])</span><br></pre></td></tr></table></figure><p><b>文件中的第一行会被自动作为标题行处理</b>，并且会根据它们得出字典中键的名称。在接下来的每一行中，会得到一个包含行内数据的字典。我们可以使用for循环迭代每一行。</p><h4 id="1-3-编辑爬虫"><a href="#1-3-编辑爬虫" class="headerlink" title="1.3 编辑爬虫"></a><b>1.3 编辑爬虫</b></h4><p>我们开始编辑爬虫。通过 <em>scrapy genspider fromcsv</em> 创建爬虫文件。我们将会用到.csv文件中的url，并且我们不希望受到域名的任何限制。因此，首先要做的事情就是移除start_urls以及allowed_domains，然后读取.csv文件。</p><p>由于我们事先并不知道想要起始的url，而是从文件中读取得到的，因此需要实现一个start_requests()方法。对于每一行，创建Request，然后对其进行yield操作。此外，还会再request.meta中存储来自csv文件的字段名称和XPath表达式，一边在parse()函数中使用它们。然后，使用Item和ItemLoader填充Item字段。代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.item <span class="keyword">import</span> Item,Field</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FromcsvSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;fromcsv&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        path = <span class="string">&#x27;C:\QzmVc1\Code\PyCharm\Python_Project\Python_Spider\Spider_Test1\CSV\\todo.csv&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            reader = csv.DictReader(fp)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">                <span class="keyword">yield</span> Request(line.pop(<span class="string">&#x27;锘縰rl&#x27;</span>),meta=&#123;<span class="string">&#x27;fields&#x27;</span>:line&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = Item()</span><br><span class="line">        l = ItemLoader(item=item,response=response)</span><br><span class="line">        <span class="keyword">for</span> i,xpath <span class="keyword">in</span> response.meta[<span class="string">&#x27;fields&#x27;</span>].items():</span><br><span class="line">            <span class="keyword">if</span> xpath:</span><br><span class="line">                item.fields[i]=Field()</span><br><span class="line">                l.add_xpath(i,xpath)</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">44</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">44</span> [scrapy.extensions.logstats] INFO: Crawled <span class="number">0</span> pages (at <span class="number">0</span> pages/<span class="built_in">min</span>), scraped <span class="number">0</span> items (at <span class="number">0</span> items/<span class="built_in">min</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">44</span> [scrapy.extensions.telnet] DEBUG: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">44</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">404</span>) &lt;GET https://jcoffeezph.top/robots.txt&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">45</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/<span class="number">14</span>/JSP%E8%AE%BF%E9%<span class="number">97</span>%AEmysql%E6%<span class="number">95</span>%B0%E6%8D%AE%E5%BA%<span class="number">93</span>/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">45</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/<span class="number">14</span>/JSP%E8%AE%BF%E9%<span class="number">97</span>%AEmysql%E6%<span class="number">95</span>%B0%E6%8D%AE%E5%BA%<span class="number">93</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-14&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;\n      JSP访问mysql数据库\n    &#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/05/jsp%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%<span class="number">95</span>%E5%8F%8A%E5%<span class="number">86</span>%<span class="number">85</span>%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BB%8B%E7%BB%8D/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/05/jsp%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%<span class="number">95</span>%E5%8F%8A%E5%<span class="number">86</span>%<span class="number">85</span>%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BB%8B%E7%BB%8D/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-05&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/07/%E6%<span class="number">95</span>%A3%E5%<span class="number">88</span>%<span class="number">97</span>%E8%A1%A8%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/07/%E6%<span class="number">95</span>%A3%E5%<span class="number">88</span>%<span class="number">97</span>%E8%A1%A8%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-07&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.engine] INFO: Closing spider (finished)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.statscollectors] INFO: Dumping Scrapy stats:</span><br><span class="line">&#123;<span class="string">&#x27;downloader/request_bytes&#x27;</span>: <span class="number">1125</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/request_count&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/request_method_count/GET&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_bytes&#x27;</span>: <span class="number">156880</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_count&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_status_count/200&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_status_count/404&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;finished&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;finish_time&#x27;</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">46</span>, <span class="number">842400</span>),</span><br><span class="line"> <span class="string">&#x27;item_scraped_count&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;log_count/DEBUG&#x27;</span>: <span class="number">8</span>,</span><br><span class="line"> <span class="string">&#x27;log_count/INFO&#x27;</span>: <span class="number">7</span>,</span><br><span class="line"> <span class="string">&#x27;response_received_count&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/dequeued&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/dequeued/memory&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/enqueued&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/enqueued/memory&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;start_time&#x27;</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">44</span>, <span class="number">97251</span>)&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">46</span> [scrapy.core.engine] INFO: Spider closed (finished)</span><br></pre></td></tr></table></figure><br><b>代码解释：</b></p><p>在代码中，你可能已经注意到了几个事情，由于我们没有为该项目定义系统范围的Item，因此必须像如下代码这样手动为ItemLoader提供：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.item <span class="keyword">import</span> Item,Field</span><br><span class="line">item = Item()</span><br><span class="line">l = ItemLoader(item=item,response=response)</span><br></pre></td></tr></table></figure><p>此外，我们还使用了Item的成员变量fields动态添加字段，这也是为什么我们没有导入CsvItem(items.py)而使用scrapy.item中的Item。为了能够动态添加新字段，并通过ItemLoader对其进行填充，需要实现的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处的 name 是一个字符串变量</span></span><br><span class="line">item.fields[name] = Field()</span><br><span class="line">l.add_xpath(name, xpath)</span><br></pre></td></tr></table></figure><p><b>代码说明：</b></p><ol><li>reader是一个可迭代对象。</li><li>line.pop(‘锘縰rl’) 乱码问题目前为止我还找不到方法，留坑…</li><li>关于Request中的参数meta：meta是一个字典，<b>主要是用解析函数之间传递值</b>，常见的情况是：在parse1中给item某些字段提取了值，但是另外一些值需要在parse2中提取，这时候需要将parse1中的item传到parse2方法中处理，显然无法直接给parse2设置额外参数。 <b>Request对象接受一个meta参数，一个字典对象，同时response对象有一个meta属性可以获取到相应Request传过来的meta。</b></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架之细数到目前为止我遇到的坑</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BB%86%E6%95%B0%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BB%86%E6%95%B0%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
      
        <content type="html"><![CDATA[<p><b>本篇博客会在我学习Scrapy的途中不断更新，记录大大小小的我遇到的坑。直接正题。</b></p><hr><p><b>问1：Python3.7版本使用Scrapy Shell遇到invalid syntax</b><br>答1：如果出现SyntaxError:invalid syntax,在“ from twisted.conch import        manhole ”而且提示符 ‘^’ 指向async，那么很有可能是因为你的版本是Python3.7，这个版本把async变成了关键字，这个时候就需要自己动手去找到并打开 <em>manhole.py</em> (在错误信息里面找)这个文件，然后找到(CTRL+F)所有 “async” 关键字并修改成关键字无关的标识符如“async_” 。</p><p><b>问2：Scrapy爬虫提示 list index out of range</b><br>答2：extract()返回信息列表，extract()[0]显示 <strong><em>index out of range</em></strong> 错误信息，将extract()[0]换成extract_first()即可。<br><span id="more"></span><br><b>问3：Scrapy爬取URL在cmd中显示url编码</b><br>答3：cmd默认使用的gbk编码，在项目的py文件中使用urllib.parse.unquote()函数将url编码转化为gbk编码。该函数的输出是对应中文在gbk下的编码。</p><hr><p>这里插着写一下windows控制台cmd乱码的解决方法（与本篇博客无关）</p><p>有时在cmd中输出的中文乱码，解决办法如下：</p><p>在cmd中输入 <b>CHCP 65001<br>CHCP是一个计算机指令，能够显示或设置活动代码页编号。</b>　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>代码页</th><th>描述</th></tr></thead><tbody><tr><td>65001</td><td>UTF-8</td></tr><tr><td>950</td><td>繁体中文</td></tr><tr><td>936</td><td>中国 - 简体中文(GB2312)</td></tr><tr><td>437</td><td>MS-DOS 美国英语</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><hr><p><b>问4：DEBUG: Filtered offsite request to…</b><br>答4：输出crawl命令后显示 <strong>[scrapy.spidermiddlewares.offsite] DEBUG: Filtered offsite request to ‘<a href="http://jcoffeezph.top">http://jcoffeezph.top</a>‘</strong>，原来是二次解析的域名被过滤掉了。解决办法yield scrapy.Request(url=detail_url, meta={‘item’: item}, callback=self.parse_info, <b>dont_filter=True</b>)，原理是忽略allowed_domains的过滤。如果需要多次提交表单，且url一样，那么就必须加此参数dont_filter，防止被当成重复网页过滤掉。</p><p>这篇链接对于此问题的解释也很清楚：<a href="https://www.jianshu.com/p/c31e53fd45f6">https://www.jianshu.com/p/c31e53fd45f6</a></p><p><b>问5：Scrapy 爬取顺序每次都不一样</b><br>答5：异步处理请求，也就是说Scrapy发送请求之后，不会等待这个请求的响应（也就是不会阻塞），而是可以同时发送其他请求或者做别的事情。而我们知道服务器对于请求的响应是由很多方面的因素影响的，如网络速度、解析速度、资源抢占等等，其响应的顺序是难以预测的。</p><p>Scrapy异步的根源，在于它依赖于Twisted框架。Twisted框架是一个Python的event-driven的框架，这里你可以理解为是异步I/O的。</p><p><b>问6：数组的索引值是从0开始的，Xpath的元素值是从几开始的</b><br>答6：1</p><p><b>问7：<strong>json.dumps的参数ensure_ascii=False：</strong>  </b><br>答7：在使用json.dumps时要注意一个问题</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> json.dumps(<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line"></span><br><span class="line">输出：<span class="string">&quot;\u4e2d\u56fd&quot;</span></span><br><span class="line">输出的会是</span><br><span class="line"><span class="string">&#x27;中国&#x27;</span> 中的<span class="built_in">ascii</span> 字符码，而不是真正的中文。</span><br></pre></td></tr></table></figure><p>因为json.dumps 序列化时对中文默认使用的ascii编码.想输出真正的中文需要指定ensure_ascii=False;</p></blockquote><p><strong>问8：中文保存到json文件中产生乱码</strong><br>答8：通过str.encode转换为’UTF-8’编码，因为str.encode返回值是一个bytes对象，因此打开文件的方式要写成 ‘wb’ 。<br>也可以通过在settings.py中添加如下代码：</p><blockquote><p>FEED_EXPORT_ENCODING = ‘UTF-8’</p></blockquote><p><strong>问9：Scrapy爬取图片报错：raise ValueError(‘Missing scheme in request url: %s’ % self._url)</strong><br>答9：items.py定义的image_urls属性需要在spider.py中爬取时赋值为列表，以便在下载管道中进行迭代下载。</p><p><strong>问10：Scrapy爬取图片报错：’NoneType’ object is not subscriptable</strong><br>答10：可能是管道下载获取图片URL时碰到了一些无法获取到的图片，例如本地图片等等…</p><p><strong>问11：爬取豆瓣时scrapy crawl spider报错403</strong><br>答11：这是因为豆瓣有反爬机质，需要加上<code>scrapy crawl spider -s USER_AGENT=”Mozilla/5.0”</code></p><p><strong>问12：xpath如何获取当前节点的兄弟标签</strong><br>答12：</p><ul><li>获取第三个a标签的下一个a标签：”/following-sibling::a[1]”</li><li>获取第三个a标签后面的第N个标签：”/following-sibling::*[N]”</li><li>获取第三个a标签的上一个a标签：”/preceding-sibling::a[1]”</li><li>获取第三个a标签的前面的第N个标签：”/preceding-sibling::*[N]”</li><li>获取第三个a标签的父标签：”/..”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(二) 抽取更多的URL</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%8C-%E6%8A%BD%E5%8F%96%E6%9B%B4%E5%A4%9A%E7%9A%84URL.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%BA%8C-%E6%8A%BD%E5%8F%96%E6%9B%B4%E5%A4%9A%E7%9A%84URL.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、爬取更多的URL"><a href="#一、爬取更多的URL" class="headerlink" title="一、爬取更多的URL"></a><b>一、爬取更多的URL</b></h3><p>到目前为止，我们使用的只是设置在爬虫的start_urls属性中的单一URL。而该属性实际为一个列表，我们可以硬编码写入更多的URL，如下所示：</p><blockquote><p>start_urls = [<br>　　　‘<a href="https://jcoffeezph.top/">https://jcoffeezph.top/</a>‘,<br>　　　‘<a href="http://qzmvc1.top/">http://qzmvc1.top/</a>‘,<br>　　　···<br>]</p></blockquote><p>这种写法可能不会让你太激动。不过我们还可以使用文件作为URL的源，写法如下所示:</p><blockquote><p>start_urls = [ i.strip() for i in open(‘xxx.txt’,’r’).readlines()]</p></blockquote><p>这种写法其实也不那么令人激动，但它确实管用。更经常发生的情况是感兴趣的网站中包含一些索引页以及内容页。<br><img src="https://s1.ax1x.com/2018/11/19/FSRO5q.png" alt=""></p><p><img src="https://s1.ax1x.com/2018/11/19/FSRLan.png" alt=""><br>一个典型的索引页会包含许多到博客的链接，以及一个能够让你从一个索引页前往另一个索引页的分页系统。</p><p>因此，一个典型的爬虫会向两个方向移动：</p><ul><li>横向——从一个索引页到另一个索引页；</li><li>纵向——从一个索引页到内容页并抽取Item。</li></ul><p>我们将前者称为<b>水平爬取</b>，因为这种情况下是在同一层级下爬取页面；而将后者成为<b>垂直爬取</b>，因为该方式是从一个更高的层级到一个更低的层级。<br><span id="more"></span><br>实际上，它比听起来更加容易。我们所有需要做的事情就是再增加两个Xpath表达式。对于第一个表达式，右键单击 <b>Next</b> 按钮打开审查元素，可以注意到URL包含在一个链接中，如图所示：<br><img src="https://s1.ax1x.com/2018/11/19/FSWEPx.png" alt=""><br>因此我们只需要使用一个使用的Xpath表达式 <code>//*[@class=&quot;extend next&quot;]//@href</code>就可以运行了。</p><p>对于第二个表达式，右键单击页面中的列表标题打开审查元素，如图所示：<br><img src="https://s1.ax1x.com/2018/11/19/FSWQZd.png" alt=""><br>Xpath表达式： <code>//*[@class=&quot;article-title&quot;]/@href</code><br>可以运行Scrapy Shell观察上述表达式是否有效。</p><hr><h3 id="二、使用爬虫实现双向爬取"><a href="#二、使用爬虫实现双向爬取" class="headerlink" title="二、使用爬虫实现双向爬取"></a><b>二、使用爬虫实现双向爬取</b></h3><p>该做的分析、工作差不多都做完了，下面我们上代码然后慢慢解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose,Join</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        URLS = response.xpath(<span class="string">&#x27;//*[@class=&quot;extend next&quot;]//@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">        <span class="comment">#Request()函数没有给callback赋值，所以默认回调函数就是parse函数</span></span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        content_urls = response.xpath(<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> content_urls:</span><br><span class="line">            <span class="keyword">yield</span> Request(urljoin(response.url,url),callback=self.parse_item,dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(),response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;link&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;name&quot;]/a/@href&#x27;</span>,MapCompose(<span class="keyword">lambda</span> i:urljoin(response.url,i)))</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure><blockquote><h5 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a><b>代码解释：</b></h5><h6 id="程序从start-urls处开始运行，然后用创建好项目就有的parse-默认解析函数对start-urls进行解析，我们在parse-中抓取了横向和纵向的所有URL。对于横向的URL，我们只需要用scrapy-http中的Request对象不断请求就行，而对于内容页，我们需要请求并进行解析。我们在parse-下方定义了一个新的解析函数，并把它命名为parse-item-，然后在Request中用callback属性进行调用，别忘了将dont-filter设置为true，具体原因可以参考我的博客：Scrapy框架之细数到目前为止我遇到的坑-。"><a href="#程序从start-urls处开始运行，然后用创建好项目就有的parse-默认解析函数对start-urls进行解析，我们在parse-中抓取了横向和纵向的所有URL。对于横向的URL，我们只需要用scrapy-http中的Request对象不断请求就行，而对于内容页，我们需要请求并进行解析。我们在parse-下方定义了一个新的解析函数，并把它命名为parse-item-，然后在Request中用callback属性进行调用，别忘了将dont-filter设置为true，具体原因可以参考我的博客：Scrapy框架之细数到目前为止我遇到的坑-。" class="headerlink" title="程序从start_urls处开始运行，然后用创建好项目就有的parse()默认解析函数对start_urls进行解析，我们在parse()中抓取了横向和纵向的所有URL。对于横向的URL，我们只需要用scrapy.http中的Request对象不断请求就行，而对于内容页，我们需要请求并进行解析。我们在parse()下方定义了一个新的解析函数，并把它命名为parse_item()，然后在Request中用callback属性进行调用，别忘了将dont_filter设置为true，具体原因可以参考我的博客：Scrapy框架之细数到目前为止我遇到的坑)。"></a><b>程序从start_urls处开始运行，然后用创建好项目就有的parse()默认解析函数对start_urls进行解析，我们在parse()中抓取了横向和纵向的所有URL。对于横向的URL，我们只需要用scrapy.http中的Request对象不断请求就行，而对于内容页，我们需要请求并进行解析。我们在parse()下方定义了一个新的解析函数，并把它命名为parse_item()，然后在Request中用callback属性进行调用，别忘了将dont_filter设置为true，具体原因可以参考我的博客：<a href="[http://qzmvc1.top/Scrapy%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BB%86%E6%95%B0%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html](http://qzmvc1.top/Scrapy框架之细数到目前为止我遇到的坑.html">Scrapy框架之细数到目前为止我遇到的坑</a>)。</b></h6><blockquote><p>什么是回调函数？</p></blockquote><p>我们绕点远路来回答这个问题。</p></blockquote><p>编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。<br>　　　　　<br>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。<br>　　　<br>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。<br>　　　　　　<br>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。　　　　　　　　　　　　　　　　</p><blockquote><blockquote><p>关于yield：<br>yield与return在某种意义上来说有些相似，都是将返回值提供给调用者。不过，和return不同的是，yield不会退出函数，而是继续执行for循环。</p></blockquote></blockquote><p>输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">57</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">57</span> [scrapy.extensions.logstats] INFO: Crawled <span class="number">0</span> pages (at <span class="number">0</span> pages/<span class="built_in">min</span>), scraped <span class="number">0</span> items (at <span class="number">0</span> items/<span class="built_in">min</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">57</span> [scrapy.extensions.telnet] DEBUG: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">58</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">404</span>) &lt;GET https://jcoffeezph.top/robots.txt&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">59</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">59</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/page/<span class="number">2</span>/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">59</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0Set%E6%8E%A5%E5%8F%A3%E7%9A%84HashSet%E3%<span class="number">80</span>%81TreeSet%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:02:<span class="number">59</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/01/MySQL%E7%9A%<span class="number">84</span>%E5%B8%B8%E7%<span class="number">94</span>%A8%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E6%<span class="number">93</span>%8D%E4%BD%9C/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/02/JDBC%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BD%BF%E7%<span class="number">94</span>%A8/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/01/MySQL%E7%9A%<span class="number">84</span>%E5%B8%B8%E7%<span class="number">94</span>%A8%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E6%<span class="number">93</span>%8D%E4%BD%9C/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-01&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;MySQL的常用简单操作&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0Set%E6%8E%A5%E5%8F%A3%E7%9A%84HashSet%E3%<span class="number">80</span>%81TreeSet%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-29&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;java实现Set接口的HashSet、TreeSet用法简析&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/<span class="number">14</span>/JSP%E8%AE%BF%E9%<span class="number">97</span>%AEmysql%E6%<span class="number">95</span>%B0%E6%8D%AE%E5%BA%<span class="number">93</span>/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-29&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;java实现顺序表&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/02/JDBC%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BD%BF%E7%<span class="number">94</span>%A8/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-02&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;JDBC的简单使用&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/<span class="number">14</span>/JSP%E8%AE%BF%E9%<span class="number">97</span>%AEmysql%E6%<span class="number">95</span>%B0%E6%8D%AE%E5%BA%<span class="number">93</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-14&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;JSP访问mysql数据库&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">26</span>/%E4%BA%8C%E5%8F%<span class="number">89</span>%E6%A0%<span class="number">91</span>%E5%<span class="number">92</span>%8C%E5%<span class="number">93</span>%<span class="number">88</span>%E5%A4%AB%E6%9B%BC%E6%A0%<span class="number">91</span>%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E5%AE%9E%E7%8E%B0/&gt; (referer: https://jcoffeezph.top/page/<span class="number">2</span>/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/07/%E6%<span class="number">95</span>%A3%E5%<span class="number">88</span>%<span class="number">97</span>%E8%A1%A8%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">25</span>/%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E7%<span class="number">90</span>%<span class="number">86</span>%E8%A7%A3synchronized%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>/&gt; (referer: https://jcoffeezph.top/page/<span class="number">2</span>/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">26</span>/%E4%BA%8C%E5%8F%<span class="number">89</span>%E6%A0%<span class="number">91</span>%E5%<span class="number">92</span>%8C%E5%<span class="number">93</span>%<span class="number">88</span>%E5%A4%AB%E6%9B%BC%E6%A0%<span class="number">91</span>%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E5%AE%9E%E7%8E%B0/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-26&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;二叉树和哈夫曼树的简单实现&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/07/%E6%<span class="number">95</span>%A3%E5%<span class="number">88</span>%<span class="number">97</span>%E8%A1%A8%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-07&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;散列表及HashMap简析&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">25</span>/%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E7%<span class="number">90</span>%<span class="number">86</span>%E8%A7%A3synchronized%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-25&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;简单理解synchronized用法&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/05/jsp%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%<span class="number">95</span>%E5%8F%8A%E5%<span class="number">86</span>%<span class="number">85</span>%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BB%8B%E7%BB%8D/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">27</span>/ArrayList%E5%<span class="number">92</span>%8CLinkedList%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:<span class="number">00</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">11</span>/05/jsp%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%<span class="number">95</span>%E5%8F%8A%E5%<span class="number">86</span>%<span class="number">85</span>%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BB%8B%E7%BB%8D/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-05&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;jsp基本语法及内置对象的简单介绍&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">27</span>/ArrayList%E5%<span class="number">92</span>%8CLinkedList%E7%<span class="number">94</span>%A8%E6%B3%<span class="number">95</span>%E7%AE%<span class="number">80</span>%E6%9E%<span class="number">90</span>/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-27&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;ArrayList和LinkedList用法简析&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0%E9%<span class="number">93</span>%BE%E8%A1%A8%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E6%<span class="number">93</span>%8D%E4%BD%9C/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">29</span>/java%E5%AE%9E%E7%8E%B0%E9%<span class="number">93</span>%BE%E8%A1%A8%E7%9A%<span class="number">84</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E6%<span class="number">93</span>%8D%E4%BD%9C/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-29&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;java实现链表的简单操作&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">30</span>/java-IO%E5%AD%<span class="number">97</span>%E7%AC%A6%E6%B5%<span class="number">81</span>%E4%B8%8E%E5%AD%<span class="number">97</span>%E8%8A%<span class="number">82</span>%E6%B5%<span class="number">81</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BD%BF%E7%<span class="number">94</span>%A8%E7%A4%BA%E4%BE%8B/&gt; (referer: https://jcoffeezph.top/)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/<span class="number">2018</span>/<span class="number">10</span>/<span class="number">30</span>/java-IO%E5%AD%<span class="number">97</span>%E7%AC%A6%E6%B5%<span class="number">81</span>%E4%B8%8E%E5%AD%<span class="number">97</span>%E8%8A%<span class="number">82</span>%E6%B5%<span class="number">81</span>%E7%AE%<span class="number">80</span>%E5%8D%<span class="number">95</span>%E4%BD%BF%E7%<span class="number">94</span>%A8%E7%A4%BA%E4%BE%8B/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>], <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-10-30&#x27;</span>], <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;java IO字符流与字节流简单使用示例&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.engine] INFO: Closing spider (finished)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.extensions.feedexport] INFO: Stored json feed (<span class="number">12</span> items) <span class="keyword">in</span>: scrapy.json</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.statscollectors] INFO: Dumping Scrapy stats:</span><br><span class="line">&#123;<span class="string">&#x27;downloader/request_bytes&#x27;</span>: <span class="number">4772</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/request_count&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/request_method_count/GET&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_bytes&#x27;</span>: <span class="number">635577</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_count&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_status_count/200&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;downloader/response_status_count/404&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;finished&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;finish_time&#x27;</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">726464</span>),</span><br><span class="line"> <span class="string">&#x27;item_scraped_count&#x27;</span>: <span class="number">12</span>,</span><br><span class="line"> <span class="string">&#x27;log_count/DEBUG&#x27;</span>: <span class="number">28</span>,</span><br><span class="line"> <span class="string">&#x27;log_count/INFO&#x27;</span>: <span class="number">8</span>,</span><br><span class="line"> <span class="string">&#x27;request_depth_max&#x27;</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="string">&#x27;response_received_count&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/dequeued&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/dequeued/memory&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/enqueued&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;scheduler/enqueued/memory&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;start_time&#x27;</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">810300</span>)&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">11</span>:03:01 [scrapy.core.engine] INFO: Spider closed (finished)</span><br></pre></td></tr></table></figure><p>当内容页过多时，我们可以输入如下命令限制爬取数量：</p><blockquote><p>scrapy crawl demo -s CLOSESPIDER_ITEMCOUNT=20</p><hr><h3 id="二、使用CrawlSpider实现双向爬取"><a href="#二、使用CrawlSpider实现双向爬取" class="headerlink" title="二、使用CrawlSpider实现双向爬取"></a><b>二、使用CrawlSpider实现双向爬取</b></h3><p>如果感觉上面的双向爬取有些冗长，则说明你确实发现了关键问题。Scrapy尝试简化此类通用情况，以使其编码更加简单。最简单的实现同样结果的方式是使用CrawlSpider，这是一个能够更容易地实现这种爬取的类。为了实现它，我们需要使用genspider命令，并设置 <em>-t crawl</em> 参数，以使用crawl爬虫模板创建一个爬虫。<br>scrapy genspider -t crawl demo web</p></blockquote><p>现在文件包含如下内容：<br><img src="https://s1.ax1x.com/2018/11/19/FSIaUH.png" alt=""></p><p>当阅读这段自动生成的代码时，会发现它和之前的爬虫有些相似，不过在此处类的声明中，会发现爬虫是继承自 <em>CrawlSpider</em> ，而不再是Spider。CrawlSpider提供了一个使用rules变量实现的parse()方法，这与我们之前例子中手工实现的功能一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose,Join</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrawldemoSpider</span>(<span class="params">CrawlSpider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;crawldemo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[@class=&quot;extend next&quot;]&#x27;</span>)),</span><br><span class="line">        Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//*[@class=&quot;article-title&quot;]&#x27;</span>),callback=<span class="string">&#x27;parse_item&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(), response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>, MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>, MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>, MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;link&#x27;</span>, <span class="string">&#x27;//*[@itemprop=&quot;name&quot;]/a/@href&#x27;</span>, MapCompose(<span class="keyword">lambda</span> i: urljoin(response.url, i)))</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure><p>这两条规则使用的是和我们之前手工实现的示例中相同的Xpath表达式，不过这是没有了a 或 href 的限制。顾名思义，LinkExtractor正是专门用于抽取链接的，因此在默认情况下，他们会去查找a (及area) href属性。你可以通过设置它的 tags 和 attrs 参数来进行自定义。需要注意的是，回调函数目前是包含回调方法名称的字符串(比如 ‘parse_item’)，而不是方法引用，如Request(self.parse_item)。最后，除非设置了callback参数，否则Rule将跟踪已经抽取的URL，也就是说他会扫描目标页面以获取额外的链接并跟踪他们。如果设置了callback，Rule将不会跟踪目标页面的链接。如果你希望它跟踪链接，应在callback方法中使用return或yield返回它们，或将Rule()的follow参数设置为True。</p><p>——这里有个坑，爬取博客时，CrawlSpider可能会碰到域名过滤问题，这里又没有Request中的<em>dont_filter</em> 参数，怎么办呢？我们只需要把<em>allowed_domains</em>去掉就好啦~</p><h5 id="CrawlSpider很强大，但此处先不做过多阐述，以后遇到了再慢慢学-我超懒的！"><a href="#CrawlSpider很强大，但此处先不做过多阐述，以后遇到了再慢慢学-我超懒的！" class="headerlink" title="CrawlSpider很强大，但此处先不做过多阐述，以后遇到了再慢慢学~~我超懒的！"></a><b>CrawlSpider很强大，但此处先不做过多阐述，以后遇到了再慢慢学~~我超懒的！</b></h5><hr><h2 id="本章完"><a href="#本章完" class="headerlink" title="本章完"></a><b>本章完</b></h2>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy框架(一) 第一个Scrapy项目</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AAScrapy%E9%A1%B9%E7%9B%AE.html"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6-%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AAScrapy%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><b>前言</b></h3><p>这几天在Scrapy框架里面挣扎了好久，各种碰坑，好在也懵懵懂懂的坚持了下来，话不多说，直接进入正题吧~</p><p><b>本篇博客框架如下：</b></p><ul><li>第一个Scrapy项目</li><li>编写爬虫</li><li>清理—-item装载器与管理字段</li><li>Scrapy Shell<span id="more"></span></li></ul><hr><h3 id="一、第一个Scrapy项目"><a href="#一、第一个Scrapy项目" class="headerlink" title="一、第一个Scrapy项目"></a><b>一、第一个Scrapy项目</b></h3><p><b>1.1 创建爬虫项目</b></p><p>打开cmd窗口，cd到你想存放项目的文件夹下，输入创建命令：</p><blockquote><p>scrapy startproject projectname</p></blockquote><p>其中projectname是爬虫项目名称</p><p>进入爬虫项目后，我们可以看到如下的项目结构:</p><blockquote><p>│  scrapy.cfg<br>  │<br>  └─projectname<br>　　│  items.py<br>　　│  pipelines.py<br>　　│  settings.py<br>　　│  <strong>init</strong>.py<br>　　│<br>　　└─spiders<br>　　　　 <strong>init</strong>.py<br>　　　　 ···</p></blockquote><p><b>1.2 创建爬虫</b></p><p>cd到刚才创建的项目下，输入创建爬虫命令：</p><blockquote><p>scrapy genspider basic web</p></blockquote><p>然后我们可以发现在projectname/spiders目录中增加了一个basic.py文件，这个命令所作的工作就是创建一个名为“basic” 的默认爬虫，并且该爬虫被限制为只能爬取web域名下的URL。</p><h5 id="下面我通过创建一个名为Demo-的项目名以及demo-的默认爬虫进行演示"><a href="#下面我通过创建一个名为Demo-的项目名以及demo-的默认爬虫进行演示" class="headerlink" title="下面我通过创建一个名为Demo 的项目名以及demo 的默认爬虫进行演示"></a><b>下面我通过创建一个名为<em>Demo</em> 的项目名以及<em>demo</em> 的默认爬虫进行演示</b></h5><h5 id="爬虫的演示网址为我一位朋友的博客：https-jcoffeezph-top"><a href="#爬虫的演示网址为我一位朋友的博客：https-jcoffeezph-top" class="headerlink" title="爬虫的演示网址为我一位朋友的博客：https://jcoffeezph.top/"></a><b>爬虫的演示网址为我一位朋友的博客：<a href="https://jcoffeezph.top/">https://jcoffeezph.top/</a></b></h5><hr><h3 id="二、编写爬虫"><a href="#二、编写爬虫" class="headerlink" title="二、编写爬虫"></a><b>二、编写爬虫</b></h3><blockquote><p>scrapy startproject Demo<br>scrapy genspider demo web</p></blockquote><p>创建项目完成后我们打开items.py和demo.py文件，效果如下：<br><img src="https://s1.ax1x.com/2018/11/18/FSNqEQ.png" alt=""><br><img src="https://s1.ax1x.com/2018/11/18/FSNLNj.png" alt=""><br><img src="https://s1.ax1x.com/2018/11/18/FSNHHg.png" alt=""></p><h5 id="之后我们就要大展身手着手开始编写爬虫啦-首先介绍一下items-py这个文件。"><a href="#之后我们就要大展身手着手开始编写爬虫啦-首先介绍一下items-py这个文件。" class="headerlink" title="之后我们就要大展身手着手开始编写爬虫啦~首先介绍一下items.py这个文件。"></a><b>之后我们就要大展身手着手开始编写爬虫啦~首先介绍一下items.py这个文件。</b></h5><h4 id="1-items-py"><a href="#1-items-py" class="headerlink" title="1.items.py"></a><b>1.items.py</b></h4><p>使用items来包装需要爬取的内容。把内容都用items.py来进行管理，便于把抓取的内容传递进pipelines进行后期处理。同时，把内容都放进items.py以后，可以解耦合爬虫文件demo.py，责任更加明晰：爬虫负责去发请求，解析网址；items.py负责管理抓取到的内容。</p><p>在项目目录下有items.py文件。这是存放items的地方，也就是存放抓取内容的地方。我们需要在items.py中告诉Scrapy我们要抓取的内容叫什么名字，也就是需要声明items。</p><p>Item使用简单的class定义语法以及 Field 对象来声明。例如:<br><img src="https://s1.ax1x.com/2018/11/18/FSB6DP.png" alt=""><br><b>表示我们要抓取的内容是：title，time，author以及link。</b></p><p><b>Field对象指明了每个字段的元数据(metadata)</b>，你可以为每个字段指明任何类型的元数据。 Field对象对接受的值没有任何限制。也正是因为这个原因，文档也无法提供所有可用的元数据的键(key)参考列表。 Field对象中保存的每个键可以由多个组件使用，并且只有这些组件知道这个键的存在。你可以根据自己的需求，定义使用其他的Field键。 <b>设置 Field 对象的主要目的就是在一个地方定义好所有的元数据。</b> 一般来说，那些依赖某个字段的组件肯定使用了特定的键(key)。您必须查看组件相关的文档，查看其用了哪些元数据键(metadata key)。</p><p><b>需要注意的是，用来声明item的Field对象并没有被赋值为class的属性。 不过您可以通过Item.fields属性进行访问。</b></p><h4 id="2-demo-py"><a href="#2-demo-py" class="headerlink" title="2.demo.py"></a><b>2.demo.py</b></h4><p><img src="https://s1.ax1x.com/2018/11/18/FSNHHg.png" alt=""><br>接下来我们进入<em>demo.py</em> 文件中。import语句能够让我们使用Scrapy框架中已有的类。下面是扩展自scrapy.Spider的DemoSpider类的定义。通过扩展的方式，尽管我们实际上没有写任何代码，但是该类已经继承了Scrapy框架中Spider类的相当一部分功能。这样，就可以只额外编写少量的代码行，而获得一个完整运行的爬虫了。最后是空函数parse()的定义，该函数包含两个参数self和response对象。通过self的引用，我们就可以使用爬虫中感兴趣的功能了。response对象是网页返回的请求对象。</p><ul><li><p>首先，我们需要引入之前在item.py中编写的DemoItem类。如前所述，它在Demo目录的items.py文件中，也就是Demo.items模块中。我们使用如下命令引入该模块：</p><blockquote><p>from Demo.items import DemoItem</p></blockquote></li><li><p>然后需要进行实例化，并返回一个对象。这非常简单，在parse()方法中，可以通过添加<b> item = DemoItem()</b> 语句创建一个新的item，然后可以按如下方式为其字段分配表达式：</p><blockquote><p>item[‘title’] = response.xpath(‘ ‘).extract()</p></blockquote></li></ul><blockquote><p>有关xpath的具体用法可以参考我之前的一篇博客：<a href="http://qzmvc1.top/2018/11/05/Xpath%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/">Xpath用法总结</a></p></blockquote><ul><li>最后return item返回item，代码如下所示：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#起始爬取的URL列表，程序从这里开始</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"><span class="comment">#parse()对每个URL进行解析</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = DemoItem()</span><br><span class="line">        item[<span class="string">&#x27;title&#x27;</span>] = response.xpath(<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>).extract()</span><br><span class="line">        item[<span class="string">&#x27;author&#x27;</span>] = response.xpath(<span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>).extract()</span><br><span class="line">        item[<span class="string">&#x27;time&#x27;</span>] = response.xpath(<span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>).extract()</span><br><span class="line">        item[<span class="string">&#x27;link&#x27;</span>] = response.xpath(<span class="string">&#x27;//*[@itemprop=&quot;name&quot;]/a/@href&#x27;</span>).extract()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>写完之后保存，我们在cmd下cd进入Demo爬虫项目下，输入爬取命令：</p><blockquote><p>scrapy crawl demo</p></blockquote><p>可以在控制台看到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">47</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">47</span> [scrapy.extensions.logstats] INFO: Crawled <span class="number">0</span> pages (at <span class="number">0</span> pages/<span class="built_in">min</span>), scraped <span class="number">0</span> items (at <span class="number">0</span> items/<span class="built_in">min</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">47</span> [scrapy.extensions.telnet] DEBUG: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">49</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">404</span>) &lt;GET https://jcoffeezph.top/robots.txt&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">53</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">53</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> https://jcoffeezph.top/&gt;</span><br><span class="line">&#123;<span class="string">&#x27;author&#x27;</span>: [<span class="string">&#x27;ForMe&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;link&#x27;</span>: [<span class="string">&#x27;/2018/11/14/JSP访问mysql数据库/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/11/07/散列表简析/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/11/05/jsp基本语法及内置对象的简单介绍/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/11/02/JDBC的简单使用/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/11/01/MySQL的常用简单操作/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/10/30/java-IO字符流与字节流简单使用示例/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/10/29/java实现Set接口的HashSet、TreeSet用法简析/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/10/29/java实现链表的简单操作/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/10/29/java实现顺序表/&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;/2018/10/27/ArrayList和LinkedList用法简析/&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;time&#x27;</span>: [<span class="string">&#x27;2018-11-14&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-11-07&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-11-05&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-11-02&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-11-01&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-10-30&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-10-29&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-10-29&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-10-29&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;2018-10-27&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;title&#x27;</span>: [<span class="string">&#x27;JSP访问mysql数据库&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;散列表及HashMap简析&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;jsp基本语法及内置对象的简单介绍&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;JDBC的简单使用&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;MySQL的常用简单操作&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;java IO字符流与字节流简单使用示例&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;java实现Set接口的HashSet、TreeSet用法简析&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;java实现链表的简单操作&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;java实现顺序表&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;ArrayList和LinkedList用法简析&#x27;</span>]&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">53</span> [scrapy.core.engine] INFO: Closing spider (finished)</span><br></pre></td></tr></table></figure><p>在爬取的同时我们也可以把数据保存到文件中，通过如下命令即可：</p><blockquote><p>scrapy crawl demo -o items.json</p></blockquote><hr><h3 id="三、清理—-item装载器与管理字段"><a href="#三、清理—-item装载器与管理字段" class="headerlink" title="三、清理—-item装载器与管理字段"></a><b>三、清理—-item装载器与管理字段</b></h3><p>首先，我们使用一个强大的工具类——ItemLoader，以代替那些杂乱的extract()和xpath()操作。通过使用该类，我们的parse()方法会按如下进行代码变更：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(),response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;link&#x27;</span>,<span class="string">&#x27;//*[@itemprop=&quot;name&quot;]/a/@href&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure><p>好多了，是不是？不过，这种写法并不只是视觉上更加舒适，它还非常明确地声明了我们意图去做的事情，而不会将其与实现细节混淆起来。这就使得代码具有更好的可维护性以及自描述性。</p><p><b>ItemLoader提供了许多有趣的结合数据及对数据进行格式化和清洗的方式。</b>处理器是一个快速而又简单的函数。处理器的一个例子是<b>Join()</b>。假设你已经使用类似<em>//p</em> 的xpath表达式选取了很多个段落，该处理器可以将这些段落结合成一个条目。另一个非常有意思的处理器是<b>MapCompose()</b>,通过使用该处理器，你可以使用任意Python函数或Python函数链，以实现复杂的功能。比如，MapCompose(float)可以将字符串数据转换为数值，而MapCompose(str.strip, str.title)可以删除多余的空白符，并将字符串格式化为每个单词均为首字母大写的样式。当然，你也可以通过lambda表达式自定义一些函数。</p><p>这里要解决的关键问题是，处理器只是一些简单小巧的功能，用来对我们的Xpath/CSS结果进行后置处理。现在，在爬虫中使用几个这样的处理器，并按照我们想要的方式输出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> Demo.items <span class="keyword">import</span> DemoItem</span><br><span class="line"><span class="keyword">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> MapCompose,Join</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;web&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://jcoffeezph.top/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        l = ItemLoader(item=DemoItem(),response=response)</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;//*[@class=&quot;article-title&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;time&#x27;</span>,<span class="string">&#x27;//*[@itemprop=&quot;datePublished&quot;]/text()&#x27;</span>,MapCompose(<span class="built_in">str</span>.strip))</span><br><span class="line">        l.add_xpath(<span class="string">&#x27;link&#x27;</span>,<span class="string">&#x27;//*[@itemprop=&quot;name&quot;]/a/@href&#x27;</span>,MapCompose(<span class="keyword">lambda</span> i:urljoin(response.url,i)))</span><br><span class="line">        <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure><p>最后，我们可以通过使用<b>add_value()</b>方法，添加Python计算得出的单个值，我们可以用该方法设置“管理字段”，比如URL，爬虫名称，时间戳等。我们还可以直接使用管理字段表中总结出来的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#举例</span></span><br><span class="line">...</span><br><span class="line">l.add_value(<span class="string">&#x27;url&#x27;</span>,response.url)</span><br><span class="line">l.add_value(<span class="string">&#x27;server&#x27;</span>,socket.gethostname())</span><br><span class="line">l.add_value(<span class="string">&#x27;date&#x27;</span>,datetime.datetime.now())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上是ItemLoader及其功能的简要概述，ItemLoader和处理器是基于编写并支持了成千上万个爬虫的人们的抓取需求而开发的工具包，如果你准备开发多个爬虫的话，就非常值得去学习使用它们。</p><hr><h3 id="四、Scrapy-Shell"><a href="#四、Scrapy-Shell" class="headerlink" title="四、Scrapy Shell"></a><b>四、Scrapy Shell</b></h3><p>Scrapy终端是一个交互终端，我们可以在未启动spider的情况下尝试及调试代码，也可以用来测试XPath或CSS表达式，查看他们的工作方式，方便我们爬取的网页中提取的数据。</p><p>如果安装了 IPython ，Scrapy终端将使用 IPython (替代标准Python终端)。 IPython 终端与其他相比更为强大，提供智能的自动补全，高亮输出，及其他特性。（推荐安装IPython）</p><h4 id="4-1-启动Scrapy-Shell"><a href="#4-1-启动Scrapy-Shell" class="headerlink" title="4.1 启动Scrapy Shell"></a><b>4.1 启动Scrapy Shell</b></h4><p>进入cmd，执行下列命令来启动shell:</p><blockquote><p>scrapy shell “<a href="http://jcoffeezph.top">http://jcoffeezph.top</a>“</p></blockquote><p>会在控制台看到如下输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.utils.log] INFO: Scrapy <span class="number">1.5</span><span class="number">.1</span> started (bot: scrapybot)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.utils.log] INFO: Versions: lxml <span class="number">4.2</span><span class="number">.3</span><span class="number">.0</span>, libxml2 <span class="number">2.9</span><span class="number">.7</span>, cssselect <span class="number">1.0</span><span class="number">.3</span>, parsel <span class="number">1.5</span><span class="number">.0</span>, w3lib <span class="number">1.19</span><span class="number">.0</span>, Twisted <span class="number">18.7</span><span class="number">.0</span>, Python <span class="number">3.7</span><span class="number">.0</span> (v3<span class="number">.7</span><span class="number">.0</span>:1bf9cc5093, Jun <span class="number">27</span> <span class="number">2018</span>, 04:<span class="number">59</span>:<span class="number">51</span>) [MSC v<span class="number">.1914</span> <span class="number">64</span> bit (AMD64)], pyOpenSSL <span class="number">18.0</span><span class="number">.0</span> (OpenSSL <span class="number">1.1</span><span class="number">.0</span>h  <span class="number">27</span> Mar <span class="number">2018</span>), cryptography <span class="number">2.3</span>, Platform Windows-<span class="number">10</span>-<span class="number">10.0</span><span class="number">.17134</span>-SP0</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.crawler] INFO: Overridden settings: &#123;<span class="string">&#x27;DUPEFILTER_CLASS&#x27;</span>: <span class="string">&#x27;scrapy.dupefilters.BaseDupeFilter&#x27;</span>, <span class="string">&#x27;LOGSTATS_INTERVAL&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">[<span class="string">&#x27;scrapy.extensions.corestats.CoreStats&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.extensions.telnet.TelnetConsole&#x27;</span>]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">[<span class="string">&#x27;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.retry.RetryMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.downloadermiddlewares.stats.DownloaderStats&#x27;</span>]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">[<span class="string">&#x27;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.spidermiddlewares.referer.RefererMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;scrapy.spidermiddlewares.depth.DepthMiddleware&#x27;</span>]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.extensions.telnet] DEBUG: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">25</span>:<span class="number">59</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">26</span>:<span class="number">00</span> [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (<span class="number">301</span>) to &lt;GET https://jcoffeezph.top/&gt; <span class="keyword">from</span> &lt;GET http://jcoffeezph.top&gt;</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">19</span> 08:<span class="number">26</span>:<span class="number">00</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET https://jcoffeezph.top/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line">[s] Available Scrapy objects:</span><br><span class="line">[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)</span><br><span class="line">[s]   crawler    &lt;scrapy.crawler.Crawler <span class="built_in">object</span> at <span class="number">0x000001A0F9FF4898</span>&gt;</span><br><span class="line">[s]   item       &#123;&#125;</span><br><span class="line">[s]   request    &lt;GET http://jcoffeezph.top&gt;</span><br><span class="line">[s]   response   &lt;<span class="number">200</span> https://jcoffeezph.top/&gt;</span><br><span class="line">[s]   settings   &lt;scrapy.settings.Settings <span class="built_in">object</span> at <span class="number">0x000001A0F9FF4C18</span>&gt;</span><br><span class="line">[s]   spider     &lt;DefaultSpider <span class="string">&#x27;default&#x27;</span> at <span class="number">0x1a0fa284d68</span>&gt;</span><br><span class="line">[s] Useful shortcuts:</span><br><span class="line">[s]   fetch(url[, redirect=<span class="literal">True</span>]) Fetch URL <span class="keyword">and</span> update local objects (by default, redirects are followed)</span><br><span class="line">[s]   fetch(req)                  Fetch a scrapy.Request <span class="keyword">and</span> update local objects</span><br><span class="line">[s]   shelp()           Shell <span class="built_in">help</span> (<span class="built_in">print</span> this <span class="built_in">help</span>)</span><br><span class="line">[s]   view(response)    View response <span class="keyword">in</span> a browser</span><br><span class="line">In [<span class="number">1</span>]:</span><br></pre></td></tr></table></figure><br>Scrapy Shell根据下载的页面会自动创建一些方便使用的对象，例如 Response 对象，以及 Selector 对象 (对HTML及XML内容)。</p><ul><li>当shell载入后，将得到一个包含response数据的本地 response 变量，输入response.body将输出response的包体，输出 response.headers 可以看到response的包头。</li><li>输入 response.selector 时， 将获取到一个response 初始化的类 Selector 的对象，此时可以通过使用response.selector.xpath()或response.selector.css() 来对response 进行查询。</li><li>Scrapy也提供了一些快捷方式, 例如 response.xpath()或response.css()同样可以生效。<br><img src="https://s1.ax1x.com/2018/11/19/FSgJRU.png" alt=""><br><img src="https://s1.ax1x.com/2018/11/19/FSgGGT.png" alt=""></li></ul><h4 id="4-2-Selectors选择器"><a href="#4-2-Selectors选择器" class="headerlink" title="4.2 Selectors选择器"></a><b>4.2 Selectors选择器</b></h4><p><b>Scrapy Selectors 内置 XPath 和 CSS Selector 表达式机制</b></p><p>Selector有四个基本的方法，最常用的还是xpath:</p><ul><li>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表</li><li>extract(): 序列化该节点为Unicode字符串并返回list</li><li>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表，语法同BeautifulSoup4</li><li>re(): 根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表</li></ul><h4 id="4-3-XPath表达式的例子及对应的含义"><a href="#4-3-XPath表达式的例子及对应的含义" class="headerlink" title="4.3 XPath表达式的例子及对应的含义:"></a><b>4.3 XPath表达式的例子及对应的含义:</b></h4><p>我们还是以演示博客 <a href="https://jcoffeezph.top/">https://jcoffeezph.top/</a> 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: response.xpath(<span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>).extract()</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="string">&#x27;ForMe&#x27;</span>]</span><br></pre></td></tr></table></figure><p><b>下面对4.3.1做几点解释：</b></p><ol><li>xpath表达式语法不做过多的说明，具体可以参考我的一篇博客：<a href="[http://qzmvc1.top/Xpath%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html](http://qzmvc1.top/Xpath用法总结.html">Xpath用法总结</a>)</li><li>如果不使用extract()，response.xpath()的返回值是网页内容预加载的Selector对象，为了获取真实值，可以使用extract()，也可以使用re()。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: response.xpath(<span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span>)</span><br><span class="line">Out[<span class="number">5</span>]: [&lt;Selector xpath=<span class="string">&#x27;//*[@id=&quot;header&quot;]/hgroup/h1/a/text()&#x27;</span> data=<span class="string">&#x27;ForMe&#x27;</span>&gt;]</span><br></pre></td></tr></table></figure></li><li>extract()名为提取，返回一个list列表，里面是一些要提取的内容。这里有个坑，在shell中输入extract()[0]访问第一个列表元素没有问题，但在pycharm中却报<code>index out of range</code>这个错，表示很奇怪，现在也不知道具体原因，pycharm中具体解决方法可以参考我的一篇博客：<a href="http://qzmvc1.top/2018/11/19/Scrapy%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BB%86%E6%95%B0%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">Scrapy框架之细数到目前为止我遇到的坑</a></li></ol><h5 id="以后做数据提取的时候，可以先在Scrapy-Shell中测试，测试通过后再应用到代码中。而Scrapy-Shell的主要作用也是用来测试xpath表达式。"><a href="#以后做数据提取的时候，可以先在Scrapy-Shell中测试，测试通过后再应用到代码中。而Scrapy-Shell的主要作用也是用来测试xpath表达式。" class="headerlink" title="以后做数据提取的时候，可以先在Scrapy Shell中测试，测试通过后再应用到代码中。而Scrapy Shell的主要作用也是用来测试xpath表达式。"></a><b>以后做数据提取的时候，可以先在Scrapy Shell中测试，测试通过后再应用到代码中。而Scrapy Shell的主要作用也是用来测试xpath表达式。</b></h5><p>当然Scrapy Shell作用不仅仅如此，但是不属于我们课程重点，不做详细介绍。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用Virtualenv虚拟环境</title>
      <link href="/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Virtualenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83.html"/>
      <url>/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Virtualenv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83.html</url>
      
        <content type="html"><![CDATA[<h4 id="Virtualenv是Python的虚拟环境，可以在同一台PC隔离不同的python开发环境。Virtualenv可以创建一个隔离的Python环境（沙盒）。使用沙盒的优点："><a href="#Virtualenv是Python的虚拟环境，可以在同一台PC隔离不同的python开发环境。Virtualenv可以创建一个隔离的Python环境（沙盒）。使用沙盒的优点：" class="headerlink" title="Virtualenv是Python的虚拟环境，可以在同一台PC隔离不同的python开发环境。Virtualenv可以创建一个隔离的Python环境（沙盒）。使用沙盒的优点："></a><b>Virtualenv是Python的虚拟环境，可以在同一台PC隔离不同的python开发环境。Virtualenv可以创建一个隔离的Python环境（沙盒）。使用沙盒的优点：</b></h4><ul><li>解决库之间的版本依赖，比如同一系统上不同应用依赖同一个库的不同版本。</li><li>解决权限限制，比如你没有root权限。</li><li>尝试新的工具，而不用担心污染系统环境。<span id="more"></span></li></ul><hr><h4 id="下面是一个在Windows下使用Virtualenv的范例和步骤："><a href="#下面是一个在Windows下使用Virtualenv的范例和步骤：" class="headerlink" title="下面是一个在Windows下使用Virtualenv的范例和步骤："></a><b>下面是一个在Windows下使用Virtualenv的范例和步骤：</b></h4><h5 id="1-Python3-安装Virtualenv"><a href="#1-Python3-安装Virtualenv" class="headerlink" title="1. Python3 安装Virtualenv"></a><b>1. Python3 安装Virtualenv</b></h5><blockquote><p> <b>pip install virtualenv</b></p></blockquote><h5 id="2-建立文件夹目录，作为Python的工作环境"><a href="#2-建立文件夹目录，作为Python的工作环境" class="headerlink" title="2. 建立文件夹目录，作为Python的工作环境"></a><b>2. 建立文件夹目录，作为Python的工作环境</b></h5><p>例如我在电脑上新建了一个名为<code>Python_Virtual</code>的目录。</p><h5 id="3-创建虚拟环境"><a href="#3-创建虚拟环境" class="headerlink" title="3. 创建虚拟环境"></a><b>3. 创建虚拟环境</b></h5><p>在cmd控制台中cd到新建的文件夹<code>Python_Virtual</code>，输入命令<code>virtualenv venv</code>，虚拟环境的名字可以是任意的，这里是<code>venv</code>。<br><img src="https://s1.ax1x.com/2018/11/07/i7ETAO.png" alt=""><br>virtualenv venv 将会在当前的目录中创建一个文件夹，包含了Python可执行文件，以及 pip 库的一份拷贝，这样就能安装其它包了。若省略名字将会把文件均放在当前目录。</p><p>　　在任何你运行命令的目录中，这会创建Python的拷贝，并将之放在叫做 venv 的文件中。</p><p>　　你可以选择使用一个Python解释器：</p><blockquote><p><b>virtualenv  -p /usr/bin/python2.7 venv</b>　　　　# -p参数指定Python解释器程序路径</p></blockquote><p>这将会使用 /usr/bin/python2.7 中的Python解释器。</p><h5 id="4-到虚拟环境下工作"><a href="#4-到虚拟环境下工作" class="headerlink" title="4. 到虚拟环境下工作"></a><b>4. 到虚拟环境下工作</b></h5><p>(1) 切换到Scripts路径（激活、关闭虚拟环境的工具在这里）<br><img src="https://s1.ax1x.com/2018/11/07/i7EIHK.png" alt=""></p><hr><p><img src="https://s1.ax1x.com/2018/11/07/i7E7ND.png" alt=""></p><p>(2) 执行activate，激活虚拟环境<br><img src="https://s1.ax1x.com/2018/11/07/i7ZgyR.png" alt=""></p><p>(3) 在虚拟环境下执行python命令</p><p>(4) 用pip为该虚拟环境安装特定版本的依赖库<br><img src="https://s1.ax1x.com/2018/11/07/i7E5B6.png" alt=""><br>(5) 执行deactivate退出虚拟环境<br><img src="https://s1.ax1x.com/2018/11/07/i7eSfg.png" alt=""></p><hr><h4 id="如上所述，激活不同的虚拟环境，就能在虚拟环境中使用不同版本的Python和不同的依赖，且不同虚拟环境之间是互相独立的。"><a href="#如上所述，激活不同的虚拟环境，就能在虚拟环境中使用不同版本的Python和不同的依赖，且不同虚拟环境之间是互相独立的。" class="headerlink" title=" 如上所述，激活不同的虚拟环境，就能在虚拟环境中使用不同版本的Python和不同的依赖，且不同虚拟环境之间是互相独立的。"></a><b> 如上所述，激活不同的虚拟环境，就能在虚拟环境中使用不同版本的Python和不同的依赖，且不同虚拟环境之间是互相独立的。</b></h4>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Virtualenv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新篇 精通Python爬虫框架Scrapy</title>
      <link href="/%E6%96%B0%E7%AF%87-%E7%B2%BE%E9%80%9APython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy.html"/>
      <url>/%E6%96%B0%E7%AF%87-%E7%B2%BE%E9%80%9APython%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://47.93.163.221:8084/uploadimg/Material/978-7-115-47420-9/72jpg/47420_s300.jpg" alt=""></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><b>前言</b></h3><p>很早之前学习了《Python网络数据采集》这本爬虫入门书籍，书上基本用的是Python标准库urllib和第三方库BeautifulSoup，还有一些少量的requests库。过了这么长时间，对爬虫也不是很熟悉了。想了想以后可能会从事大数据方面的工作，本人对数据也是hin感兴趣。于是想腾出时间学习一下Scrapy框架，也趁此机会巩固一下我的爬虫能力。</p><p>这本《精通Python爬虫框架Scrapy》基于Scrapy1.0和Python2.x版本，虽然我学的是Python3.x，但这本书应该不会影响阅读，之后的博客就会基于这本书发布一些我学习Scrapy的进度，理解等等，路还很长，一起加油吧！</p><hr><span id="more"></span><h3 id="什么是Scrapy？"><a href="#什么是Scrapy？" class="headerlink" title="什么是Scrapy？"></a><b>什么是Scrapy？</b></h3><p>   Scrapy 是用 纯Python 实现一个为了爬取网站数据、提取结构性数据而编写的应用框架，用途非常广泛。用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便。</p><p>   Scrapy 使用了 Twisted 异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。</p><h5 id="制作-Scrapy-爬虫-一共需要4步："><a href="#制作-Scrapy-爬虫-一共需要4步：" class="headerlink" title="制作 Scrapy 爬虫 一共需要4步："></a><b>制作 Scrapy 爬虫 一共需要4步：</b></h5><ul><li>新建项目 （scrapy startproject xxx）：新建一个新的爬虫项目</li><li>明确目标 （编写items.py）：明确你想要抓取的目标</li><li>制作爬虫 （spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容 （pipelines.py）：设计管道存储爬取内容</li></ul><h5 id="Scrapy架构图"><a href="#Scrapy架构图" class="headerlink" title="Scrapy架构图:"></a><b>Scrapy架构图:</b></h5><p><img src="https://img-blog.csdn.net/20180704210932936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hsZW5namk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><ul><li><b>Scrapy Engine(引擎):</b>  负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。</li><li><b>Scheduler(调度器): </b>它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。</li><li><b>Downloader(下载器):</b> 负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理，</li><li><b>Spider(爬虫):</b> 它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，</li><li><b>Item Pipeline(管道):</b>  它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.</li><li><b>Downloader Middlewares(下载中间件): </b>你可以当作是一个可以自定义扩展下载功能的组件。</li><li><b>Spider Middlewares(Spider中间件):  </b> 你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）</li></ul><hr><h3 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a><b>安装Scrapy</b></h3><p>Python3.6.4及以上已经支持Scrapy了，因此我们可以直接通过pip安装。</p><blockquote><p>pip install scrapy</p></blockquote><h3 id="升级Scrapy"><a href="#升级Scrapy" class="headerlink" title="升级Scrapy"></a><b>升级Scrapy</b></h3><blockquote><p>pip install —upgrade scrapy</p><hr><p><img src="http://n.sinaimg.cn/sinacn/w640h420/20171227/1baf-fypyuvc8024291.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 Numpy模块详解</title>
      <link href="/Python3-numpy%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.html"/>
      <url>/Python3-numpy%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/a373595475/article/details/79580734">https://blog.csdn.net/a373595475/article/details/79580734</a></p><h3 id="一、Numpy-简介"><a href="#一、Numpy-简介" class="headerlink" title="一、Numpy - 简介"></a><b>一、Numpy - 简介</b></h3><p>Numpy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。</p><p>Numeric，即 NumPy 的前身，是由 Jim Hugunin 开发的。 也开发了另一个包 Numarray ，它拥有一些额外的功能。 2005年，Travis Oliphant 通过将 Numarray 的功能集成到 Numeric 包中来创建 NumPy 包。 这个开源项目有很多贡献者。</p><hr><h3 id="二、Numpy-操作"><a href="#二、Numpy-操作" class="headerlink" title="二、Numpy 操作"></a><b>二、Numpy 操作</b></h3><p>使用Numpy，开发人员可以执行以下操作：</p><ul><li><p>数组的算数和逻辑运算。</p></li><li><p>傅立叶变换和用于图形操作的例程。</p></li><li><p>与线性代数有关的操作。 Numpy 拥有线性代数和随机数生成的内置函数。</p></li></ul><hr><span id="more"></span><h3 id="三、Numpy-–-matlab-的替代之一"><a href="#三、Numpy-–-matlab-的替代之一" class="headerlink" title="三、Numpy – matlab 的替代之一"></a><b>三、Numpy – matlab 的替代之一</b></h3><p>Numpy 通常与 Scipy（Scientific Python）和 Matplotlib（绘图库）一起使用。 这种组合广泛用于替代 Matlab，是一个流行的技术计算平台。 但是，Python 作为 Matlab 的替代方案，现在被视为一种更加现代和完整的编程语言。</p><p>Numpy 是开源的，这是它的一个额外的优势。</p><hr><h3 id="四、Numpy-Ndarray-对象"><a href="#四、Numpy-Ndarray-对象" class="headerlink" title="四、Numpy - Ndarray 对象"></a><b>四、Numpy - Ndarray 对象</b></h3><p>Numpy 中定义的最重要的对象是称为 ndarray 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。</p><p>ndarray中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象（称为 dtype）。</p><p>从ndarray对象提取的任何元素（通过切片）由一个数组标量类型的 Python 对象表示。 下图显示了ndarray，数据类型对象（dtype）和数组标量类型之间的关系。<br><img src="https://www.tutorialspoint.com//numpy/images/ndarray.jpg" alt=""></p><p>基本的ndarray是使用 Numpy 中的数组函数创建的，它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面的构造器接受以下参数：　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>参数及描述</th></tr></thead><tbody><tr><td>1.</td><td>object 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。</td></tr><tr><td>2.</td><td>dtype 数组的所需数据类型，可选。</td></tr><tr><td>3.</td><td>copy 可选，默认为true，对象是否被复制。</td></tr><tr><td>4.</td><td>order C（按行）、F（按列）或A（任意，默认）。</td></tr><tr><td>5.</td><td>subok 默认情况下，返回的数组被强制为基类数组。 如果为true，则返回子类。</td></tr><tr><td>6.</td><td>ndmin 指定返回数组的最小维数。</td></tr></tbody></table></div><p>看看下面的例子来更好地理解:</p><p><b>示例一：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><b>示例二：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多一个维度</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p><b>示例三：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定数组维度ndmin</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],ndmin=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><p><b>示例四：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定存储类型dtype</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],dtype=<span class="built_in">complex</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.</span>+<span class="number">0.j</span> <span class="number">2.</span>+<span class="number">0.j</span> <span class="number">3.</span>+<span class="number">0.j</span> <span class="number">4.</span>+<span class="number">0.j</span> <span class="number">5.</span>+<span class="number">0.j</span>]</span><br></pre></td></tr></table></figure><p><b>ndarray对象由计算机内存中的一维连续区域组成，带有将每个元素映射到内存块中某个位置的索引方案。 内存块以按行（C 风格）或按列（FORTRAN 或 Matlab 风格）的方式保存元素。</b></p><hr><h3 id="五、Numpy-数据类型"><a href="#五、Numpy-数据类型" class="headerlink" title="五、Numpy - 数据类型"></a><b>五、Numpy - 数据类型</b></h3><p>Numpy 支持比 Python 更多种类的数值类型，下表显示了 Numpy 中定义的不同标量数据类型。　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>数据类型及描述</th></tr></thead><tbody><tr><td>1.</td><td>bool— 存储为一个字节的布尔值（真或假）</td></tr><tr><td>2.</td><td>int—默认整数，相当于 C 的long，通常为int32或int64</td></tr><tr><td>3.</td><td>intc 相当于 C 的int，通常为int32或int64</td></tr><tr><td>4.</td><td>intp 用于索引的整数，相当于 C 的size_t，通常为int32或int64</td></tr><tr><td>5.</td><td>int8 字节（-128 ~ 127）</td></tr><tr><td>6.</td><td>int16 16 位整数（-32768 ~ 32767）</td></tr><tr><td>7.</td><td>int32 32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td>8.</td><td>int64 64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td>9.</td><td>uint8 8 位无符号整数（0 ~ 255）</td></tr><tr><td>10.</td><td>uint16 16 位无符号整数（0 ~ 65535）</td></tr><tr><td>11.</td><td>uint32 32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td>12.</td><td>uint64 64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td>13.</td><td>float—float64的简写</td></tr><tr><td>14.</td><td>float16 半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td>15.</td><td>float32 单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td>16.</td><td>float64 双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td>17.</td><td>complex—complex128的简写</td></tr><tr><td>18.</td><td>complex64 复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td>19.</td><td>complex128 复数，由两个 64 位浮点表示（实部和虚部）</td></tr></tbody></table></div><hr><h3 id="六、数据类型对象-dtype"><a href="#六、数据类型对象-dtype" class="headerlink" title="六、数据类型对象 (dtype)"></a><b>六、数据类型对象 (dtype)</b></h3><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li><p>数据类型（整数、浮点或者 Python 对象）</p></li><li><p>数据大小</p></li><li><p>字节序（小端或大端）</p></li><li><p>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</p></li><li><p>如果数据类型是子序列，它的形状和数据类型。</p></li></ul><p>字节顺序取决于数据类型的前缀&lt;或&gt;。 &lt;意味着编码是小端（最小有效字节存储在最小地址中）。 &gt;意味着编码是大端（最大有效字节存储在最小地址中）。</p><p><b>常见用法：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#dtype=int dtype=&quot;int8&quot; dtype=np.int8</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><p>每个内建类型都有一个唯一定义它的字符代码：</p><ul><li><p>‘b’：布尔值</p></li><li><p>‘i’：符号整数</p></li><li><p>‘u’：无符号整数</p></li><li><p>‘f’：浮点</p></li><li><p>‘c’：复数浮点</p></li><li><p>‘m’：时间间隔</p></li><li><p>‘M’：日期时间</p></li><li><p>‘O’：Python 对象</p></li><li><p>‘S’, ‘a’：字节串</p></li><li><p>‘U’：Unicode</p></li><li><p>‘V’：原始数据（void）</p></li></ul><hr><h3 id="七、Numpy-数组属性"><a href="#七、Numpy-数组属性" class="headerlink" title="七、Numpy - 数组属性"></a><b>七、Numpy - 数组属性</b></h3><p>这一章中，我们会讨论 Numpy 的多种数组属性。</p><h4 id="7-1-ndarray-shape"><a href="#7-1-ndarray-shape" class="headerlink" title="7.1 ndarray.shape"></a><b>7.1 ndarray.shape</b></h4><p>这一数组属性返回一个包含数组维度的元组，它也可以用于调整数组大小。<br><b>示例一</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><b>示例二</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.shape = (<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p><b>示例三</b><br>Numpy 也提供了reshape函数来调整数组大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a.reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h4 id="7-2-ndarray-ndim"><a href="#7-2-ndarray-ndim" class="headerlink" title="7.2 ndarray.ndim"></a><b>7.2 ndarray.ndim</b></h4><p>这一数组属性返回数组的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.ndim)</span><br><span class="line"><span class="comment"># 现在调整其大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b.ndim)</span><br><span class="line"><span class="comment"># b现在拥有三个维度</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line">  [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]</span><br><span class="line">  [<span class="number">15</span> <span class="number">16</span> <span class="number">17</span>]</span><br><span class="line">  [<span class="number">18</span> <span class="number">19</span> <span class="number">20</span>]</span><br><span class="line">  [<span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="7-3-numpy-itemsize"><a href="#7-3-numpy-itemsize" class="headerlink" title="7.3 numpy.itemsize"></a><b>7.3 numpy.itemsize</b></h4><p>这一数组属性返回数组中每个元素的字节单位长度。</p><p><b>示例一</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><b>示例二</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=<span class="string">&quot;float&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.itemsize)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><hr><h3 id="八、Numpy-数组创建例程"><a href="#八、Numpy-数组创建例程" class="headerlink" title="八、Numpy - 数组创建例程"></a><b>八、Numpy - 数组创建例程</b></h3><p>新的ndarray对象可以通过任何下列数组创建例程或使用低级ndarray构造函数构造。</p><h4 id="8-1-numpy-empty"><a href="#8-1-numpy-empty" class="headerlink" title="8.1 numpy.empty"></a><b>8.1 numpy.empty</b></h4><p>它创建指定形状和dtype的未初始化数组，它使用以下构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>参数及描述</th></tr></thead><tbody><tr><td>1.</td><td>Shape 空数组的形状，整数或整数元组</td></tr><tr><td>2.</td><td>Dtype 所需的输出数组类型，可选</td></tr><tr><td>3.</td><td>Order ‘C’为按行的 C 风格数组，’F’为按列的 Fortran 风格数组</td></tr></tbody></table></div><p><b>示例</b></p><p>下面的代码展示空数组的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.empty([<span class="number">3</span>,<span class="number">3</span>],dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1869438820</span> <span class="number">1701606756</span>      <span class="number">10354</span>]</span><br><span class="line"> [   <span class="number">3961344</span>   <span class="number">98172928</span> <span class="number">1936682083</span>]</span><br><span class="line"> [<span class="number">1913137509</span>         <span class="number">61</span>      <span class="number">15986</span>]]</span><br></pre></td></tr></table></figure><p><b>注意：数组元素为随机值，因为它们未初始化</b></p><h4 id="8-2-numpy-zeros"><a href="#8-2-numpy-zeros" class="headerlink" title="8.2 numpy.zeros"></a><b>8.2 numpy.zeros</b></h4><p>返回特定大小，以 0 填充的新数组。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 含有 5 个 0 的数组，默认类型为 float</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.zeros(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br></pre></td></tr></table></figure><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.zeros((<span class="number">5</span>,), dtype = np.<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="8-3-numpy-ones"><a href="#8-3-numpy-ones" class="headerlink" title="8.3 numpy.ones"></a><b>8.3 numpy.ones</b></h4><p>返回特定大小，以 1 填充的新数组。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 含有 5 个 1 的数组，默认类型为 float</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.ones(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br></pre></td></tr></table></figure><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.ones((<span class="number">5</span>,), dtype = np.<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="九、Numpy-来自数值范围的数组"><a href="#九、Numpy-来自数值范围的数组" class="headerlink" title="九、Numpy - 来自数值范围的数组"></a><b>九、Numpy - 来自数值范围的数组</b></h3><p>这一章中，我们会学到如何从数值范围创建数组。</p><h4 id="9-1-numpy-arange"><a href="#9-1-numpy-arange" class="headerlink" title="9.1 numpy.arange"></a><b>9.1 numpy.arange</b></h4><p>这个函数返回ndarray对象，包含给定范围内的等间隔值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：　　　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>参数及描述</th></tr></thead><tbody><tr><td>1.</td><td>start 范围的起始值，默认为0</td></tr><tr><td>2.</td><td>stop 范围的终止值（不包含）</td></tr><tr><td>3.</td><td>step 两个值的间隔，默认为1</td></tr><tr><td>4.</td><td>dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table></div><p>下面的例子展示了如何使用该函数：</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">5</span>,dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.</span>  <span class="number">1.</span>  <span class="number">2.</span>  <span class="number">3.</span>  <span class="number">4.</span>]</span><br></pre></td></tr></table></figure><p><b>示例3</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>  <span class="number">12</span>  <span class="number">14</span>  <span class="number">16</span>  <span class="number">18</span>]</span><br></pre></td></tr></table></figure><h4 id="9-2-numpy-linspace"><a href="#9-2-numpy-linspace" class="headerlink" title="9.2 numpy.linspace"></a><b>9.2 numpy.linspace</b></h4><p>此函数类似于arange()函数。 在此函数中，指定了范围之间的均匀间隔数量，而不是步长。 此函数的用法如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num, endpoint, retstep, dtype)</span><br></pre></td></tr></table></figure><p>构造器接受下列参数：　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>参数及描述</th></tr></thead><tbody><tr><td>1.</td><td>start 序列的起始值</td></tr><tr><td>2.</td><td>stop 序列的终止值，如果endpoint为true，该值包含于序列中</td></tr><tr><td>3.</td><td>num 要生成的等间隔样例数量，默认为50</td></tr><tr><td>4.</td><td>endpoint 序列中是否包含stop值，默认为ture</td></tr><tr><td>5.</td><td>retstep 如果为true，返回样例，以及连续数字之间的步长</td></tr><tr><td>6.</td><td>dtype 输出ndarray的数据类型</td></tr></tbody></table></div><p>下面的例子展示了linspace函数的用法:</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10.</span>   <span class="number">12.5</span>   <span class="number">15.</span>   <span class="number">17.5</span>  <span class="number">20.</span>]</span><br></pre></td></tr></table></figure><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 endpoint 设为 false</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.linspace(<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>, endpoint = <span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10.</span>   <span class="number">12.</span>   <span class="number">14.</span>   <span class="number">16.</span>   <span class="number">18.</span>]</span><br></pre></td></tr></table></figure><p><b>示例3</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 retstep 值</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>, retstep =  <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 这里的 retstep 为 0.25</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(array([ <span class="number">1.</span>  ,  <span class="number">1.25</span>,  <span class="number">1.5</span> ,  <span class="number">1.75</span>,  <span class="number">2.</span>  ]), <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="十、Numpy-切片和索引"><a href="#十、Numpy-切片和索引" class="headerlink" title="十、Numpy - 切片和索引"></a><b>十、Numpy - 切片和索引</b></h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，就像 Python 的内置容器对象一样。</p><p>如前所述，ndarray对象中的元素遵循基于零的索引。 有三种可用的索引方法类型：<b> 字段访问</b>，<b>基本切片</b>和<b>高级索引</b>。</p><p>基本切片是 Python 中基本切片概念到 n 维的扩展。 通过将start，stop和step参数提供给内置的slice函数来构造一个 Python slice对象。 此slice对象被传递给数组来提取数组的一部分。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a[s])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>在上面的例子中，ndarray对象由arange()函数创建。 然后，分别用起始，终止和步长值2，7和2定义切片对象。 当这个切片对象传递给ndarray时，会对它的一部分进行切片，从索引2到7，步长为2。</p><p>通过将由冒号分隔的切片参数（start:stop:step）直接提供给ndarray对象，也可以获得相同的结果。</p><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>如果只输入一个参数，则将返回与索引对应的单个项目。 如果使用a:，则从该索引向后的所有项目将被提取。 如果使用两个参数（以:分隔），则对两个索引（不包括停止索引）之间的元素以默认步骤进行切片。</p><p><b>示例3</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对单个元素进行切片</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><b>示例4</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对始于索引的元素进行切片</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><b>示例5</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对索引之间的元素进行切片</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><b>上面的描述也可用于多维ndarray。</b></p><p><b>示例6</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 对始于索引的元素进行切片</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>切片还可以包括省略号（…），来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的ndarray。</p><p><b>示例7</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最开始的数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 这会返回第二列元素的数组：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二列的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在我们从第二行切片所有元素：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二行的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,...])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在我们从第二列向后切片所有元素：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二列及其剩余元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[...,<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">第二列的元素是：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">第二行的元素是：</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">第二列及其剩余元素是：</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><hr><h3 id="十一、Numpy-高级索引"><a href="#十一、Numpy-高级索引" class="headerlink" title="十一、Numpy - 高级索引"></a><b>十一、Numpy - 高级索引</b></h3><p>如果一个ndarray是非元组序列，数据类型为整数或布尔值的ndarray，或者至少一个元素为序列对象的元组，我们就能够用它来索引ndarray。高级索引始终返回数据的副本。 与此相反，切片只提供了一个视图。</p><p>有两种类型的高级索引：整数和布尔值。</p><h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a><b>整数索引</b></h4><p>这种机制有助于基于 N 维索引来获取数组中任意元素。 每个整数数组表示该维度的下标值。 当索引的元素个数就是目标ndarray的维度时，会变得相当直接。</p><p>以下示例获取了ndarray对象中每一行指定列的一个元素。 因此，<b>行索引包含所有行号，列索引指定要选择的元素</b>。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br></pre></td></tr></table></figure><br>该结果包括数组中(0,0)，(1,1)和(2,0)位置处的元素。</p><p>下面的示例获取了 4x3 数组中的每个角处的元素。 行索引是[0,0]和[3,3]，而列索引是[0,2]和[0,2]。</p><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">y = x[rows,cols]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这个数组的每个角处的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">这个数组的每个角处的元素是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><br>返回的结果是包含每个角元素的ndarray对象。</p><p>高级和基本索引可以通过使用切片:或省略号…与索引数组组合。 以下示例使用slice作为列索引和高级索引。 当切片用于两者时，结果是相同的。 但高级索引会导致复制，并且可能有不同的内存布局。</p><p><b>示例3</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">z = x[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;切片之后，我们的数组变为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 对列使用高级索引</span></span><br><span class="line">y = x[<span class="number">1</span>:<span class="number">4</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;对列使用高级索引来切片：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">切片之后，我们的数组变为：</span><br><span class="line">[[ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">对列使用高级索引来切片：</span><br><span class="line">[[ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure></p><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a><b>布尔索引</b></h4><p>当结果对象是布尔运算（例如比较运算符）的结果时，将使用此类型的高级索引。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在我们会打印出大于 5 的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[x &gt; <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">大于 <span class="number">5</span> 的元素是：</span><br><span class="line">[ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br></pre></td></tr></table></figure></p><h3 id="十二、Numpy-广播"><a href="#十二、Numpy-广播" class="headerlink" title="十二、Numpy - 广播"></a><b>十二、Numpy - 广播</b></h3><p>术语<b>广播</b>是指 Numpy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>   <span class="number">40</span>   <span class="number">90</span>   <span class="number">160</span>]</span><br></pre></td></tr></table></figure><br>如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 Numpy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。</p><p>如果满足以下规则，可以进行广播：</p><ul><li><p>ndim较小的数组会在前面追加一个长度为 1 的维度。</p></li><li><p>输出数组的每个维度的大小是输入数组该维度大小的最大值。</p></li><li><p>如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。</p></li><li><p>如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。</p></li></ul><p>如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为<b>可广播的</b>。</p><ul><li><p>数组拥有相同形状。</p></li><li><p>数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。</p></li><li><p>数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。</p></li></ul><p>下面的例称展示了广播的示例。</p><p><b>示例2</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>],[<span class="number">10.0</span>,<span class="number">10.0</span>,<span class="number">10.0</span>],[<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">20.0</span>],[<span class="number">30.0</span>,<span class="number">30.0</span>,<span class="number">30.0</span>]])</span><br><span class="line">b = np.array([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组加第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">10.</span> <span class="number">10.</span> <span class="number">10.</span>]</span><br><span class="line"> [ <span class="number">20.</span> <span class="number">20.</span> <span class="number">20.</span>]</span><br><span class="line"> [ <span class="number">30.</span> <span class="number">30.</span> <span class="number">30.</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[ <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line"></span><br><span class="line">第一个数组加第二个数组：</span><br><span class="line">[[ <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line"> [ <span class="number">11.</span> <span class="number">12.</span> <span class="number">13.</span>]</span><br><span class="line"> [ <span class="number">21.</span> <span class="number">22.</span> <span class="number">23.</span>]</span><br><span class="line"> [ <span class="number">31.</span> <span class="number">32.</span> <span class="number">33.</span>]]</span><br></pre></td></tr></table></figure><br>下面的图片展示了数组b如何通过广播来与数组a兼容。<br><img src="https://www.tutorialspoint.com//numpy/images/array.jpg" alt=""></p><hr><h3 id="十三、Numpy-数组上的迭代"><a href="#十三、Numpy-数组上的迭代" class="headerlink" title="十三、Numpy - 数组上的迭代"></a><b>十三、Numpy - 数组上的迭代</b></h3><p>Numpy 包含一个迭代器对象numpy.nditer。 它是一个有效的多维迭代器对象，可以用于在数组上进行迭代。 数组的每个元素可使用 Python 的标准Iterator接口来访问。</p><p>让我们使用arange()函数创建一个 3x4 数组，并使用nditer对它进行迭代。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><br><b>示例2</b><br>迭代的顺序匹配数组的内容布局，而不考虑特定的排序。 这可以通过迭代上述数组的转置来看到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组的转置是：&#x27;</span>)</span><br><span class="line">b = a.T</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组是：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(b):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span></span><br></pre></td></tr></table></figure></p><h4 id="迭代顺序"><a href="#迭代顺序" class="headerlink" title="迭代顺序"></a><b>迭代顺序</b></h4><p>如果相同元素使用 F 风格顺序存储，则迭代器选择以更有效的方式对数组进行迭代。</p><p><b>示例1</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组的转置是：&#x27;</span>)</span><br><span class="line">b = a.T</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>)</span><br><span class="line">c = b.copy(order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line">c = b.copy(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(c):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span> <span class="number">20</span> <span class="number">40</span> <span class="number">5</span> <span class="number">25</span> <span class="number">45</span> <span class="number">10</span> <span class="number">30</span> <span class="number">50</span> <span class="number">15</span> <span class="number">35</span> <span class="number">55</span></span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">20</span> <span class="number">40</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">25</span> <span class="number">45</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">30</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">15</span> <span class="number">35</span> <span class="number">55</span>]]</span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><br><b>示例2</b></p><p>可以通过显式提醒，来强制nditer对象使用某种顺序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原始数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 C 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a,order = <span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以 F 风格顺序排序：&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a,order = <span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(x,)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line">以 C 风格顺序排序：</span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span></span><br><span class="line"></span><br><span class="line">以 F 风格顺序排序：</span><br><span class="line"><span class="number">0</span> <span class="number">20</span> <span class="number">40</span> <span class="number">5</span> <span class="number">25</span> <span class="number">45</span> <span class="number">10</span> <span class="number">30</span> <span class="number">50</span> <span class="number">15</span> <span class="number">35</span> <span class="number">55</span></span><br></pre></td></tr></table></figure></p><blockquote><p><b>有关C风格和F风格的说明:</b>　　　　　　　　　　 　 　　 　　　　　　</p><ol><li>比如二维数组 a[2][2]，使用 C，其在内存中存储为:</li></ol><p>a[0][0] a[0][1] a[1][0] a[1][1]　　　　　　　　　</p><ol><li>而在 Fortran 里，其顺序为:</li></ol><p>a[0][0] a[1][0] a[0][1] a[1][1]</p></blockquote><hr><h3 id="十四、Numpy-数组操作"><a href="#十四、Numpy-数组操作" class="headerlink" title="十四、Numpy - 数组操作"></a><b>十四、Numpy - 数组操作</b></h3><h4 id="翻转操作"><a href="#翻转操作" class="headerlink" title="翻转操作"></a><b>翻转操作</b></h4><div class="table-container"><table><thead><tr><th>序号</th><th>操作及描述</th></tr></thead><tbody><tr><td>1.</td><td>transpose 翻转数组的维度</td></tr><tr><td>2.</td><td>ndarray.T 和self.transpose()相同</td></tr><tr><td>3.</td><td>rollaxis 向后滚动指定的轴</td></tr><tr><td>4.</td><td>swapaxes 互换数组的两个轴</td></tr></tbody></table></div><blockquote><p>这里先介绍一下转置，其他的等碰到相关需求再说= =，<del>因为我看不懂</del></p></blockquote><p><b>numpy.ndarray.T</b></p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.T)</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原数组：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">转置数组：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">1</span> <span class="number">5</span> <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">3</span> <span class="number">7</span> <span class="number">11</span>]]</span><br></pre></td></tr></table></figure><h4 id="数组的连接"><a href="#数组的连接" class="headerlink" title="数组的连接"></a><b>数组的连接</b></h4><div class="table-container"><table><thead><tr><th>序号</th><th>数组及描述</th></tr></thead><tbody><tr><td>1.</td><td>concatenate 沿着现存的轴连接数据序列</td></tr><tr><td>2.</td><td>stack 沿着新轴连接数组序列</td></tr><tr><td>3.</td><td>hstack 水平堆叠序列中的数组（列方向）</td></tr><tr><td>4.</td><td>vstack 竖直堆叠序列中的数组（行方向）</td></tr></tbody></table></div><blockquote><p>这里先介绍一下concatenate，其他的等碰到相关需求再说= =，<del>因为我还是看不懂</del></p></blockquote><h4 id="1-numpy-concatenate"><a href="#1-numpy-concatenate" class="headerlink" title="1. numpy.concatenate"></a><b>1. numpy.concatenate</b></h4><p>数组的连接是指连接。 此函数用于沿指定轴连接相同形状的两个或多个数组。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>a1, a2, …：相同类型的数组序列</li><li>axis：沿着它连接数组的轴，默认为 0</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 两个数组的维度相同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 连接两个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a,b)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 连接两个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a,b),axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 连接两个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 连接两个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><blockquote><p><b>有关数组维度axis的具体说明可以参考<a href="https://blog.csdn.net/fangjian1204/article/details/53055219">https://blog.csdn.net/fangjian1204/article/details/53055219</a></b></p></blockquote><h4 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a><b>数组分割</b></h4><div class="table-container"><table><thead><tr><th>序号</th><th>数组及描述</th></tr></thead><tbody><tr><td>1.</td><td>split 将一个数组分割为多个子数组</td></tr><tr><td>2.</td><td>hsplit 将一个数组水平分割为多个子数组（按列）</td></tr><tr><td>3.</td><td>vsplit 将一个数组竖直分割为多个子数组（按行）</td></tr></tbody></table></div><blockquote><p>这里先介绍一下split，其他的等碰到相关需求再说= =，<del>因为我还是看不懂</del></p></blockquote><h4 id="1-numpy-split"><a href="#1-numpy-split" class="headerlink" title="1. numpy.split"></a><b>1. numpy.split</b></h4><p>该函数沿特定的轴将数组分割为子数组。函数接受三个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>ary：被分割的输入数组</li><li>indices_or_sections：可以是整数，表明要从输入数组创建的，等大小的子数组的数量。 如果此参数是一维数组，则其元素表明要创建新子数组的点。</li><li>axis：默认为 0<blockquote><p><b>有关数组维度axis的具体说明可以参考<a href="https://blog.csdn.net/fangjian1204/article/details/53055219">https://blog.csdn.net/fangjian1204/article/details/53055219</a></b></p></blockquote></li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将数组分为三个大小相等的子数组：&#x27;</span>)</span><br><span class="line">b = np.split(a,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;将数组在一维数组中表明的位置分割：&#x27;</span>)</span><br><span class="line">b = np.split(a,[<span class="number">4</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">将数组分为三个大小相等的子数组：</span><br><span class="line">[array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]), array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])]</span><br><span class="line"></span><br><span class="line">将数组在一维数组中表明的位置分割：</span><br><span class="line">[array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]), array([<span class="number">7</span>, <span class="number">8</span>])]</span><br></pre></td></tr></table></figure><h4 id="添加-删除元素"><a href="#添加-删除元素" class="headerlink" title="添加/删除元素"></a><b>添加/删除元素</b></h4><div class="table-container"><table><thead><tr><th>序号</th><th>元素及描述</th></tr></thead><tbody><tr><td>1.</td><td>resize 返回指定形状的新数组</td></tr><tr><td>2.</td><td>append 将值添加到数组末尾</td></tr><tr><td>3.</td><td>insert 沿指定轴将值插入到指定下标之前</td></tr><tr><td>4.</td><td>delete 返回删掉某个轴的子数组的新数组</td></tr><tr><td>5.</td><td>unique 寻找数组内的唯一元素</td></tr></tbody></table></div><h4 id="1-numpy-resize"><a href="#1-numpy-resize" class="headerlink" title="1. numpy.resize"></a><b>1. numpy.resize</b></h4><p><b>此函数返回指定大小的新数组。 如果新大小大于原始大小，则包含原始数组中的元素的重复副本</b>。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>arr：要修改大小的输入数组</li><li>shape：返回数组的新形状</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">b = np.resize(a,(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 要注意 a 的第一行在 b 中重复出现，因为尺寸变大了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改第二个数组的大小：&#x27;</span>)</span><br><span class="line">b = np.resize(a,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">第一个数组的形状：</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组的形状：</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">修改第二个数组的大小：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h4 id="2-numpy-append"><a href="#2-numpy-append" class="headerlink" title="2. numpy.append"></a><b>2. numpy.append</b></h4><p><b>此函数在输入数组的末尾添加值。 附加操作不是原地的，而是分配新的数组。 此外，输入数组的维度必须匹配否则将生成ValueError。</b></p><p>函数接受下列函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>arr：输入数组</li><li>values：要向arr添加的值，比如和arr形状相同（除了要添加的轴）</li><li>axis：沿着它完成操作的轴。如果没有提供，两个参数都会被展开。</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;向数组添加元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(a, [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 添加元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(a, [[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 添加元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.append(a,[[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">向数组添加元素：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 添加元素：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 添加元素：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><h4 id="3-numpy-insert"><a href="#3-numpy-insert" class="headerlink" title="3. numpy.insert"></a><b>3. numpy.insert</b></h4><p><b>此函数在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</b></p><p>insert()函数接受以下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>arr：输入数组</li><li>obj：在其之前插入值的索引</li><li>values：要插入的值</li><li>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;未传递 Axis 参数。 在插入之前输入数组会被展开。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(a,<span class="number">3</span>,[<span class="number">11</span>,<span class="number">12</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;传递了 Axis 参数。 会广播值数组来配输入数组。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 广播：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(a,<span class="number">1</span>,[<span class="number">11</span>],axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 广播：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.insert(a,<span class="number">1</span>,<span class="number">11</span>,axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">12</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">传递了 Axis 参数。 会广播值数组来配输入数组。</span><br><span class="line">沿轴 <span class="number">0</span> 广播：</span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">11</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 广播：</span><br><span class="line">[[ <span class="number">1</span> <span class="number">11</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span> <span class="number">11</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span> <span class="number">11</span>  <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h4 id="4-numpy-delete"><a href="#4-numpy-delete" class="headerlink" title="4. numpy.delete"></a><b>4. numpy.delete</b></h4><p><b>此函数返回从输入数组中删除指定子数组的新数组。 与insert()函数的情况一样，如果未提供轴参数，则输入数组将展开。 该函数接受以下参数：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Numpy.delete(arr, obj, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>arr：输入数组</li><li>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li><li>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;未传递 Axis 参数。 在插入之前输入数组会被展开。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.delete(a,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;删除第二列：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.delete(a,<span class="number">1</span>,axis = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;包含从数组中删除的替代值的切片：&#x27;</span>)</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(np.delete(a, np.s_[::<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">未传递 Axis 参数。 在插入之前输入数组会被展开。</span><br><span class="line">[ <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">删除第二列：</span><br><span class="line">[[ <span class="number">0</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">包含从数组中删除的替代值的切片：</span><br><span class="line">[ <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h4 id="5-numpy-unique"><a href="#5-numpy-unique" class="headerlink" title="5. numpy.unique"></a><b>5. numpy.unique</b></h4><p><b>此函数返回输入数组中的去重元素数组。 该函数能够返回一个元组，包含去重数组和相关索引的数组。 索引的性质取决于函数调用中返回参数的类型。</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>arr：输入数组，如果不是一维数组则会展开</li><li>return_index：如果为true，返回输入数组中的元素下标</li><li>return_inverse：如果为true，返回去重数组的下标，它可以用于重构输入数组</li><li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组的去重值：&#x27;</span>)</span><br><span class="line">u = np.unique(a)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重数组的索引数组：&#x27;</span>)</span><br><span class="line">u,indices = np.unique(a, return_index = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们可以看到每个和原数组下标对应的数值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重数组的下标：&#x27;</span>)</span><br><span class="line">u,indices = np.unique(a,return_inverse = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;下标为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用下标重构原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(u[indices])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;返回去重元素的重复数量：&#x27;</span>)</span><br><span class="line">u,indices = np.unique(a,return_counts = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(indices)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[<span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一个数组的去重值：</span><br><span class="line">[<span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">去重数组的索引数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">7</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们可以看到每个和原数组下标对应的数值：</span><br><span class="line">[<span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">去重数组的下标：</span><br><span class="line">[<span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下标为：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用下标重构原数组：</span><br><span class="line">[<span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回去重元素的重复数量：</span><br><span class="line">[<span class="number">2</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="十五、Numpy-字符串函数"><a href="#十五、Numpy-字符串函数" class="headerlink" title="十五、Numpy - 字符串函数"></a><b>十五、Numpy - 字符串函数</b></h3><h3 id="待补充…"><a href="#待补充…" class="headerlink" title="待补充…"></a><b>待补充…</b></h3><hr><h3 id="十六、Numpy-算数函数"><a href="#十六、Numpy-算数函数" class="headerlink" title="十六、Numpy - 算数函数"></a><b>十六、Numpy - 算数函数</b></h3><p>很容易理解的是，Numpy 包含大量的各种数学运算功能。 Numpy 提供标准的三角函数，算术运算的函数，复数处理函数等。</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a><b>三角函数</b></h3><p>Numpy 拥有标准的三角函数，它为弧度制单位的给定角度返回三角函数比值。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;不同角度的正弦值：&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过乘 pi/180 转化为弧度</span></span><br><span class="line"><span class="built_in">print</span>(np.sin(a*np.pi/<span class="number">180</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组中角度的余弦值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.cos(a*np.pi/<span class="number">180</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组中角度的正切值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.tan(a*np.pi/<span class="number">180</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">不同角度的正弦值：</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.5</span>         <span class="number">0.70710678</span>  <span class="number">0.8660254</span>   <span class="number">1.</span>        ]</span><br><span class="line"></span><br><span class="line">数组中角度的余弦值：</span><br><span class="line">[  <span class="number">1.00000000e+00</span>   <span class="number">8.66025404e-01</span>   <span class="number">7.07106781e-01</span>   <span class="number">5.00000000e-01</span></span><br><span class="line">   <span class="number">6.12323400e-17</span>]</span><br><span class="line"></span><br><span class="line">数组中角度的正切值：</span><br><span class="line">[  <span class="number">0.00000000e+00</span>   <span class="number">5.77350269e-01</span>   <span class="number">1.00000000e+00</span>   <span class="number">1.73205081e+00</span></span><br><span class="line">   <span class="number">1.63312394e+16</span>]</span><br></pre></td></tr></table></figure><p><b>arcsin，arccos，和arctan函数返回给定角度的sin，cos和tan的反三角函数。 这些函数的结果可以通过numpy.degrees()函数通过将弧度制转换为角度制来验证。</b></p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arccos 和 arctan 函数行为类似：&#x27;</span>)</span><br><span class="line">cos = np.cos(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(cos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反余弦：&#x27;</span>)</span><br><span class="line">inv = np.arccos(cos)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tan 函数：&#x27;</span>)</span><br><span class="line">tan = np.tan(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(tan)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反正切：&#x27;</span>)</span><br><span class="line">inv = np.arctan(tan)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">含有正弦值的数组：</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.5</span>         <span class="number">0.70710678</span>  <span class="number">0.8660254</span>   <span class="number">1.</span>        ]</span><br><span class="line"></span><br><span class="line">计算角度的反正弦，返回值以弧度制为单位：</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.52359878</span>  <span class="number">0.78539816</span>  <span class="number">1.04719755</span>  <span class="number">1.57079633</span>]</span><br><span class="line"></span><br><span class="line">通过转化为角度制来检查结果：</span><br><span class="line">[  <span class="number">0.</span>  <span class="number">30.</span>  <span class="number">45.</span>  <span class="number">60.</span>  <span class="number">90.</span>]</span><br><span class="line"></span><br><span class="line">arccos 和 arctan 函数行为类似：</span><br><span class="line">[  <span class="number">1.00000000e+00</span>   <span class="number">8.66025404e-01</span>   <span class="number">7.07106781e-01</span>   <span class="number">5.00000000e-01</span></span><br><span class="line">   <span class="number">6.12323400e-17</span>]</span><br><span class="line"></span><br><span class="line">反余弦：</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.52359878</span>  <span class="number">0.78539816</span>  <span class="number">1.04719755</span>  <span class="number">1.57079633</span>]</span><br><span class="line"></span><br><span class="line">角度制单位：</span><br><span class="line">[  <span class="number">0.</span>  <span class="number">30.</span>  <span class="number">45.</span>  <span class="number">60.</span>  <span class="number">90.</span>]</span><br><span class="line"></span><br><span class="line">tan 函数：</span><br><span class="line">[  <span class="number">0.00000000e+00</span>   <span class="number">5.77350269e-01</span>   <span class="number">1.00000000e+00</span>   <span class="number">1.73205081e+00</span></span><br><span class="line">   <span class="number">1.63312394e+16</span>]</span><br><span class="line"></span><br><span class="line">反正切：</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.52359878</span>  <span class="number">0.78539816</span>  <span class="number">1.04719755</span>  <span class="number">1.57079633</span>]</span><br><span class="line"></span><br><span class="line">角度制单位：</span><br><span class="line">[  <span class="number">0.</span>  <span class="number">30.</span>  <span class="number">45.</span>  <span class="number">60.</span>  <span class="number">90.</span>]</span><br></pre></td></tr></table></figure><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a><b>舍入函数</b></h3><h4 id="1-numpy-around"><a href="#1-numpy-around" class="headerlink" title="1. numpy.around()"></a><b>1. numpy.around()</b></h4><p>这个函数返回四舍五入到所需精度的值。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.around(a,decimals)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>a 输入数组</li><li>decimals 要舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,  <span class="number">123</span>,  <span class="number">0.567</span>,  <span class="number">25.532</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.around(a))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals =  <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(np.around(a, decimals =  -<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原数组：</span><br><span class="line">[   <span class="number">1.</span>       <span class="number">5.55</span>   <span class="number">123.</span>       <span class="number">0.567</span>   <span class="number">25.532</span>]</span><br><span class="line"></span><br><span class="line">舍入后：</span><br><span class="line">[   <span class="number">1.</span>    <span class="number">6.</span>   <span class="number">123.</span>    <span class="number">1.</span>   <span class="number">26.</span> ]</span><br><span class="line">[   <span class="number">1.</span>    <span class="number">5.6</span>  <span class="number">123.</span>    <span class="number">0.6</span>  <span class="number">25.5</span>]</span><br><span class="line">[   <span class="number">0.</span>    <span class="number">10.</span>  <span class="number">120.</span>    <span class="number">0.</span>   <span class="number">30.</span> ]</span><br></pre></td></tr></table></figure><h4 id="2-numpy-floor"><a href="#2-numpy-floor" class="headerlink" title="2.numpy.floor()"></a><b>2.numpy.floor()</b></h4><p>此函数返回不大于输入参数的最大整数。 即标量x 的下限是最大的整数i ，使得i &lt;= x。 注意在Python中，向下取整总是从 0 舍入。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([-<span class="number">1.7</span>,  <span class="number">1.5</span>,  -<span class="number">0.2</span>,  <span class="number">0.6</span>,  <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;提供的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.floor(a))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提供的数组：</span><br><span class="line">[ -<span class="number">1.7</span>   <span class="number">1.5</span>  -<span class="number">0.2</span>   <span class="number">0.6</span>  <span class="number">10.</span> ]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">[ -<span class="number">2.</span>   <span class="number">1.</span>  -<span class="number">1.</span>   <span class="number">0.</span>  <span class="number">10.</span>]</span><br></pre></td></tr></table></figure><h4 id="3-numpy-ceil"><a href="#3-numpy-ceil" class="headerlink" title="3.numpy.ceil()"></a><b>3.numpy.ceil()</b></h4><p>ceil()函数返回输入值的上限，即，标量x的上限是最小的整数i ，使得i &gt;= x。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([-<span class="number">1.7</span>,  <span class="number">1.5</span>,  -<span class="number">0.2</span>,  <span class="number">0.6</span>,  <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;提供的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ceil(a))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提供的数组：</span><br><span class="line">[ -<span class="number">1.7</span>   <span class="number">1.5</span>  -<span class="number">0.2</span>   <span class="number">0.6</span>  <span class="number">10.</span> ]</span><br><span class="line"></span><br><span class="line">修改后的数组：</span><br><span class="line">[ -<span class="number">1.</span>   <span class="number">2.</span>  -<span class="number">0.</span>   <span class="number">1.</span>  <span class="number">10.</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="十七、Numpy-算数运算"><a href="#十七、Numpy-算数运算" class="headerlink" title="十七、Numpy - 算数运算"></a><b>十七、Numpy - 算数运算</b></h3><p>用于执行算术运算（如add()，subtract()，multiply()和divide()）的输入数组必须具有相同的形状或符合数组广播规则。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">9</span>, dtype = np.float_).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相加：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.add(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相减：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相乘：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组相除：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.divide(a,b))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">两个数组相加：</span><br><span class="line">[[ <span class="number">10.</span> <span class="number">11.</span> <span class="number">12.</span>]</span><br><span class="line"> [ <span class="number">13.</span> <span class="number">14.</span> <span class="number">15.</span>]</span><br><span class="line"> [ <span class="number">16.</span> <span class="number">17.</span> <span class="number">18.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相减：</span><br><span class="line">[[-<span class="number">10.</span> -<span class="number">9.</span> -<span class="number">8.</span>]</span><br><span class="line"> [ -<span class="number">7.</span> -<span class="number">6.</span> -<span class="number">5.</span>]</span><br><span class="line"> [ -<span class="number">4.</span> -<span class="number">3.</span> -<span class="number">2.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相乘：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">10.</span> <span class="number">20.</span>]</span><br><span class="line"> [ <span class="number">30.</span> <span class="number">40.</span> <span class="number">50.</span>]</span><br><span class="line"> [ <span class="number">60.</span> <span class="number">70.</span> <span class="number">80.</span>]]</span><br><span class="line"></span><br><span class="line">两个数组相除：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">0.1</span> <span class="number">0.2</span>]</span><br><span class="line"> [ <span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.5</span>]</span><br><span class="line"> [ <span class="number">0.6</span> <span class="number">0.7</span> <span class="number">0.8</span>]]</span><br></pre></td></tr></table></figure><p>让我们现在来讨论 NumPy 中提供的一些其他重要的算术函数。</p><h4 id="1-numpy-power"><a href="#1-numpy-power" class="headerlink" title="1. numpy.power()"></a><b>1. numpy.power()</b></h4><p>此函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是；&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 power 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.power(a,b))</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是；</span><br><span class="line">[  <span class="number">10</span>  <span class="number">100</span> <span class="number">1000</span>]</span><br><span class="line"></span><br><span class="line">调用 power 函数：</span><br><span class="line">[    <span class="number">100</span>   <span class="number">10000</span> <span class="number">1000000</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">再次调用 power 函数：</span><br><span class="line">[        <span class="number">10</span>      <span class="number">10000</span> <span class="number">1000000000</span>]</span><br></pre></td></tr></table></figure></p><h4 id="numpy-mod"><a href="#numpy-mod" class="headerlink" title="numpy.mod()"></a><b>numpy.mod()</b></h4><p>此函数返回输入数组中相应元素的除法余数。 函数numpy.remainder()也产生相同的结果。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第一个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第二个数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 mod() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mod(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 remainder() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.remainder(a,b))</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">调用 mod() 函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">调用 remainder() 函数：</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>以下函数用于对含有复数的数组执行操作。</p><ul><li><p>numpy.real() 返回复数类型参数的实部。</p></li><li><p>numpy.imag() 返回复数类型参数的虚部。</p></li><li><p>numpy.conj() 返回通过改变虚部的符号而获得的共轭复数。</p></li><li><p>numpy.angle() 返回复数参数的角度。 函数的参数是degree。 如果为true，返回的角度以角度制来表示，否则为以弧度制来表示。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([-<span class="number">5.6j</span>,  <span class="number">0.2j</span>,  <span class="number">11.</span>  ,  <span class="number">1</span>+<span class="number">1j</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 real() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.real(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 imag() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.imag(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 conj() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.conj(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 angle() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.angle(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 angle() 函数（以角度制返回）：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.angle(a,deg =  <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[ <span class="number">0.</span>-<span class="number">5.6j</span> <span class="number">0.</span>+<span class="number">0.2j</span> <span class="number">11.</span>+<span class="number">0.j</span> <span class="number">1.</span>+<span class="number">1.j</span> ]</span><br><span class="line"></span><br><span class="line">调用 real() 函数：</span><br><span class="line">[ <span class="number">0.</span> <span class="number">0.</span> <span class="number">11.</span> <span class="number">1.</span>]</span><br><span class="line"></span><br><span class="line">调用 imag() 函数：</span><br><span class="line">[-<span class="number">5.6</span> <span class="number">0.2</span> <span class="number">0.</span> <span class="number">1.</span> ]</span><br><span class="line"></span><br><span class="line">调用 conj() 函数：</span><br><span class="line">[ <span class="number">0.</span>+<span class="number">5.6j</span> <span class="number">0.</span>-<span class="number">0.2j</span> <span class="number">11.</span>-<span class="number">0.j</span> <span class="number">1.</span>-<span class="number">1.j</span> ]</span><br><span class="line"></span><br><span class="line">调用 angle() 函数：</span><br><span class="line">[-<span class="number">1.57079633</span> <span class="number">1.57079633</span> <span class="number">0.</span> <span class="number">0.78539816</span>]</span><br><span class="line"></span><br><span class="line">再次调用 angle() 函数（以角度制返回）：</span><br><span class="line">[-<span class="number">90.</span> <span class="number">90.</span> <span class="number">0.</span> <span class="number">45.</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="十八、Numpy-统计函数"><a href="#十八、Numpy-统计函数" class="headerlink" title="十八、Numpy - 统计函数"></a><b>十八、Numpy - 统计函数</b></h3><p>Numpy 有很多有用的统计函数，用于从数组中给定的元素中查找最小，最大，百分标准差和方差等。 函数说明如下：</p><h4 id="1-numpy-amin-和-2-numpy-amax"><a href="#1-numpy-amin-和-2-numpy-amax" class="headerlink" title="1. numpy.amin() 和 2. numpy.amax()"></a><b>1. numpy.amin() 和 2. numpy.amax()</b></h4><p>这些函数从给定数组中的元素沿指定轴返回最小值和最大值。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 amin() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 amin() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amin(a,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 amax() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 amax() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.amax(a,axis = <span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="3-numpy-ptp"><a href="#3-numpy-ptp" class="headerlink" title="3. numpy.ptp()"></a>3. numpy.ptp()</h4><p>numpy.ptp()函数返回沿轴的值的范围（最大值 - 最小值）。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 ptp() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 调用 ptp() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis =  <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 调用 ptp() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.ptp(a, axis = <span class="number">0</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">调用 ptp() 函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 调用 ptp() 函数：</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 调用 ptp() 函数：</span><br><span class="line">[<span class="number">6</span> <span class="number">3</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h4 id="4-numpy-percentile"><a href="#4-numpy-percentile" class="headerlink" title="4. numpy.percentile()"></a>4. numpy.percentile()</h4><p>百分位数是统计中使用的度量，表示小于这个值得观察值占某个百分比。 函数numpy.percentile()接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.percentile(a, q, axis)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>a 输入数组</li><li>q 要计算的百分位数，在 0 ~ 100 之间</li><li>axis 沿着它计算百分位数的轴</li></ul><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 percentile() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 调用 percentile() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>, axis = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 调用 percentile() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.percentile(a,<span class="number">50</span>, axis = <span class="number">0</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用 percentile() 函数：</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 调用 percentile() 函数：</span><br><span class="line">[ <span class="number">40.</span> <span class="number">20.</span> <span class="number">60.</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 调用 percentile() 函数：</span><br><span class="line">[ <span class="number">50.</span> <span class="number">40.</span> <span class="number">60.</span>]</span><br></pre></td></tr></table></figure><h4 id="5-numpy-median"><a href="#5-numpy-median" class="headerlink" title="5. numpy.median()"></a>5. numpy.median()</h4><p>中值定义为将数据样本的上半部分与下半部分分开的值。 numpy.median()函数的用法如下面的程序所示。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">65</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">95</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 median() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 调用 median() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a,axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 调用 median() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.median(a,axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">65</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">95</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用 median() 函数：</span><br><span class="line"><span class="number">65.0</span></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 调用 median() 函数：</span><br><span class="line">[ <span class="number">50.</span> <span class="number">90.</span> <span class="number">60.</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 调用 median() 函数：</span><br><span class="line">[ <span class="number">65.</span> <span class="number">80.</span> <span class="number">60.</span>]</span><br></pre></td></tr></table></figure><h4 id="6-numpy-mean"><a href="#6-numpy-mean" class="headerlink" title="6. numpy.mean()"></a>6. numpy.mean()</h4><p>算术平均值是沿轴的元素的总和除以元素的数量。 numpy.mean()函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 mean() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 调用 mean() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 调用 mean() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(a, axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">调用 mean() 函数：</span><br><span class="line"><span class="number">3.66666666667</span></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 调用 mean() 函数：</span><br><span class="line">[ <span class="number">2.66666667</span> <span class="number">3.66666667</span> <span class="number">4.66666667</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 调用 mean() 函数：</span><br><span class="line">[ <span class="number">2.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><h4 id="7-numpy-average"><a href="#7-numpy-average" class="headerlink" title="7. numpy.average()"></a>7. numpy.average()</h4><p>加权平均值是由每个分量乘以反映其重要性的因子得到的平均值。 numpy.average()函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加权平均值 = (<span class="number">1</span>*<span class="number">4</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">3</span>*<span class="number">2</span>+<span class="number">4</span>*<span class="number">1</span>)/(<span class="number">4</span>+<span class="number">3</span>+<span class="number">2</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 average() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 不指定权重时相当于 mean 函数</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;再次调用 average() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average(a,weights = wts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果 returned 参数设为 true，则返回权重的和</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;权重的和：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.average([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],weights = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], returned = <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">调用 average() 函数：</span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">再次调用 average() 函数：</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">权重的和：</span><br><span class="line">(<span class="number">2.0</span>, <span class="number">10.0</span>)</span><br></pre></td></tr></table></figure><p>　　　　　　</p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a><b>标准差</b></h3><p>标准差是与均值的偏差的平方的平均值的平方根。 标准差公式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std = sqrt(mean((x - x.mean())**<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>如果数组是[1，2，3，4]，则其平均值为2.5。 因此，差的平方是[2.25,0.25,0.25,2.25]，并且其平均值的平方根除以4，即sqrt(5/4)是1.1180339887498949。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1180339887498949</span></span><br></pre></td></tr></table></figure><p>　　　　　　</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a><b>方差</b></h3><p>方差是偏差的平方的平均值，即mean((x - x.mean())** 2)。 换句话说，标准差是方差的平方根。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure><hr><h3 id="十九、Numpy-排序、搜索和计数函数"><a href="#十九、Numpy-排序、搜索和计数函数" class="headerlink" title="十九、Numpy - 排序、搜索和计数函数"></a><b>十九、Numpy - 排序、搜索和计数函数</b></h3><p>Numpy中提供了各种排序相关功能。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。　　　　　　　　　　　 　　 　　　 　　　　</p><div class="table-container"><table><thead><tr><th>种类</th><th>速度</th><th>最坏情况</th><th>工作空间</th><th>稳定性</th></tr></thead><tbody><tr><td>quicksort（快速排序）</td><td>1</td><td>O(n^2)</td><td>0</td><td>否</td></tr><tr><td>mergesort（归并排序</td><td>2</td><td>O(n*log(n))</td><td>~n/2</td><td>是</td></tr><tr><td>heapsort（堆排序）</td><td>3</td><td>O(n*log(n))</td><td>0</td><td>否</td></tr></tbody></table></div><h4 id="1-numpy-sort"><a href="#1-numpy-sort" class="headerlink" title="1.numpy.sort()"></a><b>1.numpy.sort()</b></h4><p>sort()函数返回输入数组的排序副本。 它有以下参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>a 要排序的数组</li><li>axis 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序</li><li>kind 默认为’quicksort’（快速排序）</li><li>order 如果数组包含字段，则是要排序的字段</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 sort() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, axis =  <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 在 sort 函数中排序字段</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="built_in">int</span>)])</span><br><span class="line">a = np.array([(<span class="string">&quot;raju&quot;</span>,<span class="number">21</span>),(<span class="string">&quot;anil&quot;</span>,<span class="number">25</span>),(<span class="string">&quot;ravi&quot;</span>,<span class="number">17</span>),(<span class="string">&quot;amar&quot;</span>,<span class="number">27</span>)], dtype = dt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按 name 排序：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.sort(a, order =  <span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">调用 sort() 函数：</span><br><span class="line">[[<span class="number">3</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 排序：</span><br><span class="line">[[<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line">我们的数组是：</span><br><span class="line">[(<span class="string">&#x27;raju&#x27;</span>,<span class="number">21</span>) (<span class="string">&#x27;anil&#x27;</span>,<span class="number">25</span>) (<span class="string">&#x27;ravi&#x27;</span>,<span class="number">17</span>) (<span class="string">&#x27;amar&#x27;</span>,<span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line">按 name 排序：</span><br><span class="line">[(<span class="string">&#x27;amar&#x27;</span>,<span class="number">27</span>) (<span class="string">&#x27;anil&#x27;</span>,<span class="number">25</span>) (<span class="string">&#x27;raju&#x27;</span>,<span class="number">21</span>) (<span class="string">&#x27;ravi&#x27;</span>,<span class="number">17</span>)]</span><br></pre></td></tr></table></figure><h4 id="2-numpy-argmax-和-3-numpy-argmin"><a href="#2-numpy-argmax-和-3-numpy-argmin" class="headerlink" title="2. numpy.argmax() 和 3. numpy.argmin()"></a><b>2. numpy.argmax() 和 3. numpy.argmin()</b></h4><p>这两个函数分别沿给定轴返回最大和最小元素的索引。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 argmax() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.argmax(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.flatten())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 的最大值索引：&#x27;</span>)</span><br><span class="line">maxindex = np.argmax(a,axis = <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(maxindex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 的最大值索引：&#x27;</span>)</span><br><span class="line">maxindex = np.argmax(a, axis =  <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(maxindex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 argmin() 函数：&#x27;</span>)</span><br><span class="line">minindex = np.argmin(a)</span><br><span class="line"><span class="built_in">print</span>(minindex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;展开数组中的最小值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.flatten()[minindex])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 0 的最小值索引：&#x27;</span>)</span><br><span class="line">minindex = np.argmin(a,axis = <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(minindex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;沿轴 1 的最小值索引：&#x27;</span>)</span><br><span class="line">minindex = np.argmin(a,axis = <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(minindex)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span>]</span><br><span class="line"> [<span class="number">80</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用 argmax() 函数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">展开数组：</span><br><span class="line">[<span class="number">30</span> <span class="number">40</span> <span class="number">70</span> <span class="number">80</span> <span class="number">20</span> <span class="number">10</span> <span class="number">50</span> <span class="number">90</span> <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 的最大值索引：</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 的最大值索引：</span><br><span class="line">[<span class="number">2</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">调用 argmin() 函数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">展开数组中的最小值：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">0</span> 的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">沿轴 <span class="number">1</span> 的最小值索引：</span><br><span class="line">[<span class="number">0</span> <span class="number">2</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="4-numpy-nonzero"><a href="#4-numpy-nonzero" class="headerlink" title="4. numpy.nonzero()"></a><b>4. numpy.nonzero()</b></h4><p>numpy.nonzero()函数返回输入数组中非零元素的索引。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 nonzero() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[<span class="number">30</span> <span class="number">40</span> <span class="number">0</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">20</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">50</span> <span class="number">0</span> <span class="number">60</span>]]</span><br><span class="line"></span><br><span class="line">调用 nonzero() 函数：</span><br><span class="line">(array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]), array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h4 id="5-numpy-where"><a href="#5-numpy-where" class="headerlink" title="5. numpy.where()"></a><b>5. numpy.where()</b></h4><p>where()函数返回输入数组中满足给定条件的元素的索引。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;大于 3 的元素的索引：&#x27;</span>)</span><br><span class="line">y = np.where(x &gt; <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用这些索引来获取满足条件的元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x[y])</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">大于 <span class="number">3</span> 的元素的索引：</span><br><span class="line">(array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]), array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">使用这些索引来获取满足条件的元素：</span><br><span class="line">[ <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><h4 id="6-numpy-extract"><a href="#6-numpy-extract" class="headerlink" title="6. numpy.extract()"></a><b>6. numpy.extract()</b></h4><p>extract()函数返回满足任何条件的元素。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 定义条件</span></span><br><span class="line">condition = np.mod(x,<span class="number">2</span>)  ==  <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按元素的条件值：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(condition)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;使用条件提取元素：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.extract(condition,x))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[[ <span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span>]]</span><br><span class="line"></span><br><span class="line">按元素的条件值：</span><br><span class="line">[[ <span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]</span><br><span class="line"> [<span class="literal">False</span> <span class="literal">True</span> <span class="literal">False</span>]</span><br><span class="line"> [ <span class="literal">True</span> <span class="literal">False</span> <span class="literal">True</span>]]</span><br><span class="line"></span><br><span class="line">使用条件提取元素：</span><br><span class="line">[ <span class="number">0.</span> <span class="number">2.</span> <span class="number">4.</span> <span class="number">6.</span> <span class="number">8.</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="二十、Numpy-副本和视图"><a href="#二十、Numpy-副本和视图" class="headerlink" title="二十、Numpy - 副本和视图"></a><b>二十、Numpy - 副本和视图</b></h3><p>在执行函数时，其中一些返回输入数组的副本，而另一些返回视图。 当内容物理存储在另一个位置时，称为<b>副本</b>。 另一方面，如果提供了相同内存内容的不同视图，我们将其称为<b>视图</b>。</p><h3 id="无复制"><a href="#无复制" class="headerlink" title="无复制"></a><b>无复制</b></h3><p>简单的赋值不会创建数组对象的副本。 相反，它使用原始数组的相同id()来访问它。 id()返回 Python 对象的通用标识符，类似于 C 中的指针。</p><p>此外，一个数组的任何变化都反映在另一个数组上。 例如，一个数组的形状改变也会改变另一个数组的形状。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用 id() 函数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 赋值给 b：&#x27;</span>)</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b 拥有相同 id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改 b 的形状：&#x27;</span>)</span><br><span class="line">b.shape = (<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 的形状也修改了：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">调用 <span class="built_in">id</span>() 函数：</span><br><span class="line"><span class="number">139747815479536</span></span><br><span class="line"></span><br><span class="line">a 赋值给 b：</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">b 拥有相同 <span class="built_in">id</span>()：</span><br><span class="line"><span class="number">139747815479536</span></span><br><span class="line"></span><br><span class="line">修改 b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">a 的形状也修改了：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="视图或浅复制"><a href="#视图或浅复制" class="headerlink" title="视图或浅复制"></a><b>视图或浅复制</b></h3><p>Numpy 拥有ndarray.view()方法，它是一个新的数组对象，并可查看原始数组的相同数据。 与前一种情况不同，新数组的维数更改不会更改原始数据的维数。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 最开始 a 是个 3x2 的数组</span></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建 a 的视图：&#x27;</span>)</span><br><span class="line">b = a.view()</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;两个数组的 id() 不同：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 的 id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b 的 id()：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 修改 b 的形状，并不会修改 a</span></span><br><span class="line">b.shape = (<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b 的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 的形状：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">创建 a 的视图：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">两个数组的 <span class="built_in">id</span>() 不同：</span><br><span class="line">a 的 <span class="built_in">id</span>()：</span><br><span class="line"><span class="number">140424307227264</span></span><br><span class="line">b 的 <span class="built_in">id</span>()：</span><br><span class="line"><span class="number">140424151696288</span></span><br><span class="line"></span><br><span class="line">b 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">a 的形状：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a><b>深复制</b></h3><p>ndarray.copy()函数创建一个深层副本。 它是数组及其数据的完整副本，不与原始数组共享。<br><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;创建 a 的深层副本：&#x27;</span>)</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># b 与 a 不共享任何内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我们能够写入 b 来写入 a 吗？&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改 b 的内容：&#x27;</span>)</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;修改后的数组 b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 保持不变：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">创建 a 的深层副本：</span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">我们能够写入 b 来写入 a 吗？</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">修改 b 的内容：</span><br><span class="line">修改后的数组 b：</span><br><span class="line">[[<span class="number">100</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">a 保持不变：</span><br><span class="line">[[<span class="number">10</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure><hr><h3 id="二十一、Numpy-矩阵库"><a href="#二十一、Numpy-矩阵库" class="headerlink" title="二十一、Numpy - 矩阵库"></a><b>二十一、Numpy - 矩阵库</b></h3><p>Numpy 包包含一个 Matrix库numpy.matlib。此模块的函数返回矩阵而不是返回ndarray对象。</p><h4 id="1-matlib-empty"><a href="#1-matlib-empty" class="headerlink" title="1. matlib.empty()"></a><b>1. matlib.empty()</b></h4><p>matlib.empty()函数返回一个新的矩阵，而不初始化元素。 该函数接受以下参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br></pre></td></tr></table></figure><br>其中：</p><ul><li>shape 定义新矩阵形状的整数或整数元组</li><li>Dtype 可选，输出的数据类型</li><li>order C 或者 F</li></ul><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.empty((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="comment"># 填充为随机数据</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">2.12199579e-314</span>,   <span class="number">4.24399158e-314</span>]</span><br><span class="line"> [ <span class="number">4.24399158e-314</span>,   <span class="number">2.12199579e-314</span>]]</span><br></pre></td></tr></table></figure><h4 id="2-numpy-matlib-zeros"><a href="#2-numpy-matlib-zeros" class="headerlink" title="2. numpy.matlib.zeros()"></a><b>2. numpy.matlib.zeros()</b></h4><p>此函数返回以零填充的矩阵。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.zeros((<span class="number">2</span>,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><h4 id="3-numpy-matlib-ones"><a href="#3-numpy-matlib-ones" class="headerlink" title="3. numpy.matlib.ones()"></a><b>3. numpy.matlib.ones()</b></h4><p>此函数返回以一填充的矩阵。</p><p><b>示例</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.ones((<span class="number">2</span>,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><h4 id="4-numpy-matlib-eye"><a href="#4-numpy-matlib-eye" class="headerlink" title="4. numpy.matlib.eye()"></a><b>4. numpy.matlib.eye()</b></h4><p>这个函数返回一个矩阵，对角线元素为 1，其他位置为零。 该函数接受以下参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.matlib.eye(n,M,k,dtype)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>n 返回矩阵的行数</li><li>M 返回矩阵的列数，默认为n</li><li>k 对角线的索引</li><li>dtype 输出的数据类型</li></ul><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.eye(n = <span class="number">3</span>,M = <span class="number">4</span>,k = <span class="number">0</span>,dtype = <span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><h4 id="5-numpy-matlib-identity"><a href="#5-numpy-matlib-identity" class="headerlink" title="5. numpy.matlib.identity()"></a><b>5. numpy.matlib.identity()</b></h4><p>numpy.matlib.identity()函数返回给定大小的单位矩阵。单位矩阵是主对角线元素都为 1 的方阵。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.identity(<span class="number">5</span>,dtype = <span class="built_in">float</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure><h4 id="6-numpy-matlib-rand"><a href="#6-numpy-matlib-rand" class="headerlink" title="6. numpy.matlib.rand()"></a><b>6. numpy.matlib.rand()</b></h4><p>numpy.matlib.rand()函数返回给定大小的填充随机值的矩阵。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.matlib.rand(<span class="number">3</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0.82674464</span>  <span class="number">0.57206837</span>  <span class="number">0.15497519</span>]</span><br><span class="line"> [ <span class="number">0.33857374</span>  <span class="number">0.35742401</span>  <span class="number">0.90895076</span>]</span><br><span class="line"> [ <span class="number">0.03968467</span>  <span class="number">0.13962089</span>  <span class="number">0.39665201</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>注意，矩阵总是二维的，而ndarray是一个 n 维数组。 两个对象都是可互换的。</p></blockquote><hr><h3 id="二十二、Numpy-线性代数"><a href="#二十二、Numpy-线性代数" class="headerlink" title="二十二、Numpy - 线性代数"></a><b>二十二、Numpy - 线性代数</b></h3><p>Numpy 包包含numpy.linalg模块，提供线性代数所需的所有功能，此模块中的一些重要功能如下表所述。　　　　　　　　　 　　　　　　　　 　　　</p><div class="table-container"><table><thead><tr><th>序号</th><th>函数及描述</th></tr></thead><tbody><tr><td>1.</td><td>dot 两个数组的点积</td></tr><tr><td>2.</td><td>vdot 两个向量的点积</td></tr><tr><td>3.</td><td>inner 两个数组的内积</td></tr><tr><td>4.</td><td>matmul 两个数组的矩阵积</td></tr><tr><td>5.</td><td>determinant 数组的行列式</td></tr><tr><td>6.</td><td>solve 求解线性矩阵方程</td></tr><tr><td>7.</td><td>inv 寻找矩阵的乘法逆矩阵</td></tr></tbody></table></div><h4 id="1-numpy-dot"><a href="#1-numpy-dot" class="headerlink" title="1. numpy.dot()"></a><b>1. numpy.dot()</b></h4><p>此函数返回两个数组的点积。 对于二维向量，其等效于矩阵乘法。 对于一维数组，它是向量的内积。 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.dot(a,b))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">37</span>  <span class="number">40</span>]</span><br><span class="line"> [<span class="number">85</span>  <span class="number">92</span>]]</span><br></pre></td></tr></table></figure><h4 id="2-numpy-vdot"><a href="#2-numpy-vdot" class="headerlink" title="2. numpy.vdot()"></a><b>2. numpy.vdot()</b></h4><p>此函数返回两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算， 如果参数id是多维数组，它会被展开。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.vdot(a,b))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">130</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：1*11 + 2*12 + 3*13 + 4*14 = 130。</span><br></pre></td></tr></table></figure><h4 id="3-numpy-inner"><a href="#3-numpy-inner" class="headerlink" title="3. numpy.inner()"></a><b>3. numpy.inner()</b></h4><p>此函数返回一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积。</p><p><b>示例1</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.inner(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]),np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])))</span><br><span class="line"><span class="comment"># 等价于 1*0+2*1+3*0</span></span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><b>示例2</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多维数组示例</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = np.array([[<span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 b：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;内积：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.inner(a,b))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">数组 b：</span><br><span class="line">[[<span class="number">11</span> <span class="number">12</span>]</span><br><span class="line">[<span class="number">13</span> <span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line">内积：</span><br><span class="line">[[<span class="number">35</span> <span class="number">41</span>]</span><br><span class="line">[<span class="number">81</span> <span class="number">95</span>]]</span><br></pre></td></tr></table></figure><p>上面的例子中，内积计算如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1*11+2*12, 1*13+2*14</span><br><span class="line">3*11+4*12, 3*13+4*14</span><br></pre></td></tr></table></figure><h4 id="4-numpy-matmul"><a href="#4-numpy-matmul" class="headerlink" title="4. numpy.matmul"></a><b>4. numpy.matmul</b></h4><p>numpy.matmul()函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p><b>示例1</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于二维数组，它就是矩阵乘法</span></span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">b = [[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.matmul(a,b))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">4</span>  <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span>  <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p><b>示例2</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维和一维运算</span></span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(np.matmul(a,b))</span><br><span class="line"><span class="built_in">print</span>(np.matmul(b,a))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>  <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><b>示例3</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 维度大于二的数组</span></span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(np.matmul(a,b))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[[ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">  [ <span class="number">6</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"> [[<span class="number">10</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">14</span> <span class="number">27</span>]]]</span><br></pre></td></tr></table></figure><h4 id="5-numpy-linalg-det"><a href="#5-numpy-linalg-det" class="headerlink" title="5. numpy.linalg.det()"></a><b>5. numpy.linalg.det()</b></h4><p>行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p><p>换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p><p>numpy.linalg.det()函数计算输入矩阵的行列式。</p><p><b>示例1</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(a))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">2.0</span></span><br></pre></td></tr></table></figure><p><b>示例2</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.array([[<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>], [<span class="number">4</span>, -<span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">6</span>*(-<span class="number">2</span>*<span class="number">7</span> - <span class="number">5</span>*<span class="number">8</span>) - <span class="number">1</span>*(<span class="number">4</span>*<span class="number">7</span> - <span class="number">5</span>*<span class="number">2</span>) + <span class="number">1</span>*(<span class="number">4</span>*<span class="number">8</span> - -<span class="number">2</span>*<span class="number">2</span>))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">6</span>  <span class="number">1</span>  <span class="number">1</span>]</span><br><span class="line"> [ <span class="number">4</span> -<span class="number">2</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">2</span>  <span class="number">8</span>  <span class="number">7</span>]]</span><br><span class="line">-<span class="number">306.0</span></span><br><span class="line">-<span class="number">306</span></span><br></pre></td></tr></table></figure><h4 id="6-numpy-linalg-solve"><a href="#6-numpy-linalg-solve" class="headerlink" title="6. numpy.linalg.solve()"></a><b>6. numpy.linalg.solve()</b></h4><p>numpy.linalg.solve()函数给出了矩阵形式的线性方程的解。</p><p><b>示例</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy.linalg中的函数solve可以求解形如 Ax = b 的线性方程组，其中 A 为矩阵，b 为一维或二维的数组，x 是未知变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建矩阵和数组</span></span><br><span class="line">B = np.mat(<span class="string">&quot;1 -2 1;0 2 -8;-4 5 9&quot;</span>)</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">8</span>,-<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用solve函数求解线性方程</span></span><br><span class="line">x = np.linalg.solve(B,b)</span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="comment">#[ 29. 16. 3.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dot函数检查求得的解是否正确</span></span><br><span class="line"><span class="built_in">print</span> (np.dot(B , x))</span><br><span class="line"><span class="comment"># [[ 0. 8. -9.]]</span></span><br></pre></td></tr></table></figure></p><h4 id="7-numpy-linalg-inv"><a href="#7-numpy-linalg-inv" class="headerlink" title="7. numpy.linalg.inv()"></a><b>7. numpy.linalg.inv()</b></h4><p>我们使用numpy.linalg.inv()函数来计算矩阵的逆。 矩阵的逆是这样的，如果它乘以原始矩阵，则得到单位矩阵。</p><p><b>示例1</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.linalg.inv(x)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(np.dot(x,y))</span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line">[[-<span class="number">2.</span>   <span class="number">1.</span> ]</span><br><span class="line"> [ <span class="number">1.5</span> -<span class="number">0.5</span>]]</span><br><span class="line">[[  <span class="number">1.00000000e+00</span>   <span class="number">1.11022302e-16</span>]</span><br><span class="line"> [  <span class="number">0.00000000e+00</span>   <span class="number">1.00000000e+00</span>]]</span><br></pre></td></tr></table></figure><p><b>示例2</b></p><p>现在让我们在示例中创建一个矩阵A的逆。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>,-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数组 a：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">ainv = np.linalg.inv(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a 的逆：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ainv)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;矩阵 b：&#x27;</span>)</span><br><span class="line">b = np.array([[<span class="number">6</span>],[-<span class="number">4</span>],[<span class="number">27</span>]])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算：A^(-1)B：&#x27;</span>)</span><br><span class="line">x = np.linalg.solve(a,b)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># 这就是线性方向 x = 5, y = 3, z = -2 的解</span></span><br></pre></td></tr></table></figure><br>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">数组 a：</span><br><span class="line">[[ <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"> [ <span class="number">0</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">2</span> <span class="number">5</span> -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">a 的逆：</span><br><span class="line">[[ <span class="number">1.28571429</span> -<span class="number">0.28571429</span> -<span class="number">0.14285714</span>]</span><br><span class="line"> [-<span class="number">0.47619048</span> <span class="number">0.14285714</span> <span class="number">0.23809524</span>]</span><br><span class="line"> [ <span class="number">0.19047619</span> <span class="number">0.14285714</span> -<span class="number">0.0952381</span> ]]</span><br><span class="line"></span><br><span class="line">矩阵 b：</span><br><span class="line">[[ <span class="number">6</span>]</span><br><span class="line"> [-<span class="number">4</span>]</span><br><span class="line"> [<span class="number">27</span>]]</span><br><span class="line"></span><br><span class="line">计算：A^(-<span class="number">1</span>)B：</span><br><span class="line">[[ <span class="number">5.</span>]</span><br><span class="line"> [ <span class="number">3.</span>]</span><br><span class="line"> [-<span class="number">2.</span>]]</span><br></pre></td></tr></table></figure><p>结果也可以使用下列函数获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = np.dot(ainv,b)</span><br></pre></td></tr></table></figure><h4 id="8-numpy-random-randint"><a href="#8-numpy-random-randint" class="headerlink" title="8. numpy.random.randint"></a><b>8. numpy.random.randint</b></h4><p>生成n行m列的数组，数组元素通过randint随机生成。<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成四行三列的随机整数数组，元素范围为[0,10]</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.randint(<span class="number">0</span>,<span class="number">10</span>,(<span class="number">4</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><hr><h4 id="2019-1-27更新："><a href="#2019-1-27更新：" class="headerlink" title="2019/1/27更新："></a>2019/1/27更新：</h4><p>将多维数组展平变成一维：</p><ul><li>np.ravel()  # 只提供试图</li><li>np.flatten() # 请求分配内存来保存结果</li></ul><hr><h3 id="之后有空会学习下Matplotlib，待更新…"><a href="#之后有空会学习下Matplotlib，待更新…" class="headerlink" title="之后有空会学习下Matplotlib，待更新…"></a><b>之后有空会学习下Matplotlib，待更新…</b></h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1541532616136&amp;di=c82ab97df354a22c8aea283f7728caf4&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D1419051179%2C3849014730%26fm%3D214%26gp%3D0.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath用法总结</title>
      <link href="/Xpath%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
      <url>/Xpath%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/u013332124/article/details/80621638">https://blog.csdn.net/u013332124/article/details/80621638</a></p><h3 id="一、Xpath介绍"><a href="#一、Xpath介绍" class="headerlink" title="一、Xpath介绍"></a><b>一、Xpath介绍</b></h3><p>Xpath 是一门在 XML 文档中查找信息的语言，Xpath 用于在 XML 文档中通过元素和属性进行导航。</p><ul><li>Xpath 使用路径表达式在 XML 文档中进行导航</li><li>Xpath 包含一个标准函数库</li><li>Xpath 是 XSLT 中的主要元素</li><li>Xpath 是一个 W3C 标准</li></ul><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a><b>节点</b></h5><p>在 Xpath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。<br><span id="more"></span></p><hr><h3 id="二、Xpath语法"><a href="#二、Xpath语法" class="headerlink" title="二、Xpath语法"></a><b>二、Xpath语法</b></h3><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>/</td><td>从根节点选取。</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table></div><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><b>例子</b></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><b>xml.xpath(“bookstore”) </b>表示选取 bookstore 元素的所有子节点</li><li><b>xml.xpath(“/bookstore”)</b> 表示选取根元素 bookstore。</li><li><b>xml.xpath(“bookstore/book”)</b> 选取属于 bookstore 的子元素的所有 book 元素。</li><li><b>xml.xpath(“//book”)</b> 选取所有 book 子元素，而不管它们在文档中的位置。</li><li><b>xml.xpath(“bookstore//book”)</b> 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</li><li><b>xml.xpath(“//@lang”)</b> 选取名为 lang 的所有属性。</li></ul><hr><h4 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a><b>谓语</b></h4><div class="table-container"><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>/bookstore/book[position() &lt; 3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>//title[@lang=’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table></div><h4 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a><b>选取未知节点</b></h4><div class="table-container"><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配任何元素节点。</td></tr><tr><td>@*</td><td>匹配任何属性节点。</td></tr><tr><td>node()</td><td>匹配任何类型的节点。</td></tr></tbody></table></div><p>例子：　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/*</td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td>//*</td><td>选取文档中的所有元素。</td></tr><tr><td>//title[@*]</td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table></div><h4 id="选取若干路径"><a href="#选取若干路径" class="headerlink" title="选取若干路径"></a><b>选取若干路径</b></h4><p>通过在路径表达式中使用“|”运算符，您可以选取若干个路径。</p><ul><li><b>//book/title | //book/price</b> 选取 book 元素的所有 title 和 price 元素。</li><li><b>//title | //price</b> 选取文档中的所有 title 和 price 元素。</li><li><b>/bookstore/book/title | //price</b> 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</li></ul><hr><h3 id="三、轴"><a href="#三、轴" class="headerlink" title="三、轴"></a><b>三、轴</b></h3><p>轴可定义相对于当前节点的节点集。　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>轴名称</th><th>结果</th></tr></thead><tbody><tr><td>ancestor</td><td>选取当前节点的所有先辈（父、祖父等）。</td></tr><tr><td>ancestor-or-self</td><td>选取当前节点的所有先辈（父、祖父等）以及当前节点本身。</td></tr><tr><td>attribute</td><td>选取当前节点的所有属性。</td></tr><tr><td>child</td><td>选取当前节点的所有子元素。</td></tr><tr><td>descendant</td><td>选取当前节点的所有后代元素（子、孙等）。</td></tr><tr><td>descendant-or-self</td><td>选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td></tr><tr><td>following</td><td>选取文档中当前节点的结束标签之后的所有节点。</td></tr><tr><td>namespace</td><td>选取当前节点的所有命名空间节点。</td></tr><tr><td>parent</td><td>选取当前节点的父节点。</td></tr><tr><td>preceding</td><td>选取文档中当前节点的开始标签之前的所有节点。</td></tr><tr><td>preceding-sibling</td><td>选取当前节点之前的所有同级节点。</td></tr><tr><td>self</td><td>选取当前节点。</td></tr></tbody></table></div><p><b>步的语法： </b></p><blockquote><p>轴名称::节点测试[谓语]</p></blockquote><p>例子：　　　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>例子</th><th>结果</th></tr></thead><tbody><tr><td>child::book</td><td>选取所有属于当前节点的子元素的 book 节点。</td></tr><tr><td>attribute::lang</td><td>选取当前节点的 lang 属性。</td></tr><tr><td>child:: *</td><td>选取当前节点的所有子元素。</td></tr><tr><td>attribute:: *</td><td>选取当前节点的所有属性。</td></tr><tr><td>child::text()</td><td>选取当前节点的所有文本子节点。</td></tr><tr><td>child::node()</td><td>选取当前节点的所有子节点。</td></tr><tr><td>descendant::book</td><td>选取当前节点的所有 book 后代。</td></tr><tr><td>ancestor::book</td><td>选择当前节点的所有 book 先辈。</td></tr><tr><td>ancestor-or-self::book</td><td>选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点）</td></tr><tr><td>child:: */child::price</td><td>选取当前节点的所有 price 孙节点。</td></tr></tbody></table></div><hr><h3 id="四、一些函数"><a href="#四、一些函数" class="headerlink" title="四、一些函数"></a><b>四、一些函数</b></h3><p><b>1. starts-with函数</b><br>获取以xxx开头的元素<br>例子：xpath(‘//div[starts-with(@class,”test”)]’)</p><p><b>2.contains函数</b><br>获取包含xxx的元素<br>例子：xpath(‘//div[contains(@id,”test”)]’)</p><p><b>3.and</b><br>与的关系<br>例子：xpath(‘//div[contains(@id,”test”) and contains(@id,”title”)]’)</p><p><b>4.text()函数</b><br>例子1：xpath(‘//div[contains(text(),”test”)]’)<br>例子2：xpath(‘//div[@id=”test”]/text()’)</p><hr><h3 id="五、一个lxml的Xpath示例"><a href="#五、一个lxml的Xpath示例" class="headerlink" title="五、一个lxml的Xpath示例"></a><b>五、一个lxml的Xpath示例</b></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">　　&lt;head&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;meta name=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;title&gt;友情链接查询 - 站长工具&lt;/title&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;!-- uRj0Ak8VLEPhjWhg3m9z4EjXJwc --&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;meta name=&quot;Keywords&quot; content=&quot;友情链接查询&quot; /&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;meta name=&quot;Description&quot; content=&quot;友情链接查询&quot; /&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　&lt;/head&gt;</span></span><br><span class="line"><span class="string">　　&lt;body&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;h1 class=&quot;heading&quot;&gt;Top News&lt;/h1&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;p style=&quot;font-size: 200%&quot;&gt;World News only on this page&lt;/p&gt;</span></span><br><span class="line"><span class="string">　　　　Ah, and here&#x27;s some more text, by the way.</span></span><br><span class="line"><span class="string">　　　　&lt;p&gt;... and this is a parsed fragment ...&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://www.cydf.org.cn/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;青少年发展基金会&lt;/a&gt; </span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://www.4399.com/flash/32979.htm&quot; target=&quot;_blank&quot;&gt;洛克王国&lt;/a&gt; </span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://www.4399.com/flash/35538.htm&quot; target=&quot;_blank&quot;&gt;奥拉星&lt;/a&gt; </span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://game.3533.com/game/&quot; target=&quot;_blank&quot;&gt;手机游戏&lt;/a&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://game.3533.com/tupian/&quot; target=&quot;_blank&quot;&gt;手机壁纸&lt;/a&gt;</span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://www.4399.com/&quot; target=&quot;_blank&quot;&gt;4399小游戏&lt;/a&gt; </span></span><br><span class="line"><span class="string">　　　　&lt;a href=&quot;http://www.91wan.com/&quot; target=&quot;_blank&quot;&gt;91wan游戏&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">page = etree.HTML(html.lower().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">hrefs = page.xpath(<span class="string">u&quot;//a&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> href <span class="keyword">in</span> hrefs:</span><br><span class="line">    <span class="built_in">print</span>(href.attrib)</span><br></pre></td></tr></table></figure><blockquote><p>打印出的结果为：</p></blockquote><p>{‘href’: ‘<a href="http://www.cydf.org.cn/‘">http://www.cydf.org.cn/‘</a>, ‘target’: ‘_blank’, ‘rel’: ‘nofollow’}<br>{‘href’: ‘<a href="http://www.4399.com/flash/32979.htm‘">http://www.4399.com/flash/32979.htm‘</a>, ‘target’: ‘_blank’}<br>{‘href’: ‘<a href="http://www.4399.com/flash/35538.htm‘">http://www.4399.com/flash/35538.htm‘</a>, ‘target’: ‘_blank’}<br>{‘href’: ‘<a href="http://game.3533.com/game/‘">http://game.3533.com/game/‘</a>, ‘target’: ‘_blank’}<br>{‘href’: ‘<a href="http://game.3533.com/tupian/‘">http://game.3533.com/tupian/‘</a>, ‘target’: ‘_blank’}<br>{‘href’: ‘<a href="http://www.4399.com/‘">http://www.4399.com/‘</a>, ‘target’: ‘_blank’}<br>{‘href’: ‘<a href="http://www.91wan.com/‘">http://www.91wan.com/‘</a>, ‘target’: ‘_blank’}<br>　　　　　　　　　　　　　　　　　　<br>如果要获取标签a之间的内容，就可以用<code>print href.text</code>输出</p><hr><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><b>六、总结</b></h3><p>上面的内容大多都是抄自网上的一些资料,这里只是做了一个大概的总结，后面如果有漏的还会补充。</p><hr><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> XPath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 Random模块常用函数总结</title>
      <link href="/Python3-random%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93.html"/>
      <url>/Python3-random%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/xiaocaiju/article/details/6973175">https://blog.csdn.net/xiaocaiju/article/details/6973175</a></p><p><b>Python中的random模块用于生成随机数。下面介绍一下random模块中最常用的几个函数。</b><br><span id="more"></span></p><h3 id="1-random-randint"><a href="#1-random-randint" class="headerlink" title="1.random.randint"></a><b>1.random.randint</b></h3><p>random.randint()的函数原型为：random.randint(a, b)，用于<b>生成一个指定范围内的整数</b>。其中参数a是下限，参数b是上限，生成的随机数n: a &lt;= n &lt;= b</p><h3 id="2-random-randrange"><a href="#2-random-randrange" class="headerlink" title="2.random.randrange"></a><b>2.random.randrange</b></h3><p>　random.randrange的函数原型为：random.randrange([start], stop[, step])，<b>从指定范围内，按指定基数递增的集合中获取一个随机数</b>。如：random.randrange(10, 100, 2)，结果相当于从[10, 12, 14, 16, … 96, 98]序列中获取一个随机数。random.randrange(10, 100, 2)在结果上与 random.choice(range(10, 100, 2) )等效。</p><h3 id="3-random-random"><a href="#3-random-random" class="headerlink" title="3.random.random"></a><b>3.random.random</b></h3><p>random.random()用于<b>生成一个0到1的随机浮点数</b>: 0 &lt;= n &lt; 1.0</p><h3 id="4-random-uniform"><a href="#4-random-uniform" class="headerlink" title="4.random.uniform"></a><b>4.random.uniform</b></h3><p>random.uniform的函数原型为: random.uniform(a, b)，用于<b>生成一个指定范围内的随机浮点数</b>，两个参数其中一个是上限，一个是下限。如果a &lt; b，则生成的随机数n: a &lt;= n &lt;= b。如果 a &gt; b， 则 b &lt;= n &lt;= a。</p><h3 id="5-random-choice"><a href="#5-random-choice" class="headerlink" title="5.random.choice"></a><b>5.random.choice</b></h3><p>random.choice<b>从序列中获取一个随机元素</b>。其函数原型为：random.choice(sequence)。参数sequence表示一个有序类型。这里要说明 一下：sequence在python不是一种特定的类型，而是泛指一系列的类型。list, tuple, 字符串都属于sequence。</p><h3 id="6-random-shuffle"><a href="#6-random-shuffle" class="headerlink" title="6.random.shuffle"></a><b>6.random.shuffle</b></h3><p>random.shuffle的函数原型为：random.shuffle(x[, random])，<b>用于将一个列表中的元素打乱</b>。</p><h3 id="7-random-sample"><a href="#7-random-sample" class="headerlink" title="7.random.sample"></a><b>7.random.sample</b></h3><p>random.sample的函数原型为：random.sample(sequence, k)，<b>从指定序列中随机获取指定长度的片断</b>, sample函数不会修改原有序列。</p><blockquote><p><b>上面这些方法是random模块中最常用的，在Python手册中，还介绍其他的方法。感兴趣的朋友可以通过查询Python手册了解更详细的信息。</b></p></blockquote><hr><p><b>代码实现：</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成[1,10]的随机整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">10</span>))　　　　　　<span class="comment">#[a,b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成[1,100]步长为2的随机数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>))　　　　　<span class="comment">#[a,b,step]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成[0.0,1.0)的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>(random.random())  　　　　　　　　 <span class="comment">#[0,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成[1.0,12.0]的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1.0</span>,<span class="number">12.0</span>))  　　  <span class="comment">#[a,b]</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#从序列中随机选取一个元素</span></span><br><span class="line"><span class="built_in">print</span>(random.choice(lst))</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新打乱一个列表</span></span><br><span class="line">random.shuffle(lst)</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从序列中随机选取5个元素</span></span><br><span class="line"><span class="built_in">print</span>(random.sample(lst,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p><b>运行结果：</b></p><blockquote><p>5<br>49<br>0.4109578465733287<br>7.539110018468436<br>9<br>[10, 6, 8, 2, 1, 9, 3, 4, 5, 7]<br>[6, 2, 3, 5, 1]</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 Requests模块详解</title>
      <link href="/Python3-requests%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.html"/>
      <url>/Python3-requests%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<p>参考链接 : <a href="https://www.cnblogs.com/ranxf/p/7808537.html">https://www.cnblogs.com/ranxf/p/7808537.html</a></p><hr><h3 id="一、安装requests"><a href="#一、安装requests" class="headerlink" title="一、安装requests"></a><b>一、安装requests</b></h3><ul><li><p>通过pip安装</p><blockquote><p> <b>pip install requests</p></blockquote></li><li><p>或者下载代码后通过git安装</p><blockquote><p><b>$ git clone git://github.com/kennethreitz/requests.git<br>$ cd requests<br>$ python setup.py install</b></p><span id="more"></span></blockquote></li></ul><hr><h3 id="二、基础入门"><a href="#二、基础入门" class="headerlink" title="二、基础入门"></a><b>二、基础入门</b></h3><p>1）导入模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>2）发送请求的简洁<br>　　<br>　　　示例代码：获取一个网页（个人github）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r1 = requests.get(<span class="string">&#x27;https://github.com/QzmVc1&#x27;</span>)       <span class="comment"># 最基本的不带参数的get请求</span></span><br><span class="line">r2 = requests.get(url=<span class="string">&#x27;http://dict.baidu.com/s&#x27;</span>, params=&#123;<span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;)      <span class="comment"># 带参数的get请求</span></span><br></pre></td></tr></table></figure><p>我们就可以使用该方式使用以下各种方法</p><blockquote><p><b> requests.get(‘<a href="https://github.com/timeline.json’">https://github.com/timeline.json’</a>)　　　　　　　# GET请求<br>  requests.post(“<a href="http://httpbin.org/post”">http://httpbin.org/post”</a>)　　　　　　　　　　 # POST请求<br>  requests.put(“<a href="http://httpbin.org/put”">http://httpbin.org/put”</a>)　　　　　　　　　　　　# PUT请求<br>  requests.delete(“<a href="http://httpbin.org/delete”">http://httpbin.org/delete”</a>)　　　　　　　　 # DELETE请求<br>  requests.head(“<a href="http://httpbin.org/get”">http://httpbin.org/get”</a>)　　　　　　　　　　 # HEAD请求<br>  requests.options(“<a href="http://httpbin.org/get”">http://httpbin.org/get”</a> )　　　　　　　　 # OPTIONS请求</b></p></blockquote><p>3）响应的内容　　　　　　　　　　　　　　　　　　　　　</p><div class="table-container"><table><thead><tr><th>响应内容</th><th>意义</th></tr></thead><tbody><tr><td>r.encoding</td><td>获取当前的编码</td></tr><tr><td>r.encoding = ‘utf-8’</td><td>设置编码</td></tr><tr><td>r.text</td><td>以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。</td></tr><tr><td>r.content</td><td>以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。</td></tr><tr><td>r.headers</td><td>以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None</td></tr><tr><td>r.status_code</td><td>响应状态码</td></tr><tr><td>r.ok</td><td>查看r.ok的布尔值便可以知道是否登陆成功</td></tr><tr><td>r.json()</td><td>Requests中内置的JSON解码器，以json形式返回,前提返回的内容确保是json格式的，不然解析出错会抛异常</td></tr><tr><td>r.raise_for_status()</td><td>失败请求(非200响应)抛出异常</td></tr><tr><td>r.requests.headers</td><td>返回发送到服务器的头信息</td></tr><tr><td>r.cookies</td><td>返回cookie</td></tr><tr><td>r.history</td><td>返回重定向信息,当然可以在请求是加上allow_redirects = false 阻止重定向</td></tr></tbody></table></div><p>4）为get请求传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url_params = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;       <span class="comment">#字典传递参数</span></span><br><span class="line">r = requests.get(<span class="string">&#x27;your url&#x27;</span>,params = url_params)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.url)</span><br></pre></td></tr></table></figure><p>输出结果</p><blockquote><p>your url?key=value</p></blockquote><p>5）为post请求传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url_params = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;https://api.github.com/some/endpoint&#x27;</span>,data=url_params)</span><br></pre></td></tr></table></figure><p>6）定制header和cookie信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;my-app/0.0.1&#x27;</span>&#125;</span><br><span class="line">cookie = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r = requests.get/post(<span class="string">&#x27;your url&#x27;</span>,headers=header,cookies=cookie) </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">data = &#123;<span class="string">&#x27;some&#x27;</span>: <span class="string">&#x27;data&#x27;</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:22.0) Gecko/20100101 Firefox/22.0&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">r = requests.post(<span class="string">&#x27;https://api.github.com/some/endpoint&#x27;</span>, data=data, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p>7）超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;url&#x27;</span>,timeout=<span class="number">1</span>)           <span class="comment">#设置秒数超时，仅对于连接有效</span></span><br></pre></td></tr></table></figure><p>8）会话对象，能够跨请求保持某些参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.auth = (<span class="string">&#x27;auth&#x27;</span>,<span class="string">&#x27;passwd&#x27;</span>)</span><br><span class="line">s.headers = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r1 = s.get(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">r2 = s.get(<span class="string">&#x27;url1&#x27;</span>) </span><br></pre></td></tr></table></figure><p>9）代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;<span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;ip1&#x27;</span>,<span class="string">&#x27;https&#x27;</span>:<span class="string">&#x27;ip2&#x27;</span> &#125;</span><br><span class="line">requests.get(<span class="string">&#x27;url&#x27;</span>,proxies=proxies)</span><br></pre></td></tr></table></figure><hr><h3 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a><b>三、示例代码</b></h3><p><b>3.1 GET请求</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、无参数实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">ret = requests.get(<span class="string">&#x27;https://github.com/timeline.json&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(ret.url)</span><br><span class="line"><span class="built_in">print</span>(ret.text)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2、有参数实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">payload = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line">ret = requests.get(<span class="string">&quot;http://httpbin.org/get&quot;</span>, params=payload)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(ret.url)</span><br><span class="line"><span class="built_in">print</span>(ret.text)</span><br></pre></td></tr></table></figure><p><b>3.2 POST请求</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、基本POST实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">  </span><br><span class="line">payload = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line">ret = requests.post(<span class="string">&quot;http://httpbin.org/post&quot;</span>, data=payload)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(ret.text)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 2、发送请求头和数据实例</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">  </span><br><span class="line">url = <span class="string">&#x27;https://api.github.com/some/endpoint&#x27;</span></span><br><span class="line">payload = &#123;<span class="string">&#x27;some&#x27;</span>: <span class="string">&#x27;data&#x27;</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line">ret = requests.post(url, data=json.dumps(payload), headers=headers)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(ret.text)</span><br><span class="line"><span class="built_in">print</span>(ret.cookies)</span><br></pre></td></tr></table></figure><p><b>3.3 XML请求</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">url_request</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;init&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    heards = &#123;<span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/xml&#x27;</span>&#125;</span><br><span class="line">    XML = <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;Request xmlns=&quot;http://tempuri.org/&quot;&gt;&lt;jme&gt;&lt;JobClassFullName&gt;WeChatJSTicket.JobWS.Job.JobRefreshTicket,WeChatJSTicket.JobWS&lt;/JobClassFullName&gt;&lt;Action&gt;RUN&lt;/Action&gt;&lt;Param&gt;1&lt;/Param&gt;&lt;HostIP&gt;127.0.0.1&lt;/HostIP&gt;&lt;JobInfo&gt;1&lt;/JobInfo&gt;&lt;NeedParallel&gt;false&lt;/NeedParallel&gt;&lt;/jme&gt;&lt;/Request&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;http://jobws.push.mobile.xxxxxxxx.com/RefreshWeiXInTokenJob/RefreshService.asmx&#x27;</span></span><br><span class="line">    r = requests.post(url=url, heards=heards, data=XML)</span><br><span class="line">    data = r.text</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></p><p><b>3.4 状态异常处理</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL = <span class="string">&#x27;http://ip.taobao.com/service/getIpInfo.php&#x27;</span>  <span class="comment"># 淘宝IP地址库API</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    r = requests.get(URL, params=&#123;<span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;8.8.8.8&#x27;</span>&#125;, timeout=<span class="number">1</span>)</span><br><span class="line">    r.raise_for_status()  <span class="comment"># 如果响应状态码不是 200，就主动抛出异常</span></span><br><span class="line"><span class="keyword">except</span> requests.RequestException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = r.json()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(result), result, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p><b>3.5 上传文件</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:8080/upload&#x27;</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;/home/rxf/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">#files = &#123;&#x27;file&#x27;: (&#x27;report.jpg&#x27;, open(&#x27;/home/lyb/sjzl.mpg&#x27;, &#x27;r&#x27;))&#125;     #显式的设置文件名</span></span><br><span class="line"> </span><br><span class="line">r = requests.post(url, files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p><b>3.6 身份验证</b></p><p>基本身份认证(HTTP Basic Auth)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"> </span><br><span class="line">r = requests.get(<span class="string">&#x27;https://httpbin.org/hidden-basic-auth/user/passwd&#x27;</span>, auth=HTTPBasicAuth(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;passwd&#x27;</span>))</span><br><span class="line"><span class="comment"># r = requests.get(&#x27;https://httpbin.org/hidden-basic-auth/user/passwd&#x27;, auth=(&#x27;user&#x27;, &#x27;passwd&#x27;))    # 简写</span></span><br><span class="line"><span class="built_in">print</span>(r.json())</span><br></pre></td></tr></table></figure><br>另一种非常流行的HTTP身份认证形式是摘要式身份认证，Requests对它的支持也是开箱即可用的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(URL, auth=HTTPDigestAuth(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>))</span><br></pre></td></tr></table></figure><hr><p>有关Session的问题可以参考<a href="https://blog.csdn.net/hjc1984117/article/details/53995816">Session详解</a></p><h3 id="待补充…"><a href="#待补充…" class="headerlink" title="待补充…"></a>待补充…</h3>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyMySQL实现与数据库的交互</title>
      <link href="/PyMySQL%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92.html"/>
      <url>/PyMySQL%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、什么是PyMySQL"><a href="#1、什么是PyMySQL" class="headerlink" title="1、什么是PyMySQL"></a><b>1、什么是PyMySQL</b></h3><blockquote><p>为了使Python连接上数据库，你需要一个驱动，这个驱动是用于与数据库交互的库。<br>　　　　　　　　　　　　　　　　　　　　　<br>PyMySQL ： 这是一个使Python连接到MySQL的库，它是一个纯Python库。</p></blockquote><p><b>环境要求：</b><br>PyMySQL支持的python版本：</p><blockquote><ul><li>python2<br>python2.7</li><li>python3<br>python version &gt;=3.4<span id="more"></span></li></ul><hr><h3 id="2、如何安装PyMySQL"><a href="#2、如何安装PyMySQL" class="headerlink" title="2、如何安装PyMySQL"></a><b>2、如何安装PyMySQL</b></h3><p>打开cmd，输入以下语句：<br>pip install PyMySQL</p></blockquote><p>回车等待安装完成。</p><hr><h3 id="3、PyMySQL实现与数据库的交互"><a href="#3、PyMySQL实现与数据库的交互" class="headerlink" title="3、PyMySQL实现与数据库的交互"></a><b>3、PyMySQL实现与数据库的交互</b></h3><blockquote><p><b>PyMySQL实现与数据库的交互，我们首先需要了解一下Python数据库的图解流程。关于图解流程图中的Connection对象和游标对象Cursor下面给出了生动的比喻。</b></p><h4 id="Python-数据库图解流程"><a href="#Python-数据库图解流程" class="headerlink" title="Python 数据库图解流程:"></a><b>Python 数据库图解流程:</b></h4><p><img src="https://s1.ax1x.com/2018/11/21/FCFsVU.jpg" alt=""></p><h4 id="Connection、Cursor比喻"><a href="#Connection、Cursor比喻" class="headerlink" title="Connection、Cursor比喻:"></a><b>Connection、Cursor比喻:</b></h4><p><img src="https://s1.ax1x.com/2018/11/21/FCF654.png" alt=""><br> <b>下面我们先上代码，用PyMySQL与数据库进行交互实现增删改查，有关代码中的陌生函数会在文章末尾给出说明。</b></p></blockquote><hr><h4 id="3-1-查询操作"><a href="#3-1-查询操作" class="headerlink" title="3.1 查询操作"></a><b>3.1 查询操作</b></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql <span class="comment">#导入pymysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,db=<span class="string">&quot;demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法获取操作游标</span></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用查询操作</span></span><br><span class="line"><span class="comment">#编写sql语句，profile是db里面的一个表名</span></span><br><span class="line">sql = <span class="string">&quot;select * from profile&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比喻图解里面出现的“事故”</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)   <span class="comment">#执行查询操作</span></span><br><span class="line">    results = cur.fetchall()  <span class="comment">#fetchall方法返回一个包含所有查询信息的元组</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;critical_level&quot;</span>) <span class="comment">#表中字段名</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:                <span class="comment">#打印表单</span></span><br><span class="line">        <span class="built_in">print</span>(row[<span class="number">0</span>],row[<span class="number">1</span>],row[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">raise</span> e        <span class="comment">#抛出异常</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db.close()      <span class="comment">#关闭数据库</span></span><br><span class="line">cur.close()     <span class="comment">#关闭光标</span></span><br></pre></td></tr></table></figure><p><b>运行结果</b></p><blockquote><p>id name critical_level<br>1 warp core 4<br>2 life support 3<br>3 thruster 2<br>4 transporer 1<br>5 deflecter 2<br>6 botanic bay 0<br>8 warp system 2<br>9 phaser bank 1<br>10 photon torpedo 2<br>11 primary system 2<br>12 secondary system 1<br>13 coca cola 4<br>14 sensor 1</p><hr><h4 id="3-2-插入操作"><a href="#3-2-插入操作" class="headerlink" title="3.2 插入操作"></a><b>3.2 插入操作</b></h4></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql <span class="comment">#导入pymysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,db=<span class="string">&quot;demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法获取操作游标</span></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用插入操作</span></span><br><span class="line"><span class="comment">#编写sql语句，profile是db里面的一个表名</span></span><br><span class="line">sql = <span class="string">&quot;insert into profile(id,name,critical_level) values(15,&#x27;QzmVc1&#x27;,&#x27;5&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比喻图解里面出现的“事故”</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)  <span class="comment">#执行插入操作</span></span><br><span class="line">    db.commit()       <span class="comment">#提交操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    db.rollback()     <span class="comment">#错误回滚</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db.close()      <span class="comment">#关闭数据库</span></span><br><span class="line">cur.close()     <span class="comment">#关闭光标</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-3-更新操作"><a href="#3-3-更新操作" class="headerlink" title="3.3 更新操作"></a><b>3.3 更新操作</b></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql <span class="comment">#导入pymysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,db=<span class="string">&quot;demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法获取操作游标</span></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用更新操作</span></span><br><span class="line"><span class="comment">#编写sql语句，profile是db里面的一个表名</span></span><br><span class="line">sql = <span class="string">&quot;update profile set name = &#x27;%s&#x27;,critical_level = %d where id = %d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比喻图解里面出现的“事故”</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql % (<span class="string">&#x27;Vincent&#x27;</span>,<span class="number">3</span>,<span class="number">15</span>))  <span class="comment">#执行插入操作</span></span><br><span class="line">    db.commit()       <span class="comment">#提交操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    db.rollback()     <span class="comment">#错误回滚</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db.close()      <span class="comment">#关闭数据库</span></span><br><span class="line">cur.close()     <span class="comment">#关闭光标</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-4-删除操作"><a href="#3-4-删除操作" class="headerlink" title="3.4 删除操作"></a><b>3.4 删除操作</b></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql <span class="comment">#导入pymysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;root&quot;</span>,db=<span class="string">&quot;demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法获取操作游标</span></span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用删除操作</span></span><br><span class="line"><span class="comment">#编写sql语句，profile是db里面的一个表名</span></span><br><span class="line">sql = <span class="string">&quot;delete from profile where id = %d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比喻图解里面出现的“事故”</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql % (<span class="number">15</span>))  <span class="comment">#执行插入操作</span></span><br><span class="line">    db.commit()       <span class="comment">#提交操作</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    db.rollback()     <span class="comment">#错误回滚</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    db.close()      <span class="comment">#关闭数据库</span></span><br><span class="line">cur.close()     <span class="comment">#关闭光标</span></span><br></pre></td></tr></table></figure><hr><h3 id="4、关于以上代码做几点说明"><a href="#4、关于以上代码做几点说明" class="headerlink" title="4、关于以上代码做几点说明"></a><b>4、关于以上代码做几点说明</b></h3><blockquote><p><b>4.1 pymysql.connect()函数参数</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCFgPJ.png" alt="">　　　　　　　　　　　　</p><blockquote><p><b>4.2 Connection对象支持的方法</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCFBrV.png" alt="">　　　　　　　　　　　　　　　　</p><blockquote><p><b>4.3 游标对象Cursor支持的方法</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCFDbT.png" alt="">　　　　　　　　　　　　　　　　</p><blockquote><p><b>4.4 execute方法执行过程图解</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCFyaF.png" alt="">　　　　　　　　　　　　　　　</p><blockquote><p><b>4.5 fetch* 方法</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCFR2R.png" alt="">　　　　　　　　　　　　　　　</p><blockquote><p><b>4.6 关于事务的几点说明</b></p></blockquote><p><img src="https://s1.ax1x.com/2018/11/21/FCF2G9.png" alt=""></p><blockquote><p><b>4.6.1 commit方法</b><br>　　<br>像插入、删除、更新这种对数据库造成更改的操作需要进行提交操作</p><p><b>4.6.2 什么是错误回滚?</b><br>　　　　　<br>Cursor游标对象在Python和数据库之间进行交互时可能会发生异常事件，这就类似货车在公路上可能会发生事故。在程序中我们用try-except-finally进行异常处理。比如现在在try语句我们要进行多条数据库数据的插入命令，当执行到某条语句的时候发生了异常。这时，except接收并处理异常，由于异常语句之前的插入命令已经生效，为了不对数据库造成永久性的改变，我们需要事务回滚，回到数据库最初的状态，这就是错误回滚。</p><p><b>4.7 close()方法</b><br>　　　　　　　　　　　　<br>用完游标和连接后，千万记得把他们关闭。如果不关闭就会导致连接泄露，造成一种未关闭连接现象，即连接已经不再使用，但是数据库却不能关闭，因为数据库不能确定你还要不要继续使用它。这种现象会一直耗费数据库的资源，所以用完数据库之后记得关闭连接！</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之增删改查</title>
      <link href="/MySQL%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.html"/>
      <url>/MySQL%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.html</url>
      
        <content type="html"><![CDATA[<h3 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a><b>运行MySQL</b></h3><blockquote><p>如果没有开启Mysql服务需输入<b>net start mysql;</b>命令</p></blockquote><p><b>1: cd 到mysql bin目录下：</b><br><img src="https://s1.ax1x.com/2018/10/29/ig8ksf.png" alt=""></p><p><b>2：链接到本地数据库：</b><br><img src="https://s1.ax1x.com/2018/10/29/ig8Pzt.png" alt=""></p><p><b><em>-h localhost表示链接到本地数据库，-u表示数据库用户名（默认为root），-p表示数据库密码（默认为root）</em></b><br><span id="more"></span><br><b>3：导入sql文件</b></p><blockquote><p>mysql&gt;create database dbname;<br>mysql&gt;show databases;<br>mysql&gt;use dbname;<br>mysql&gt;source c:\emmm.sql</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/29/ig8pid.png" alt=""></p><p><b>4: 删除数据库</b></p><blockquote><p>drop database dbname；</p></blockquote><p><strong>5：创建表单：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE doubanmovie (</span><br><span class="line">    name VARCHAR(100) NOT NULL, # 电影名字</span><br><span class="line">    info VARCHAR(150), # 电影信息</span><br><span class="line">    rating VARCHAR(10), # 评分</span><br><span class="line">    num VARCHAR(10), # 评论人数</span><br><span class="line">    quote VARCHAR(100), # 经典语句</span><br><span class="line">    img_url VARCHAR(100), # 电影图片</span><br><span class="line">)default charset=utf8;</span><br></pre></td></tr></table></figure></p><hr><h3 id="数据库操作增删改查："><a href="#数据库操作增删改查：" class="headerlink" title="数据库操作增删改查："></a><b>数据库操作增删改查：</b></h3><h4 id="1-增"><a href="#1-增" class="headerlink" title="1. 增"></a><b>1. 增</b></h4><p><img src="https://s1.ax1x.com/2018/10/29/ig8AL8.png" alt=""></p><p><img src="https://s1.ax1x.com/2018/10/29/ig3zIH.png" alt=""></p><hr><h4 id="2-删"><a href="#2-删" class="headerlink" title="2. 删"></a><b>2. 删</b></h4><h5 id="2-1-删除部分记录"><a href="#2-1-删除部分记录" class="headerlink" title="2.1 删除部分记录"></a><b>2.1 删除部分记录</b></h5><p><img src="https://s1.ax1x.com/2018/10/29/ig89JA.png" alt=""></p><h5 id="2-2-删除全部记录"><a href="#2-2-删除全部记录" class="headerlink" title="2.2 删除全部记录"></a><b>2.2 删除全部记录</b></h5><p><img src="https://s1.ax1x.com/2018/10/29/ig8CRI.png" alt=""></p><hr><h4 id="3-改"><a href="#3-改" class="headerlink" title="3. 改"></a><b>3. 改</b></h4><h5 id="3-1-更新部分数据"><a href="#3-1-更新部分数据" class="headerlink" title="3.1 更新部分数据"></a><b>3.1 更新部分数据</b></h5><p><img src="https://s1.ax1x.com/2018/10/29/ig8Zdg.png" alt=""></p><h5 id="3-2-更新全部数据"><a href="#3-2-更新全部数据" class="headerlink" title="3.2 更新全部数据"></a><b>3.2 更新全部数据</b></h5><p><img src="https://s1.ax1x.com/2018/10/29/ig8FQP.png" alt=""></p><hr><h4 id="4-查"><a href="#4-查" class="headerlink" title="4. 查"></a><b>4. 查</b></h4><h5 id="4-1-查询所有字段"><a href="#4-1-查询所有字段" class="headerlink" title="4.1 查询所有字段"></a><b>4.1 查询所有字段</b></h5><blockquote><p>select 字段名1，字段名2，… from 表名</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/29/ig8VeS.png" alt=""></p><h5 id="4-2-在select语句中使用（’-’）通配符代替所有字段"><a href="#4-2-在select语句中使用（’-’）通配符代替所有字段" class="headerlink" title="4.2 在select语句中使用（’*’）通配符代替所有字段"></a><b>4.2 在select语句中使用（’*’）通配符代替所有字段</b></h5><blockquote><p>select * from 表名;</p></blockquote><h5 id="4-3-查询指定的部分字段"><a href="#4-3-查询指定的部分字段" class="headerlink" title="4.3 查询指定的部分字段"></a><b>4.3 查询指定的部分字段</b></h5><blockquote><p>语法：select 字段名1，字段名2，… from 表名;<br>举例：查询student2表中的name字段和gender字段<br>命令：select name,gender from student2;</p></blockquote><h5 id="4-4-带关系运算符的查询"><a href="#4-4-带关系运算符的查询" class="headerlink" title="4.4 带关系运算符的查询"></a><b>4.4 带关系运算符的查询</b></h5><blockquote><p>select 字段名1，字段名2，… from 表名  where 条件表达式</p></blockquote><h5 id="4-5-带-BETWEEN-AND-关键字的查询"><a href="#4-5-带-BETWEEN-AND-关键字的查询" class="headerlink" title="4.5 带 BETWEEN AND  关键字的查询"></a><b>4.5 带 BETWEEN AND  关键字的查询</b></h5><blockquote><p>between and 用于判断某个字段的值是否在指定范围之内，若在，则该字段所在的记录会被查询出来，反之不会。</p></blockquote><p>语法：select { 字段名1，字段名2，… } from  表名 where 字段名 [ not ] between 值 1  and  值 2;<br>举例：查询student2表中id值在2~5之间的人的id和name<br>命令：select id,name from students where id between 2 and 5;</p><h5 id="4-6-带-distinct-关键字的查询"><a href="#4-6-带-distinct-关键字的查询" class="headerlink" title="4.6 带 distinct 关键字的查询"></a><b>4.6 带 distinct 关键字的查询</b></h5><blockquote><p>很多表中某些字段的数据存在重复的值，可以使用DISTINCT关键字来过滤重复的值，只保留一个值。</p></blockquote><p>语法：SELECT DISTINCT 字段名 FROM 表名；<br>举例：查询student2表中gender字段的值，结果中不允许出行重复的值。<br>命令：SELECT DISTINCT gender FROM student2;</p><h5 id="4-7-带-LIKE-关键字的查询"><a href="#4-7-带-LIKE-关键字的查询" class="headerlink" title="4.7 带 LIKE 关键字的查询"></a><b>4.7 带 LIKE 关键字的查询</b></h5><blockquote><p>语法：SELECT * | 字段名1，字段名2，… FROM 表名 WHERE 字段名 [ NOT ] LIKE ‘匹配字符串’;</p><p><b>（1）百分号（%）通配符</b><br>匹配任意长度的字符串，包括空字符串。例如，字符串“ c% ”匹配以字符 c 开始，任意长度的字符串，如“ ct  ”，“ cut ”，“ current ”等；字符串“ c%g ”表示以字符 c 开始，以 g 结尾的字符串；字符串“ %y% ”表示包含字符“ y ”的字符串，无论“ y ”在字符串的什么位置。</p><p>举例1：查询student2表中name字段以字符“ s ”开头的人的id,name<br>命令：SELECT id,name FROM student2  WHERE name LIKE “S%”; </p><p>举例2：查询student2表中name字段以字符“ w ”开始，以字符“ g ”结尾的人的id，name。<br>命令：SELECT id,name FROM student2 WHERE name LIKE ‘w%g’;</p><p>举例3：查询student2表中name字段不包含“ y ”的人的id，name。<br>命令：SELECT id,name FROM student2 WHERE name NOT LIKE ‘%y%’;</p></blockquote><p><b>（2）下划线通配符</b></p><blockquote><p>下划线通配符只匹配单个字符，若要匹配多个字符，需要使用多个下划线通配符。例如，字符串“ cu_ ”匹配以字符串“ cu ”开始，长度为3的字符，如“ cut ”，“ cup ”；字符串“ c__l”匹配在“ c ”和“ l ”之间包含两个字符的字符串，如“ cool ”。</p><p>举例：查询在student2表中name字段值以“ wu ”开始，以“ ong ”结束，并且中间只有一个字符的记录。<br>命令：SELECT * FROM student2 WHERE name LIKE ‘wu_ong’;</p></blockquote><hr><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a><b>高级查询</b></h3><p><b>（1）COUNT()函数：统计记录的条数</b></p><blockquote><p>举例：查询student2表中一共有多少条记录<br>命令：SELECT COUNT(*) FROM student2;</p></blockquote><p><b>（2）SUM()函数：求出表中某个字段所有值的总和</b></p><blockquote><p>语法：SELECT  SUM(字段名) FROM 表名；<br>举例：求出student2表中grade字段的总和<br>命令：SELECT SUM(grade) FROM student2;</p></blockquote><p><b>（3）AVG()函数：求出表中某个字段所有值的平均值</b></p><blockquote><p>语法：SELECT AVG(字段名) FROM 表名；<br>举例：求出student2表中grade字段的平均值<br>命令：SELECT AVG(grade) FROM student2;</p></blockquote><p><b>（4）MAX()函数：求出表中某个字段所有值的最大值</b></p><blockquote><p>语法：SELECT MAX(字段名) FROM 表名；<br>举例：求出student2表中所有人grade字段的最大值<br>命令：SELECT MAX(grade) FROM student2;</p></blockquote><p><b>（5）MIN()函数：求出表中某个字段所有值的最小值</b></p><blockquote><p>语法：SELECT MIN(字段名) FROM 表名；<br>举例：求出student2表中所有人grade字段的最小值<br>命令：SELECT MIN(grade) FROM student2;</p></blockquote><hr><h3 id="对查询结果进行排序"><a href="#对查询结果进行排序" class="headerlink" title="对查询结果进行排序"></a><b>对查询结果进行排序</b></h3><p>语法：SELECT 字段名1，字段名2，… FROM 表名 ORDER BY 字段名1 [ ASC | DESC ],字段名2 [ ASC|DESC ]…<br>　　　　　　　　　　　　　　　　　　　　<br><b>在该语法中指定的字段名是对查询结果进行排序的依据，ASC表示升序排列，DESC 表示降序排列，默认情况是升序排列。</b>　　　　　　　　　　　　　　　　　　　　　　　　　　</p><blockquote><p>举例1：查出student2表中的所有记录，并按照grade字段进行降序排序<br>命令：SELECT * FROM student2 ORDER BY grade DESC;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 用CSV模块读写CSV文件</title>
      <link href="/Python3-%E7%94%A8CSV%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99CSV%E6%96%87%E4%BB%B6.html"/>
      <url>/Python3-%E7%94%A8CSV%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99CSV%E6%96%87%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言-CSV简介"><a href="#前言-CSV简介" class="headerlink" title="前言: CSV简介"></a><b>前言: CSV简介</b></h3><p><b>CSV (Comma Separated Values)</b></p><p>CSV是英文Comma Separate Values（逗号分隔值）的缩写，顾名思义，文档的内容是由 “ , ” 分隔的一列列的数据构成的。CSV文档是一种编辑方便，可视化效果极佳的数据存储方式。而Python中有着非常强大的库可以处理这种文档，所以，如果你经常用Python处理数据的话，CSV文档当然是一种简单快捷的轻量级选择。下面我将以一个数据处理的例子入手，展现CSV文档的创建和编辑，以及Python是如何对CSV文档读写的。</p><hr><h3 id="一、CSV文档的创建和编辑"><a href="#一、CSV文档的创建和编辑" class="headerlink" title="一、CSV文档的创建和编辑 "></a><b>一、CSV文档的创建和编辑 </b></h3><p><b>1. 良好的Excel交互</b> </p><p>(1) Excel创建CSV<br>说到CSV文档，大家可能不熟悉，不过Excel想必没有人不知道，我们经常使用Excel负责数据的存储，编辑以及轻量级的计算。而CSV文档最大的优点就是能和Excel进行方便的交互，我们可以很方便地通过Excel创建、查看以及编辑CSV文档。<br><span id="more"></span><br>在Excel中编辑完数据后，保存文件的时候，会出现一种文件格式，就是 .csv ，如图：<br><img src="http://www.codexiu.cn/static/blog/imagesw8/2016/08/26/full/cc083a2d132c9c2e2757634a2aaeb3d8de71faa0.jpg" alt=""></p><p>然后现在点击保存，会发现“文件格式”的选项中有“逗号分隔值(.csv)”：</p><p><img src="http://www.codexiu.cn/static/blog/imagesw8/2016/08/26/full/713ddcea10b12d1860bf589f094c259b22b39466.jpg" alt=""></p><p>我们选择文件格式为.csv存储，这样，就通过Excel成功创建了一个CSV文档。</p><p>(2) 文本访问和编辑CSV<br>如果现在我们将刚才创建好的CSV文档直接双击点开，他会默认由Excel打开，依旧和上边相同，用Excel可以很方便的编辑，修改数据，这里不再赘述。我要说的是CSV文档也可以以文本的形式展现出来，比如，我现在把刚才保存的CSV文档用Sublime打开，展示如下：<br><img src="http://www.codexiu.cn/static/blog/imagesw8/2016/08/26/full/297d0e4ff22a8521f6e2509ed766cf68b48dfab6.jpg" alt=""></p><p>这我们就非常直观地明白为什么叫“逗号分隔值”了，数据之间是由 “,” 分隔开的，且格式非常规范，没有多余的空格，空行等。</p><hr><h3 id="二、Python读写CSV文档"><a href="#二、Python读写CSV文档" class="headerlink" title="二、Python读写CSV文档 "></a>二、<b>Python读写CSV文档 </b></h3><h4 id="1、CSV模块中的函数"><a href="#1、CSV模块中的函数" class="headerlink" title="1、CSV模块中的函数"></a><b>1、CSV模块中的函数</b></h4><p><b>1.1 读取CSV文件：</b></p><ul><li><b>reader(csvfile,  dialect=’excel’,  **fmtparams)</b><blockquote><p>参数说明：<br>csvfile，必须是支持迭代(Iterator)的对象，可以是文件(file)对象或者列表(list)对象，如果是文件对象，打开时需要加”b”标志参数。</p></blockquote></li></ul><blockquote><p>dialect，编码风格，默认为excel的风格，也就是用逗号（,）分隔，dialect方式也支持自定义，通过调用register_dialect方法来注册。</p></blockquote><p>＞fmtparam，格式化参数，用来覆盖之前dialect对象指定的编码风格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxx.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> myFile:</span><br><span class="line">    <span class="comment">#读取csv文件，返回的是迭代类型</span></span><br><span class="line">    lines = csv.reader(myFile)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>上面程序的效果是将csv文件中的文本按行打印，每一行的元素都是以逗号分隔符’,’分隔得来</b></p><blockquote><p>例如程序输出结果：<br>[‘1’, ‘2’]<br>[‘3’, ‘a’]<br>[‘4’, ‘b’]</p><hr><p><b>1.2 存为CSV文件：</b></p><ul><li><b>writer(csvfile, dialect=’excel’, **fmtparams)</b></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;xxx.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> myFile:    </span><br><span class="line">    myWriter=csv.writer(myFile)</span><br><span class="line">    myWriter.writerow([<span class="number">7</span>,<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">    myWriter.writerow([<span class="number">8</span>,<span class="string">&#x27;h&#x27;</span>])</span><br><span class="line">    myList=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">    myWriter.writerows(myList)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><b>‘w’表示写模式。</b></p><p><b>首先open()函数打开当前路径下的名字为’xxx.csv’的文件，如果不存在这个文件，则创建它，返回myFile文件对象。如果文件’xxx.csv’事先存在，调用writer函数会先清空原文件中的文本，再执行writerow/writerows方法。</b></p><p><b>csv.writer(myFile)返回writer对象myWriter。</b></p><p><b>writerow()方法是一行一行写入，writerows方法是一次写入多行。</b></p></blockquote><p><b>1.3 以字典的形式读出：</b></p><ul><li><b>DictReader()</b></li></ul><p>假设CSV文件的内容如下图所示，DictReader会将第一行的内容（类标题）作为key值，第二行开始才是数据内容。即图中的CSV文件有2列7行数据，第一列的key值为id，第二列的key值为class： </p><p><img src="https://img-blog.csdn.net/20180711190504142?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbWF0b21hcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;name.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    reader = csv.DictReader(fp)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="comment">#循环打印数据的id和class值，此循环执行7次</span></span><br><span class="line">        <span class="built_in">print</span>(line[<span class="string">&#x27;id&#x27;</span>],line[<span class="string">&#x27;class&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>打印结果为：<br>0 5<br>1 4<br>2 13<br>…<br>6 15</p></blockquote><p><b>1.4 以字典的形式写入：</b></p><ul><li><b>DictWriter()</b></li></ul><p>DictReader可以用来把CSV文件以字典的形式读出，当然还有相对的DictWriter以字典的形式写入内容，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;name.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="comment">#写入列标题，即DictWriter构造方法的fieldnames参数，生成writer对象</span></span><br><span class="line">    writer = csv.DictWriter(fp,fieldnames=[<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;class&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#但是如果此时直接写入内容，会导致没有数据名，所以，应先写数据名</span></span><br><span class="line">    <span class="comment">#csv提供了专门的函数 writeheader()来实现添加文件头（数据名），简化开发者的工作</span></span><br><span class="line">    writer.writeheader()</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#写入数据</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas:</span><br><span class="line">        writer.writerow(&#123;<span class="string">&#x27;id&#x27;</span>:data[<span class="number">0</span>],<span class="string">&#x27;class&#x27;</span>:data[<span class="number">1</span>]&#125;)</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> CSV </tag>
            
            <tag> 文件IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 OS模块常用命令总结</title>
      <link href="/Python3-OS%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html"/>
      <url>/Python3-OS%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://blog.csdn.net/lygzscnt12/article/details/52470017?utm_source=blogxgwz1">https://blog.csdn.net/lygzscnt12/article/details/52470017?utm_source=blogxgwz1</a></p><h3 id="一、OS模块概述"><a href="#一、OS模块概述" class="headerlink" title="一、OS模块概述"></a><b>一、OS模块概述</b></h3><p>Python3 OS模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的(一语中的）。<br><span id="more"></span></p><h3 id="二、OS模块常用方法"><a href="#二、OS模块常用方法" class="headerlink" title="二、OS模块常用方法"></a><b>二、OS模块常用方法</b></h3><p><b>1、os.name</b><br>输出字符串指示正在使用的平台。如果是window 则用’nt’表示，对于Linux/Unix用户，它是’posix’。</p><p><b>2、os.getcwd()</b><br>函数得到当前工作目录，即当前Python脚本工作的目录路径。</p><p><b>3、os.listdir()</b><br>返回指定目录下的所有文件和目录名。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(os.getcwd())</span><br><span class="line">[<span class="string">&#x27;Django&#x27;</span>, <span class="string">&#x27;DLLs&#x27;</span>, <span class="string">&#x27;Doc&#x27;</span>, <span class="string">&#x27;include&#x27;</span>, <span class="string">&#x27;Lib&#x27;</span>, <span class="string">&#x27;libs&#x27;</span>, <span class="string">&#x27;LICENSE.txt&#x27;</span>, <span class="string">&#x27;MySQL-python-wininst.log&#x27;</span>, <span class="string">&#x27;NEWS.txt&#x27;</span>, <span class="string">&#x27;PIL-wininst.log&#x27;</span>, <span class="string">&#x27;python.exe&#x27;</span>, <span class="string">&#x27;pythonw.exe&#x27;</span>, <span class="string">&#x27;README.txt&#x27;</span>, <span class="string">&#x27;RemoveMySQL-python.exe&#x27;</span>, <span class="string">&#x27;RemovePIL.exe&#x27;</span>, <span class="string">&#x27;Removesetuptools.exe&#x27;</span>, <span class="string">&#x27;Scripts&#x27;</span>, <span class="string">&#x27;setuptools-wininst.log&#x27;</span>, <span class="string">&#x27;tcl&#x27;</span>, <span class="string">&#x27;Tools&#x27;</span>, <span class="string">&#x27;w9xpopen.exe&#x27;</span>]</span><br></pre></td></tr></table></figure></p><p><b>4、os.remove()</b><br>删除一个文件。</p><p><b>5、os.system()</b><br>运行shell命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&#x27;cmd&#x27;</span>) <span class="comment">#启动dos</span></span><br></pre></td></tr></table></figure><p><b>6、os.sep </b><br>可以取代操作系统特定的路径分割符。</p><p><b>7、os.linesep</b><br>字符串给出当前平台使用的行终止符<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.linesep</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>            <span class="comment">#Windows使用&#x27;\r\n&#x27;，Linux使用&#x27;\n&#x27;而Mac使用&#x27;\r&#x27;。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.sep</span><br><span class="line"><span class="string">&#x27;\\&#x27;</span>              <span class="comment">#Windows</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure></p><p><b>8、os.path.split()</b><br>函数返回一个路径的目录名和文件名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;C:\\Python25\\abc.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;C:\\Python25&#x27;</span>, <span class="string">&#x27;abc.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p><b>9、os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。</b></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(os.getcwd())</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><b>10、os.path.exists()</b><br>用来检验给出的路径是否真实存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">&#x27;C:\\Python25\\abc.txt&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">&#x27;C:\\Python25&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p><b>11、os.path.abspath(name)</b><br>获得绝对路径</p><p><b>12、os.path.normpath(path)</b><br>规范path字符串形式</p><p><b>13、os.path.getsize(name)</b><br>获得文件大小，如果name是目录返回0L</p><p><b>14、os.path.splitext()</b><br>分离文件名与扩展名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p><b>15、os.path.join(path,name)</b><br>连接目录与文件名或目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;c:\\Python&#x27;</span>,<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;c:\\Python\\a.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;c:\\Python&#x27;</span>,<span class="string">&#x27;f1&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;c:\\Python\\f1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p><b>16、os.path.basename(path)</b><br>返回文件名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;a.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(<span class="string">&#x27;c:\\Python\\a.txt&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;a.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p><b>17、os.path.dirname(path)</b><br>返回文件路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="string">&#x27;c:\\Python\\a.txt&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;c:\\Python&#x27;</span></span><br></pre></td></tr></table></figure><p><b>18、os.mkdir(path) </b><br>创建一级目录<br>例如要在D盘下创建hello的目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&#x27;d:\hello&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>19、os.makedirs(path)  </b><br>创建多级目录<br>例如在D盘下创建books的目录，books目录下在创建book目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">&#x27;d:\\books\\book&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="先学这么多吧，以后边遇到再边记录…"><a href="#先学这么多吧，以后边遇到再边记录…" class="headerlink" title="先学这么多吧，以后边遇到再边记录…"></a>先学这么多吧，以后边遇到再边记录…</h3>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OS </tag>
            
            <tag> Module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈URL标准化</title>
      <link href="/%E6%B5%85%E8%B0%88URL%E6%A0%87%E5%87%86%E5%8C%96.html"/>
      <url>/%E6%B5%85%E8%B0%88URL%E6%A0%87%E5%87%86%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<p>　　1、网站所有URL尽量全部使用绝对地址，可以有效的防止网站被人家把恶意镜像。还有一重要的作用就是，网络中如果有人引用了你的网站内容，你会获得来自外界的导入链接。<br>　　2、尽量把带www与不带www的域名区别开来，尽量使用一个为常用的URL，然后另外一个做好301重定向。<br>　　3、动态URL和静态URL都差不多，正常来说影响不大,扩展名其实无关紧要。如：.html,.htm,.asp,.php等等，对搜索来说,并没有什么区别，关键一点，我们在做锚文本时，尽量选择一个常用的。<br>　　4、外链与内部链接尽量做到一致，意思其实同上，也就是做外链时尽量也做与锚文本一样的URL。<br>　　5、URL 尽量用简单的英文,最好能包括关键字的，一定要记住的我们URL不要大小写混写，建议全部用小写字母。<br>　　6、做内部锚文本时，一定要注意哪一个关键词指定的哪一个URL。千万不要出现同样的锚文本，而每次指向的URL不一样。（建议做一个长尾关键词记录单，这样可以一目了然，哪一个关键词对应哪一个URL）<br><span id="more"></span></p><h4 id="有WWW和没有WWW的区别"><a href="#有WWW和没有WWW的区别" class="headerlink" title="有WWW和没有WWW的区别"></a><b>有WWW和没有WWW的区别</b></h4><p>　　首先，我们应该知道一个常识，二级域名，是主要的没有WWW的域名。搜索引擎是有区别的，<b>有WWW和没有WWW的URL是不同的两个URL</b>，当他们指向同一个网站，会让搜索引擎不知道应该选择哪一个作为主要的URL。所以，建议一些合格的主机使用301重定向URL标准化集。</p><p>　　很多人发现有WWW和没有WWW包括不一样，通常不包括比较好，这是为什么？没有WWW站点我们几乎不碰他(优化)，因为我们不去优化它，不给他增加外部链接，甚至不添加内容链接，然后讨论一下影响。说实话没有WWW的一般不会参与关键词排名，所以你没有和他一起去，我们首选域优化通常是与网站WWW。</p><p>　　为什么不带WWW通常包括所有比较好？因为没有WWW处于正常状态，因为他没有外部链接和内部链接的重量减少。我们都知道，随着WWW经常饱受外部链接，因为我们需要与WWW关键词排名，所以我们必须努力增加外部链接和内部链接，所以矛盾。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Python3 Json模块</title>
      <link href="/%E6%B5%85%E8%B0%88Python3-Json%E6%A8%A1%E5%9D%97.html"/>
      <url>/%E6%B5%85%E8%B0%88Python3-Json%E6%A8%A1%E5%9D%97.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://f1.howzhi.com/course/2018/08-16/1536160a5350463338.jpg" alt=""></p><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a><b>基础结构</b></h3><h5 id="JSON建构于两种结构："><a href="#JSON建构于两种结构：" class="headerlink" title="JSON建构于两种结构："></a><b>JSON建构于两种结构：</b></h5><p><b>1. “名称/值”对的集合（A collection of name/value pairs）</b><br> 　　　不同的语言中，它被理解为对象（object），记录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</p><p><b>2. 值的有序列表（An ordered list of values）</b>　<br>　　　在大部分语言中，它被理解为数组（array）。<br><span id="more"></span>　　　　　　　　　</p><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a><b>基础示例</b></h3><p>简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是 JavaScript 很容易解释它，而且 JSON 可以表示比”名称 / 值对”更复杂的结构。例如，可以表示数组和复杂的对象，而不仅仅是键和值的简单列表。</p><h5 id="表示名称-值对"><a href="#表示名称-值对" class="headerlink" title="表示名称 / 值对"></a><b>表示名称 / 值对</b></h5><p>按照最简单的形式，可以用下面这样的 JSON 表示 “名称 / 值对” ：{ “firstName”: “Brett” }<br>这个示例非常基本，而且实际上比等效的纯文本 “名称 / 值对” 占用更多的空间：firstName=Brett</p><p>但是，当将多个”名称 / 值对”串在一起时，JSON 就会体现出它的价值了。首先，可以创建包含多个”名称 / 值对”的 记录，比如：</p><p>{ “firstName”: “Brett”, “lastName”:”McLaughlin”, “email”: “aaaa” }</p><p>从语法方面来看，这与”名称 / 值对”相比并没有很大的优势，但是在这种情况下 JSON 更容易使用，而且可读性更好。例如，它明确地表示以上三个值都是同一记录的一部分；花括号使这些值有了某种联系。</p><h3 id="Python3-Json模块"><a href="#Python3-Json模块" class="headerlink" title="Python3 Json模块"></a><b>Python3 Json模块</b></h3><p><b>JSON (JavaScript Object Notation)</b>  是一种轻量级的数据交换格式。Python3 可以使用 json 模块来对 JSON 数据进行编解码。</p><h4 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a><b>json.dumps</b></h4><p><em>将 Python 对象编码转化为 json 字符串</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;QzmVc1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span> : <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;City&quot;</span> : <span class="string">&quot;NanJing&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Json_data = json.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python:&quot;</span>, data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Json:&quot;</span>, Json_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Json_data))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python: &#123;&#x27;name&#x27;: &#x27;QzmVc1&#x27;, &#x27;Age&#x27;: &#x27;20&#x27;, &#x27;City&#x27;: &#x27;NanJing&#x27;&#125;</span><br><span class="line">Json: &#123;&quot;name&quot;: &quot;QzmVc1&quot;, &quot;Age&quot;: &quot;20&quot;, &quot;City&quot;: &quot;NanJing&quot;&#125;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p>转化后的 Json_data 是一个字符串类型，可以使用 <strong>enumerate</strong> 来查看一下 Json_data 字符串的索引值和对应值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(Json_data):</span><br><span class="line">    <span class="built_in">print</span>(i,v)</span><br></pre></td></tr></table></figure><p>输出结果片段：</p><blockquote><p>0 {<br>1 “<br>2 n<br>3 a<br>4 m<br>5 e<br>6 “</p></blockquote><h4 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a><b>json.loads</b></h4><p><em>将 json 格式转化为 Python 格式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;QzmVc1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span> : <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;City&quot;</span> : <span class="string">&quot;NanJing&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Json_data = json.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python:&quot;</span>, data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Json:&quot;</span>, Json_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Json_data))</span><br><span class="line">Python_data = json.loads(Json_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python:&quot;</span>,Python_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Python_data))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python: &#123;&#x27;name&#x27;: &#x27;QzmVc1&#x27;, &#x27;Age&#x27;: &#x27;20&#x27;, &#x27;City&#x27;: &#x27;NanJing&#x27;&#125;</span><br><span class="line">Json: &#123;&quot;name&quot;: &quot;QzmVc1&quot;, &quot;Age&quot;: &quot;20&quot;, &quot;City&quot;: &quot;NanJing&quot;&#125;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">Python: &#123;&#x27;name&#x27;: &#x27;QzmVc1&#x27;, &#x27;Age&#x27;: &#x27;20&#x27;, &#x27;City&#x27;: &#x27;NanJing&#x27;&#125;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure><h4 id="json-dump"><a href="#json-dump" class="headerlink" title="json.dump"></a><b>json.dump</b></h4><p><em>dump 和 dumps 的功能一样，将 dict 转化为 str 的格式，然后<b>存入文件</b>中。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;QzmVc1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Age&quot;</span> : <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;City&quot;</span> : <span class="string">&quot;NanJing&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Json_data = json.dumps(data)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;Demo.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(file))</span><br><span class="line"></span><br><span class="line">json.dump(data,file)</span><br><span class="line">json.dump(Json_data,file)</span><br><span class="line"></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="json-load"><a href="#json-load" class="headerlink" title="json.load"></a><b>json.load</b></h4><p><em>load 和 loads 的功能一样，从文件中读取 str 格式并将其转化为字符串。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;Demo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(json.load(file))</span><br></pre></td></tr></table></figure><p>load 在读取的时候，只需要文件对象一个参数即可。而 dump 在使用的时候，需要 Python 对象作为第一个传入参数，文件对象作为第二个传入参数。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><b>小结：</b></h3><p><b>dump 或 dumps， 把其他对象或者格式，转化为 json 格式，dumps 用来处理字符串，dump 用来处理文件。<br>load 或 loads ，把 json 格式转化成其他格式，loads 用来处理字符串，load 用来处理文件。</b></p>]]></content>
      
      
      <categories>
          
          <category> Python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Module </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好玩的JS特效</title>
      <link href="/%E5%A5%BD%E7%8E%A9%E7%9A%84JS%E7%89%B9%E6%95%88.html"/>
      <url>/%E5%A5%BD%E7%8E%A9%E7%9A%84JS%E7%89%B9%E6%95%88.html</url>
      
        <content type="html"><![CDATA[<h4 id="从别的博客上看到一个比较好玩的JS特效，保存了！"><a href="#从别的博客上看到一个比较好玩的JS特效，保存了！" class="headerlink" title="从别的博客上看到一个比较好玩的JS特效，保存了！"></a>从别的博客上看到一个比较好玩的JS特效，保存了！</h4><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">w, v, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w.getAttribute(v) || i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">j</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByTagName(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = j(<span class="string">&quot;script&quot;</span>),</span><br><span class="line">        w = i.length,</span><br><span class="line">        v = i[w - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">l</span>: w,</span><br><span class="line">            <span class="attr">z</span>: o(v, <span class="string">&quot;zIndex&quot;</span>, -<span class="number">1</span>),</span><br><span class="line">            <span class="attr">o</span>: o(v, <span class="string">&quot;opacity&quot;</span>, <span class="number">0.5</span>),</span><br><span class="line">            <span class="attr">c</span>: o(v, <span class="string">&quot;color&quot;</span>, <span class="string">&quot;0,0,0&quot;</span>),</span><br><span class="line">            <span class="attr">n</span>: o(v, <span class="string">&quot;count&quot;</span>, <span class="number">99</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">k</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        r = u.width = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">        n = u.height = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        e.clearRect(<span class="number">0</span>, <span class="number">0</span>, r, n);</span><br><span class="line">        <span class="keyword">var</span> w = [f].concat(t);</span><br><span class="line">        <span class="keyword">var</span> x, v, A, B, z, y;</span><br><span class="line">        t.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            i.x += i.xa,</span><br><span class="line">            i.y += i.ya,</span><br><span class="line">            i.xa *= i.x &gt; r || i.x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">            i.ya *= i.y &gt; n || i.y &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">            e.fillRect(i.x - <span class="number">0.5</span>, i.y - <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; w.length; v++) &#123;</span><br><span class="line">                x = w[v];</span><br><span class="line">                <span class="keyword">if</span> (i !== x &amp;&amp; <span class="literal">null</span> !== x.x &amp;&amp; <span class="literal">null</span> !== x.y) &#123;</span><br><span class="line">                    B = i.x - x.x,</span><br><span class="line">                    z = i.y - x.y,</span><br><span class="line">                    y = B * B + z * z;</span><br><span class="line">                    y &lt; x.max &amp;&amp; (x === f &amp;&amp; y &gt;= x.max / <span class="number">2</span> &amp;&amp; (i.x -= <span class="number">0.03</span> * B, i.y -= <span class="number">0.03</span> * z), A = (x.max - y) / x.max, e.beginPath(), e.lineWidth = A / <span class="number">2</span>, e.strokeStyle = <span class="string">&quot;rgba(&quot;</span> + s.c + <span class="string">&quot;,&quot;</span> + (A + <span class="number">0.2</span>) + <span class="string">&quot;)&quot;</span>, e.moveTo(i.x, i.y), e.lineTo(x.x, x.y), e.stroke())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.splice(w.indexOf(i), <span class="number">1</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        m(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> u = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>),</span><br><span class="line">    s = l(),</span><br><span class="line">    c = <span class="string">&quot;c_n&quot;</span> + s.l,</span><br><span class="line">    e = u.getContext(<span class="string">&quot;2d&quot;</span>),</span><br><span class="line">    r,</span><br><span class="line">    n,</span><br><span class="line">    m = <span class="built_in">window</span>.requestAnimationFrame || <span class="built_in">window</span>.webkitRequestAnimationFrame || <span class="built_in">window</span>.mozRequestAnimationFrame || <span class="built_in">window</span>.oRequestAnimationFrame || <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.setTimeout(i, <span class="number">1000</span> / <span class="number">45</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    a = <span class="built_in">Math</span>.random,</span><br><span class="line">    f = &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">max</span>: <span class="number">20000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    u.id = c;</span><br><span class="line">    u.style.cssText = <span class="string">&quot;position:fixed;top:0;left:0;z-index:&quot;</span> + s.z + <span class="string">&quot;;opacity:&quot;</span> + s.o;</span><br><span class="line">    j(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].appendChild(u);</span><br><span class="line">    k(),</span><br><span class="line">    <span class="built_in">window</span>.onresize = k;</span><br><span class="line">    <span class="built_in">window</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        i = i || <span class="built_in">window</span>.event,</span><br><span class="line">        f.x = i.clientX,</span><br><span class="line">        f.y = i.clientY</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">window</span>.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        f.x = <span class="literal">null</span>,</span><br><span class="line">        f.y = <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t = [], p = <span class="number">0</span>; s.n &gt; p; p++) &#123;</span><br><span class="line">        <span class="keyword">var</span> h = a() * r,</span><br><span class="line">        g = a() * n,</span><br><span class="line">        q = <span class="number">2</span> * a() - <span class="number">1</span>,</span><br><span class="line">        d = <span class="number">2</span> * a() - <span class="number">1</span>;</span><br><span class="line">        t.push(&#123;</span><br><span class="line">            <span class="attr">x</span>: h,</span><br><span class="line">            <span class="attr">y</span>: g,</span><br><span class="line">            <span class="attr">xa</span>: q,</span><br><span class="line">            <span class="attr">ya</span>: d,</span><br><span class="line">            <span class="attr">max</span>: <span class="number">6000</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        b()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">100</span>)</span><br><span class="line">&#125; ();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>将代码放在html页面的body里面，不要放在head里面，不然不生效，页面上即可看到好玩的动态效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github 搭建自己的个人博客</title>
      <link href="/Hexo+Github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html"/>
      <url>/Hexo+Github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><b>前言</b></h3><p>本萌新一直幻想着拥有自己的博客、自己的空间发布一些学习进度。终于腾出了时间大搞了一下，<del>身心疲惫，欲哭无泪</del>，主要还是自己真实的菜啊！下面记录的是自己搭建博客的每个步骤，尽量将所有<del>细节</del>（坑）记录下来，为有同样好奇心的小伙伴给个参考。                </p><p><img src="https://s1.ax1x.com/2018/10/25/iylB38.png" alt=""></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h3 id="搭建博客，前期需要四个工具："><a href="#搭建博客，前期需要四个工具：" class="headerlink" title="搭建博客，前期需要四个工具："></a>搭建博客，前期需要四个工具：</h3><ul><li>Hexo: Hexo快速、简洁且高效的博客框架</li><li>Git: 一款免费、开源的分布式版本控制系统</li><li>Node.js: 建立在Chrome上的JavaScript运行引擎</li><li>GitHub: 国内一款面向开发者的云端开发平台，提供代码托管，运行空间，质量控制，项目管理等功能<span id="more"></span><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4>安装必要的配置环境，如果已经安装过，可以跳过<br><b>1.1 &nbsp; 安装git</b> &nbsp;&nbsp;&nbsp; <a href="https://git-scm.com/">git下载地址</a>   </li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2789715-ee429e804f5e0f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Download"><br>找到Download,安装自己对应的系统版本，系统会自动判定你当前版本，推荐下载。如果没有推荐，那就自己选择吧，下载成功安装的步骤就不贴了。</p><p><b>1.2 &nbsp; 安装Node.js</b> &nbsp;&nbsp;&nbsp; <a href="https://nodejs.org/en/">Node.js下载地址</a><br><b>1.3 &nbsp; GitHub账号注册</b> &nbsp;&nbsp;&nbsp; <a href="https://github.com/">GitHub</a><br>GitHub账号注册过程很简单，注册流程就省略，完成之后，就开始创建博客了</p><h4 id="2-创建个人博客"><a href="#2-创建个人博客" class="headerlink" title="2. 创建个人博客"></a>2. 创建个人博客</h4><p>注册完成之后,点击头像左侧的+号, —&gt;<strong><em>New repository</em></strong>，创建新仓库</p><p><img src="https://upload-images.jianshu.io/upload_images/2789715-0eb05444b0831153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为我们创建的是个人网站，所以仓库的名称需要安装GitHub个人网站项目的规定来写。<br>规则就是：</p><blockquote><p>userName.github.io</p></blockquote><p>比如我的GitHub用户名是QzmVc1，那我就要填写<a href="QzmVc1.github.io">QzmVc1.github.io</a>，然后选择Public模式，接着点击创建仓库按钮。创建成功后，进入新仓库，点击<strong><em>Settings</em></strong>，往下找到<strong><em>GitHub Pages</em></strong>。选择一个主题，之后一个托管在GitHub上的博客就就搞定了，大概几分钟后，例如我的个人博客：<a href="QzmVc1.github.io">QzmVc1.github.io</a>就可以访问了。</p><p>这时候，你的确可以访问自己博客了，但是我们的博客访问地址是：userName.github.io，是不是一点都不满足？想用自己个性化的域名作为自己的博客地址？接下来，就需要我们去购买域名，配置成自己个性化的域名地址。</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>购买域名有很多途径，例如<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.61.79ca6d3e2uYEhL">阿里云</a>、<a href="https://cloud.tencent.com/act/domainsales?from=10029">腾讯云</a>等，这里以阿里云为例。<br>域名的价格差别比较大，我们是做个个人博客，所以买个便宜的后缀域名，推荐<em>.top</em> 域名。如图所示，价格差别较大</p><p><img src="https://i.postimg.cc/kXyYcq7K/yuming1.png" alt=""><br>&nbsp;&nbsp;<br>购买域名很简单，但是一定要注意的是，选择的域名后缀一定是可以备案的，不然只能是注册保护，无法使用，在购买时，阿里云会有提示信息：</p><p><img src="https://i.postimg.cc/T2tWq4Zh/yuming2.png" alt=""><br>&nbsp;&nbsp;<br>例如我注册的是qzmvc1.top,具体购买流程就不写了。</p><p><img src="https://i.postimg.cc/W31FZmpQ/yuming3.png" alt=""></p><p>&nbsp;&nbsp;<br><b>买完域名之后一定要实名注册！！！</b>这坑我掉进去一天了，一直在等dns同步（哭死我了x…</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>购买完成后，选择<em>管理控制台—域名—域名服务—域名列表</em>，看到你购买的域名，选择解析</p><p>参考下图，修改下面信息<br>分别添加两个CNAME记录类型。一个主机记录为www，代表可以解析<em>www.qzmvc1.top</em> 的域名；另一个为@，代表<em>qzmvc1.top</em>。记录值就是我们的GitHub仓库地址：<em>userName.github.io</em><br><img src="https://s1.ax1x.com/2018/10/25/iyuhOs.png" alt=""></p><p>&nbsp;&nbsp;<br>这里，我们已经完成了域名解析工作，回到GitHub，完成域名和<em>GitHub Pages</em> 的绑定</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>回到Github, 选择我们创建的个人域名仓库，选择<em>Settings</em>，找到<em>GitHub pages</em>，将我们购买的域名地址填入下方<em>Custom domain</em>，这时候我们的<em>GitHub pages</em> 和域名就绑定到一起。</p><p><img src="https://s1.ax1x.com/2018/10/25/iyuIwq.png" alt=""></p><p><b>坑又来了！！</b>实际上我们是点不了保存按钮的。那怎么办呢？经过多番搜索，我们只需在博客仓库下的<em>code</em> 中创建一个大写CNAME的文件就行。具体操作如下图所示:</p><p><img src="https://s1.ax1x.com/2018/10/25/iyuoT0.png" alt=""><br><img src="https://s1.ax1x.com/2018/10/25/iyu5mn.png" alt=""></p><p>&nbsp;&nbsp;<br>到了这一步，我们已经完成了个人博客的创建，不过你肯定有疑问了，为什么你的博客主题那么个性？别急，下面就来试试。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装Hexo，在自己认为合适的地方创个文件夹，我是在C盘建了一个<em>Blog_Test</em> 文件夹，然后在该文件夹下右击进入git bash。</p><h4 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1. 安装"></a><b>1. 安装</b></h4><p><b>输入npm install hexo -g，开始安装Hexo</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMLL9.png" alt=""></p><p><b>输入hexo -v，检查hexo是否安装成功</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMXZR.png" alt=""></p><p><b>输入hexo init，初始化该文件夹（时间可能会有点长，慢慢等就好）</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMhaq.png" alt=""><br><b>看到后面的“Start blogging with Hexo！”，是不是很激动！</b></p><p><b>输入npm install，安装所需要的组件</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMRqs.png" alt=""></p><p><b>输入hexo g，生成静态文件，首次体验Hexo</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMfZn.png" alt=""></p><p><b>输入hexo s，开启服务器，访问该网址，正式体验Hexo</b><br><img src="https://s1.ax1x.com/2018/10/25/iyM4I0.png" alt=""></p><p><b>假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器</b><br><b>接着输入“hexo server -p 端口号”来改变端口号</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMoGT.png" alt=""></p><h4 id="2-ssh设置"><a href="#2-ssh设置" class="headerlink" title="2. ssh设置"></a><b>2. ssh设置</b></h4><p><b>将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMIiV.png" alt=""></p><p><b>输入cd ~/.ssh，检查是否由.ssh的文件夹</b><br><b>输入ls，列出该文件下的内容。下图说明存在</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMTRU.png" alt=""></p><p><b>输入ssh-keygen -t rsa -C “1026740678@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</b><br><img src="https://s1.ax1x.com/2018/10/25/iyM7zF.png" alt=""></p><p><b>输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMbM4.png" alt=""></p><p><b>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</b><br><img src="https://s1.ax1x.com/2018/10/25/iyMqsJ.png" alt=""></p><p><b>登录Github，点击头像下的<em>settings</em>，添加ssh</b><br><b>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</b><br><img src="https://s1.ax1x.com/2018/10/25/iylCt0.png" alt="">    </p><p><b>输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了！！</b></p><h4 id="3-repo修改"><a href="#3-repo修改" class="headerlink" title="3. repo修改"></a><b>3. repo修改</b></h4><p><b>配置Deployment，在其文件夹中，找到<em>_config.yml</em> 文件，修改repository值（在末尾）</b><br><img src="https://s1.ax1x.com/2018/10/25/iyQRSO.png" alt=""></p><p><b>repository值是你在github项目里的ssh（右下角）</b><br><img src="https://s1.ax1x.com/2018/10/25/iyQWlD.png" alt=""></p><h4 id="4-新建博客"><a href="#4-新建博客" class="headerlink" title="4. 新建博客"></a><b>4. 新建博客</b></h4><p><b>新建一篇博客，在git bash执行命令：hexo new post “博客名”</b><br><b>这时候在文件夹<em>_posts</em> 目录下将会看到已经创建的文件   </b>   </p><p><img src="https://s1.ax1x.com/2018/10/25/iyQ7kt.png" alt="">       </p><blockquote><p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git —save<br>使用编辑器编好文章（推荐Notepad++），那么就可以使用命令<b>hexo g &amp;&amp; hexo d &amp;&amp; hexo s</b>，生成以及部署了<br>//hexo g生成静态文件 &nbsp;&nbsp;hexo d部署到gitbub上&nbsp;&nbsp;hexo s启动服务器<br>部署成功后访问你的地址：<a href="http://qzmvc1.top">http://qzmvc1.top</a> &nbsp;那么将看到生成的文章     </p></blockquote><p>&nbsp;&nbsp;<br><b>到此，最基本也最全面的Hexo+GitHub新建博客也就大功告成啦！ 呼~~</b><br><b>下面就让我们谈谈最吸引人的hexo主题设置吧！</b></p><h3 id="Hexo主题设置"><a href="#Hexo主题设置" class="headerlink" title="Hexo主题设置"></a><b>Hexo主题设置</b></h3><p><a href="https://hexo.io/themes/">选择一个自己喜欢的Hexo主题</a><br>这个网站有很多主题可以供我们去选择，如下图所示。每一个主题都有对应网站可以预览，并且都有 Github 地址，我们可以照着 Github 的 wiki 就可以安装了，过程都比较简单。         </p><p><img src="https://s1.ax1x.com/2018/10/25/iy1EPP.png" alt=""> &nbsp;&nbsp;<br>&nbsp;&nbsp;<br><b>这里我们以Diaspora举例</b><br><img src="https://s1.ax1x.com/2018/10/25/iy1k5t.png" alt=""> &nbsp;&nbsp;<br>&nbsp;&nbsp;  </p><ol><li>我们来到该主题的Github上，如下图所示：<br><img src="https://s1.ax1x.com/2018/10/25/iy1iVA.png" alt=""><br>&nbsp;&nbsp;</li><li>进入博客文件中的<em>theme</em> 目录下，右击进入git bash命令，执行语句<blockquote><p>git clone <a href="https://github.com/Fechin/hexo-theme-diaspora.git">https://github.com/Fechin/hexo-theme-diaspora.git</a>   </p></blockquote></li></ol><p><img src="https://s1.ax1x.com/2018/10/25/iy1Cbd.png" alt=""><br>&nbsp;&nbsp;   </p><ol><li>结束之后我们就能在<em>theme</em> 目录下看到我们的主题目录啦~~~<br><img src="https://s1.ax1x.com/2018/10/25/iy1FUI.png" alt="">      </li></ol><p>&nbsp;&nbsp;</p><ol><li>最后，我们进入博客根目录<em>_config.yml</em> 文件下设置<em>theme</em> 的值，大功告成啦~~~  （撒花~<br><img src="https://s1.ax1x.com/2018/10/25/iy1V8f.png" alt=""><br>&nbsp;&nbsp;</li></ol><p><b>别忘了hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; hexo s命令哦，只有通过<em>hexo deploy</em> 命令部署到github才能看到自己写的博客！</b><br>&nbsp;&nbsp;</p><h4 id="以上就是简单的主题设置，有关主题的细节设置待我细细摸索之后再补发吧！接下来就让我们愉快的畅玩吧！"><a href="#以上就是简单的主题设置，有关主题的细节设置待我细细摸索之后再补发吧！接下来就让我们愉快的畅玩吧！" class="headerlink" title="以上就是简单的主题设置，有关主题的细节设置待我细细摸索之后再补发吧！接下来就让我们愉快的畅玩吧！"></a><b>以上就是简单的主题设置，有关主题的细节设置待我细细摸索之后再补发吧！接下来就让我们愉快的畅玩吧！</b></h4><p><img src="https://s1.ax1x.com/2018/10/25/iy1nKg.jpg" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
